/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.federation/entry.42f9d6ddc353237f58b0246cec23d53e.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.federation/entry.42f9d6ddc353237f58b0246cec23d53e.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var C_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_webpack_bundler_runtime_dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@module-federation/webpack-bundler-runtime/dist/index.esm.js */ \"./node_modules/@module-federation/webpack-bundler-runtime/dist/index.esm.js\");\n/* harmony import */ var C_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_node_dist_src_runtimePlugin_js_runtimePlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@module-federation/node/dist/src/runtimePlugin.js?runtimePlugin */ \"./node_modules/@module-federation/node/dist/src/runtimePlugin.js?runtimePlugin\");\n/* harmony import */ var C_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_cjs_runtimePlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.cjs?runtimePlugin */ \"./node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.cjs?runtimePlugin\");\n\n\n\n\nif(!__webpack_require__.federation.runtime){\n\tvar prevFederation = __webpack_require__.federation;\n\t__webpack_require__.federation = {}\n\tfor(var key in C_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_webpack_bundler_runtime_dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]){\n\t\t__webpack_require__.federation[key] = C_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_webpack_bundler_runtime_dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][key];\n\t}\n\tfor(var key in prevFederation){\n\t\t__webpack_require__.federation[key] = prevFederation[key];\n\t}\n}\nif(!__webpack_require__.federation.instance){\n\tvar pluginsToAdd = [\n\t\tC_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_node_dist_src_runtimePlugin_js_runtimePlugin__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ? (C_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_node_dist_src_runtimePlugin_js_runtimePlugin__WEBPACK_IMPORTED_MODULE_1__[\"default\"][\"default\"] || C_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_node_dist_src_runtimePlugin_js_runtimePlugin__WEBPACK_IMPORTED_MODULE_1__[\"default\"])() : false,\n\t\tC_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_cjs_runtimePlugin__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? (C_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_cjs_runtimePlugin__WEBPACK_IMPORTED_MODULE_2__[\"default\"][\"default\"] || C_Users_Win_11_Desktop_React_MicroFrontend_micro_frontend_chart_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_cjs_runtimePlugin__WEBPACK_IMPORTED_MODULE_2__[\"default\"])() : false,\n\t].filter(Boolean);\n\t__webpack_require__.federation.initOptions.plugins = __webpack_require__.federation.initOptions.plugins ? \n\t__webpack_require__.federation.initOptions.plugins.concat(pluginsToAdd) : pluginsToAdd;\n\t__webpack_require__.federation.instance = __webpack_require__.federation.runtime.init(__webpack_require__.federation.initOptions);\n\tif(__webpack_require__.federation.attachShareScopeMap){\n\t\t__webpack_require__.federation.attachShareScopeMap(__webpack_require__)\n\t}\n\tif(__webpack_require__.federation.installInitialConsumes){\n\t\t__webpack_require__.federation.installInitialConsumes()\n\t}\n\n\tif(!__webpack_require__.federation.isMFRemote && __webpack_require__.federation.prefetch){\n\t__webpack_require__.federation.prefetch()\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLmZlZGVyYXRpb24vZW50cnkuNDJmOWQ2ZGRjMzUzMjM3ZjU4YjAyNDZjZWMyM2Q1M2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFvSztBQUNDO0FBQ3dCOztBQUU3TCxJQUFJLG1CQUFtQjtBQUN2QixzQkFBc0IsbUJBQW1CO0FBQ3pDLENBQUMsbUJBQW1CO0FBQ3BCLGdCQUFnQixnTEFBVTtBQUMxQixFQUFFLG1CQUFtQixtQkFBbUIsZ0xBQVU7QUFDbEQ7QUFDQTtBQUNBLEVBQUUsbUJBQW1CO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBLEVBQUUsbUxBQVEsSUFBSSw4TEFBZ0IsSUFBSSxtTEFBUTtBQUMxQyxFQUFFLDJNQUFRLElBQUksc05BQWdCLElBQUksMk1BQVE7QUFDMUM7QUFDQSxDQUFDLG1CQUFtQixrQ0FBa0MsbUJBQW1CO0FBQ3pFLENBQUMsbUJBQW1CO0FBQ3BCLENBQUMsbUJBQW1CLHVCQUF1QixtQkFBbUIseUJBQXlCLG1CQUFtQjtBQUMxRyxJQUFJLG1CQUFtQjtBQUN2QixFQUFFLG1CQUFtQixnQ0FBZ0MsbUJBQW1CO0FBQ3hFO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkIsRUFBRSxtQkFBbUI7QUFDckI7O0FBRUEsS0FBSyxtQkFBbUIsMEJBQTBCLG1CQUFtQjtBQUNyRSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFdpbiAxMVxcRGVza3RvcFxcUmVhY3QtTWljcm9Gcm9udGVuZFxcbWljcm8tZnJvbnRlbmRcXGNoYXJ0XFxub2RlX21vZHVsZXNcXC5mZWRlcmF0aW9uXFxlbnRyeS40MmY5ZDZkZGMzNTMyMzdmNThiMDI0NmNlYzIzZDUzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZmVkZXJhdGlvbiBmcm9tICdDOi9Vc2Vycy9XaW4gMTEvRGVza3RvcC9SZWFjdC1NaWNyb0Zyb250ZW5kL21pY3JvLWZyb250ZW5kL2NoYXJ0L25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vd2VicGFjay1idW5kbGVyLXJ1bnRpbWUvZGlzdC9pbmRleC5lc20uanMnO1xuaW1wb3J0IHBsdWdpbl8wIGZyb20gJ0M6L1VzZXJzL1dpbiAxMS9EZXNrdG9wL1JlYWN0LU1pY3JvRnJvbnRlbmQvbWljcm8tZnJvbnRlbmQvY2hhcnQvbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9ub2RlL2Rpc3Qvc3JjL3J1bnRpbWVQbHVnaW4uanM/cnVudGltZVBsdWdpbic7XG5pbXBvcnQgcGx1Z2luXzEgZnJvbSAnQzovVXNlcnMvV2luIDExL0Rlc2t0b3AvUmVhY3QtTWljcm9Gcm9udGVuZC9taWNyby1mcm9udGVuZC9jaGFydC9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL25leHRqcy1tZi9kaXN0L3NyYy9wbHVnaW5zL2NvbnRhaW5lci9ydW50aW1lUGx1Z2luLmNqcz9ydW50aW1lUGx1Z2luJztcblxuaWYoIV9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5ydW50aW1lKXtcblx0dmFyIHByZXZGZWRlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24gPSB7fVxuXHRmb3IodmFyIGtleSBpbiBmZWRlcmF0aW9uKXtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb25ba2V5XSA9IGZlZGVyYXRpb25ba2V5XTtcblx0fVxuXHRmb3IodmFyIGtleSBpbiBwcmV2RmVkZXJhdGlvbil7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uW2tleV0gPSBwcmV2RmVkZXJhdGlvbltrZXldO1xuXHR9XG59XG5pZighX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluc3RhbmNlKXtcblx0dmFyIHBsdWdpbnNUb0FkZCA9IFtcblx0XHRwbHVnaW5fMCA/IChwbHVnaW5fMC5kZWZhdWx0IHx8IHBsdWdpbl8wKSgpIDogZmFsc2UsXG5cdFx0cGx1Z2luXzEgPyAocGx1Z2luXzEuZGVmYXVsdCB8fCBwbHVnaW5fMSkoKSA6IGZhbHNlLFxuXHRdLmZpbHRlcihCb29sZWFuKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluaXRPcHRpb25zLnBsdWdpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uaW5pdE9wdGlvbnMucGx1Z2lucyA/IFxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uaW5pdE9wdGlvbnMucGx1Z2lucy5jb25jYXQocGx1Z2luc1RvQWRkKSA6IHBsdWdpbnNUb0FkZDtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLnJ1bnRpbWUuaW5pdChfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uaW5pdE9wdGlvbnMpO1xuXHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uYXR0YWNoU2hhcmVTY29wZU1hcCl7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmF0dGFjaFNoYXJlU2NvcGVNYXAoX193ZWJwYWNrX3JlcXVpcmVfXylcblx0fVxuXHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uaW5zdGFsbEluaXRpYWxDb25zdW1lcyl7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluc3RhbGxJbml0aWFsQ29uc3VtZXMoKVxuXHR9XG5cblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pc01GUmVtb3RlICYmIF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5wcmVmZXRjaCl7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5wcmVmZXRjaCgpXG5cdH1cbn0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.federation/entry.42f9d6ddc353237f58b0246cec23d53e.js\n");

/***/ }),

/***/ "./node_modules/@module-federation/error-codes/dist/index.esm.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@module-federation/error-codes/dist/index.esm.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUILD_001: () => (/* binding */ BUILD_001),\n/* harmony export */   BUILD_002: () => (/* binding */ BUILD_002),\n/* harmony export */   RUNTIME_001: () => (/* binding */ RUNTIME_001),\n/* harmony export */   RUNTIME_002: () => (/* binding */ RUNTIME_002),\n/* harmony export */   RUNTIME_003: () => (/* binding */ RUNTIME_003),\n/* harmony export */   RUNTIME_004: () => (/* binding */ RUNTIME_004),\n/* harmony export */   RUNTIME_005: () => (/* binding */ RUNTIME_005),\n/* harmony export */   RUNTIME_006: () => (/* binding */ RUNTIME_006),\n/* harmony export */   RUNTIME_007: () => (/* binding */ RUNTIME_007),\n/* harmony export */   RUNTIME_008: () => (/* binding */ RUNTIME_008),\n/* harmony export */   RUNTIME_009: () => (/* binding */ RUNTIME_009),\n/* harmony export */   TYPE_001: () => (/* binding */ TYPE_001),\n/* harmony export */   buildDescMap: () => (/* binding */ buildDescMap),\n/* harmony export */   errorDescMap: () => (/* binding */ errorDescMap),\n/* harmony export */   getShortErrorMsg: () => (/* binding */ getShortErrorMsg),\n/* harmony export */   runtimeDescMap: () => (/* binding */ runtimeDescMap),\n/* harmony export */   typeDescMap: () => (/* binding */ typeDescMap)\n/* harmony export */ });\nconst RUNTIME_001 = 'RUNTIME-001';\nconst RUNTIME_002 = 'RUNTIME-002';\nconst RUNTIME_003 = 'RUNTIME-003';\nconst RUNTIME_004 = 'RUNTIME-004';\nconst RUNTIME_005 = 'RUNTIME-005';\nconst RUNTIME_006 = 'RUNTIME-006';\nconst RUNTIME_007 = 'RUNTIME-007';\nconst RUNTIME_008 = 'RUNTIME-008';\nconst RUNTIME_009 = 'RUNTIME-009';\nconst TYPE_001 = 'TYPE-001';\nconst BUILD_001 = 'BUILD-001';\nconst BUILD_002 = 'BUILD-002';\n\nconst getDocsUrl = (errorCode)=>{\n    const type = errorCode.split('-')[0].toLowerCase();\n    return `View the docs to see how to solve: https://module-federation.io/guide/troubleshooting/${type}/${errorCode}`;\n};\nconst getShortErrorMsg = (errorCode, errorDescMap, args, originalErrorMsg)=>{\n    const msg = [\n        `${[\n            errorDescMap[errorCode]\n        ]} #${errorCode}`\n    ];\n    args && msg.push(`args: ${JSON.stringify(args)}`);\n    msg.push(getDocsUrl(errorCode));\n    originalErrorMsg && msg.push(`Original Error Message:\\n ${originalErrorMsg}`);\n    return msg.join('\\n');\n};\n\nfunction _extends() {\n    _extends = Object.assign || function assign(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n\nconst runtimeDescMap = {\n    [RUNTIME_001]: 'Failed to get remoteEntry exports.',\n    [RUNTIME_002]: 'The remote entry interface does not contain \"init\"',\n    [RUNTIME_003]: 'Failed to get manifest.',\n    [RUNTIME_004]: 'Failed to locate remote.',\n    [RUNTIME_005]: 'Invalid loadShareSync function call from bundler runtime',\n    [RUNTIME_006]: 'Invalid loadShareSync function call from runtime',\n    [RUNTIME_007]: 'Failed to get remote snapshot.',\n    [RUNTIME_008]: 'Failed to load script resources.',\n    [RUNTIME_009]: 'Please call createInstance first.'\n};\nconst typeDescMap = {\n    [TYPE_001]: 'Failed to generate type declaration. Execute the below cmd to reproduce and fix the error.'\n};\nconst buildDescMap = {\n    [BUILD_001]: 'Failed to find expose module.',\n    [BUILD_002]: 'PublicPath is required in prod mode.'\n};\nconst errorDescMap = _extends({}, runtimeDescMap, typeDescMap, buildDescMap);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL2Vycm9yLWNvZGVzL2Rpc3QvaW5kZXguZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0dBQW9HLEtBQUssR0FBRyxVQUFVO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVcsR0FBRyxVQUFVO0FBQ3hCO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRDtBQUNBLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRTBNIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFdpbiAxMVxcRGVza3RvcFxcUmVhY3QtTWljcm9Gcm9udGVuZFxcbWljcm8tZnJvbnRlbmRcXGNoYXJ0XFxub2RlX21vZHVsZXNcXEBtb2R1bGUtZmVkZXJhdGlvblxcZXJyb3ItY29kZXNcXGRpc3RcXGluZGV4LmVzbS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUlVOVElNRV8wMDEgPSAnUlVOVElNRS0wMDEnO1xuY29uc3QgUlVOVElNRV8wMDIgPSAnUlVOVElNRS0wMDInO1xuY29uc3QgUlVOVElNRV8wMDMgPSAnUlVOVElNRS0wMDMnO1xuY29uc3QgUlVOVElNRV8wMDQgPSAnUlVOVElNRS0wMDQnO1xuY29uc3QgUlVOVElNRV8wMDUgPSAnUlVOVElNRS0wMDUnO1xuY29uc3QgUlVOVElNRV8wMDYgPSAnUlVOVElNRS0wMDYnO1xuY29uc3QgUlVOVElNRV8wMDcgPSAnUlVOVElNRS0wMDcnO1xuY29uc3QgUlVOVElNRV8wMDggPSAnUlVOVElNRS0wMDgnO1xuY29uc3QgUlVOVElNRV8wMDkgPSAnUlVOVElNRS0wMDknO1xuY29uc3QgVFlQRV8wMDEgPSAnVFlQRS0wMDEnO1xuY29uc3QgQlVJTERfMDAxID0gJ0JVSUxELTAwMSc7XG5jb25zdCBCVUlMRF8wMDIgPSAnQlVJTEQtMDAyJztcblxuY29uc3QgZ2V0RG9jc1VybCA9IChlcnJvckNvZGUpPT57XG4gICAgY29uc3QgdHlwZSA9IGVycm9yQ29kZS5zcGxpdCgnLScpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGBWaWV3IHRoZSBkb2NzIHRvIHNlZSBob3cgdG8gc29sdmU6IGh0dHBzOi8vbW9kdWxlLWZlZGVyYXRpb24uaW8vZ3VpZGUvdHJvdWJsZXNob290aW5nLyR7dHlwZX0vJHtlcnJvckNvZGV9YDtcbn07XG5jb25zdCBnZXRTaG9ydEVycm9yTXNnID0gKGVycm9yQ29kZSwgZXJyb3JEZXNjTWFwLCBhcmdzLCBvcmlnaW5hbEVycm9yTXNnKT0+e1xuICAgIGNvbnN0IG1zZyA9IFtcbiAgICAgICAgYCR7W1xuICAgICAgICAgICAgZXJyb3JEZXNjTWFwW2Vycm9yQ29kZV1cbiAgICAgICAgXX0gIyR7ZXJyb3JDb2RlfWBcbiAgICBdO1xuICAgIGFyZ3MgJiYgbXNnLnB1c2goYGFyZ3M6ICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG4gICAgbXNnLnB1c2goZ2V0RG9jc1VybChlcnJvckNvZGUpKTtcbiAgICBvcmlnaW5hbEVycm9yTXNnICYmIG1zZy5wdXNoKGBPcmlnaW5hbCBFcnJvciBNZXNzYWdlOlxcbiAke29yaWdpbmFsRXJyb3JNc2d9YCk7XG4gICAgcmV0dXJuIG1zZy5qb2luKCdcXG4nKTtcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSlpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmNvbnN0IHJ1bnRpbWVEZXNjTWFwID0ge1xuICAgIFtSVU5USU1FXzAwMV06ICdGYWlsZWQgdG8gZ2V0IHJlbW90ZUVudHJ5IGV4cG9ydHMuJyxcbiAgICBbUlVOVElNRV8wMDJdOiAnVGhlIHJlbW90ZSBlbnRyeSBpbnRlcmZhY2UgZG9lcyBub3QgY29udGFpbiBcImluaXRcIicsXG4gICAgW1JVTlRJTUVfMDAzXTogJ0ZhaWxlZCB0byBnZXQgbWFuaWZlc3QuJyxcbiAgICBbUlVOVElNRV8wMDRdOiAnRmFpbGVkIHRvIGxvY2F0ZSByZW1vdGUuJyxcbiAgICBbUlVOVElNRV8wMDVdOiAnSW52YWxpZCBsb2FkU2hhcmVTeW5jIGZ1bmN0aW9uIGNhbGwgZnJvbSBidW5kbGVyIHJ1bnRpbWUnLFxuICAgIFtSVU5USU1FXzAwNl06ICdJbnZhbGlkIGxvYWRTaGFyZVN5bmMgZnVuY3Rpb24gY2FsbCBmcm9tIHJ1bnRpbWUnLFxuICAgIFtSVU5USU1FXzAwN106ICdGYWlsZWQgdG8gZ2V0IHJlbW90ZSBzbmFwc2hvdC4nLFxuICAgIFtSVU5USU1FXzAwOF06ICdGYWlsZWQgdG8gbG9hZCBzY3JpcHQgcmVzb3VyY2VzLicsXG4gICAgW1JVTlRJTUVfMDA5XTogJ1BsZWFzZSBjYWxsIGNyZWF0ZUluc3RhbmNlIGZpcnN0Lidcbn07XG5jb25zdCB0eXBlRGVzY01hcCA9IHtcbiAgICBbVFlQRV8wMDFdOiAnRmFpbGVkIHRvIGdlbmVyYXRlIHR5cGUgZGVjbGFyYXRpb24uIEV4ZWN1dGUgdGhlIGJlbG93IGNtZCB0byByZXByb2R1Y2UgYW5kIGZpeCB0aGUgZXJyb3IuJ1xufTtcbmNvbnN0IGJ1aWxkRGVzY01hcCA9IHtcbiAgICBbQlVJTERfMDAxXTogJ0ZhaWxlZCB0byBmaW5kIGV4cG9zZSBtb2R1bGUuJyxcbiAgICBbQlVJTERfMDAyXTogJ1B1YmxpY1BhdGggaXMgcmVxdWlyZWQgaW4gcHJvZCBtb2RlLidcbn07XG5jb25zdCBlcnJvckRlc2NNYXAgPSBfZXh0ZW5kcyh7fSwgcnVudGltZURlc2NNYXAsIHR5cGVEZXNjTWFwLCBidWlsZERlc2NNYXApO1xuXG5leHBvcnQgeyBCVUlMRF8wMDEsIEJVSUxEXzAwMiwgUlVOVElNRV8wMDEsIFJVTlRJTUVfMDAyLCBSVU5USU1FXzAwMywgUlVOVElNRV8wMDQsIFJVTlRJTUVfMDA1LCBSVU5USU1FXzAwNiwgUlVOVElNRV8wMDcsIFJVTlRJTUVfMDA4LCBSVU5USU1FXzAwOSwgVFlQRV8wMDEsIGJ1aWxkRGVzY01hcCwgZXJyb3JEZXNjTWFwLCBnZXRTaG9ydEVycm9yTXNnLCBydW50aW1lRGVzY01hcCwgdHlwZURlc2NNYXAgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/error-codes/dist/index.esm.mjs\n");

/***/ }),

/***/ "./node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.cjs?runtimePlugin":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.cjs?runtimePlugin ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = default_1;\nfunction default_1() {\n    return {\n        name: 'next-internal-plugin',\n        createScript: function (args) {\n            const url = args.url;\n            const attrs = args.attrs;\n            if (typeof window !== 'undefined') {\n                const script = document.createElement('script');\n                script.src = url;\n                script.async = true;\n                delete attrs?.['crossorigin'];\n                return { script: script, timeout: 8000 };\n            }\n            return undefined;\n        },\n        errorLoadRemote: function (args) {\n            const id = args.id;\n            const error = args.error;\n            const from = args.from;\n            //@ts-ignore\n            globalThis.moduleGraphDirty = true;\n            console.error(id, 'offline');\n            const pg = function () {\n                console.error(id, 'offline', error);\n                return null;\n            };\n            pg.getInitialProps = function (ctx) {\n                return {};\n            };\n            let mod;\n            if (from === 'build') {\n                mod = function () {\n                    return {\n                        __esModule: true,\n                        default: pg,\n                        getServerSideProps: function () {\n                            return { props: {} };\n                        },\n                    };\n                };\n            }\n            else {\n                mod = {\n                    default: pg,\n                    getServerSideProps: function () {\n                        return { props: {} };\n                    },\n                };\n            }\n            return mod;\n        },\n        beforeInit: function (args) {\n            if (!globalThis.usedChunks)\n                globalThis.usedChunks = new Set();\n            if (typeof __webpack_require__.j === 'string' &&\n                !__webpack_require__.j.startsWith('webpack')) {\n                return args;\n            }\n            const moduleCache = args.origin.moduleCache;\n            const name = args.origin.name;\n            let gs;\n            try {\n                gs = new Function('return globalThis')();\n            }\n            catch (e) {\n                gs = globalThis; // fallback for browsers without 'unsafe-eval' CSP policy enabled\n            }\n            //@ts-ignore\n            const attachedRemote = gs[name];\n            if (attachedRemote) {\n                moduleCache.set(name, attachedRemote);\n            }\n            return args;\n        },\n        init: function (args) {\n            return args;\n        },\n        beforeRequest: function (args) {\n            const options = args.options;\n            const id = args.id;\n            const remoteName = id.split('/').shift();\n            const remote = options.remotes.find(function (remote) {\n                return remote.name === remoteName;\n            });\n            if (!remote)\n                return args;\n            if (remote && remote.entry && remote.entry.includes('?t=')) {\n                return args;\n            }\n            remote.entry = remote.entry + '?t=' + Date.now();\n            return args;\n        },\n        afterResolve: function (args) {\n            return args;\n        },\n        onLoad: function (args) {\n            const exposeModuleFactory = args.exposeModuleFactory;\n            const exposeModule = args.exposeModule;\n            const id = args.id;\n            const moduleOrFactory = exposeModuleFactory || exposeModule;\n            if (!moduleOrFactory)\n                return args;\n            if (typeof window === 'undefined') {\n                let exposedModuleExports;\n                try {\n                    exposedModuleExports = moduleOrFactory();\n                }\n                catch (e) {\n                    exposedModuleExports = moduleOrFactory;\n                }\n                const handler = {\n                    get: function (target, prop, receiver) {\n                        if (target === exposedModuleExports &&\n                            typeof exposedModuleExports[prop] === 'function') {\n                            return function () {\n                                globalThis.usedChunks.add(id);\n                                //eslint-disable-next-line\n                                return exposedModuleExports[prop].apply(this, arguments);\n                            };\n                        }\n                        const originalMethod = target[prop];\n                        if (typeof originalMethod === 'function') {\n                            const proxiedFunction = function () {\n                                globalThis.usedChunks.add(id);\n                                //eslint-disable-next-line\n                                return originalMethod.apply(this, arguments);\n                            };\n                            Object.keys(originalMethod).forEach(function (prop) {\n                                Object.defineProperty(proxiedFunction, prop, {\n                                    value: originalMethod[prop],\n                                    writable: true,\n                                    enumerable: true,\n                                    configurable: true,\n                                });\n                            });\n                            return proxiedFunction;\n                        }\n                        return Reflect.get(target, prop, receiver);\n                    },\n                };\n                if (typeof exposedModuleExports === 'function') {\n                    exposedModuleExports = new Proxy(exposedModuleExports, handler);\n                    const staticProps = Object.getOwnPropertyNames(exposedModuleExports);\n                    staticProps.forEach(function (prop) {\n                        if (typeof exposedModuleExports[prop] === 'function') {\n                            exposedModuleExports[prop] = new Proxy(exposedModuleExports[prop], handler);\n                        }\n                    });\n                    return function () {\n                        return exposedModuleExports;\n                    };\n                }\n                else {\n                    exposedModuleExports = new Proxy(exposedModuleExports, handler);\n                }\n                return exposedModuleExports;\n            }\n            return args;\n        },\n        loadRemoteSnapshot(args) {\n            const { from, remoteSnapshot, manifestUrl, manifestJson, options } = args;\n            // ensure snapshot is loaded from manifest\n            if (from !== 'manifest' ||\n                !manifestUrl ||\n                !manifestJson ||\n                !('publicPath' in remoteSnapshot)) {\n                return args;\n            }\n            // re-assign publicPath based on remoteEntry location if in browser nextjs remote\n            const { publicPath } = remoteSnapshot;\n            if (options.inBrowser && publicPath.includes('/_next/')) {\n                remoteSnapshot.publicPath = publicPath.substring(0, publicPath.lastIndexOf('/_next/') + 7);\n            }\n            else {\n                const serverPublicPath = manifestUrl.substring(0, manifestUrl.indexOf('mf-manifest.json'));\n                remoteSnapshot.publicPath = serverPublicPath;\n            }\n            if ('publicPath' in manifestJson.metaData) {\n                manifestJson.metaData.publicPath = remoteSnapshot.publicPath;\n            }\n            return args;\n        },\n        resolveShare: function (args) {\n            if (args.pkgName !== 'react' &&\n                args.pkgName !== 'react-dom' &&\n                !args.pkgName.startsWith('next/')) {\n                return args;\n            }\n            const shareScopeMap = args.shareScopeMap;\n            const scope = args.scope;\n            const pkgName = args.pkgName;\n            const version = args.version;\n            const GlobalFederation = args.GlobalFederation;\n            const host = GlobalFederation['__INSTANCES__'][0];\n            if (!host) {\n                return args;\n            }\n            if (!host.options.shared[pkgName]) {\n                return args;\n            }\n            args.resolver = function () {\n                shareScopeMap[scope][pkgName][version] =\n                    host.options.shared[pkgName][0];\n                return shareScopeMap[scope][pkgName][version];\n            };\n            return args;\n        },\n        beforeLoadShare: async function (args) {\n            return args;\n        },\n    };\n}\n//# sourceMappingURL=runtimePlugin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL25leHRqcy1tZi9kaXN0L3NyYy9wbHVnaW5zL2NvbnRhaW5lci9ydW50aW1lUGx1Z2luLmNqcz9ydW50aW1lUGx1Z2luIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXNCO0FBQzdDLGlCQUFpQixxQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsMkRBQTJEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxXaW4gMTFcXERlc2t0b3BcXFJlYWN0LU1pY3JvRnJvbnRlbmRcXG1pY3JvLWZyb250ZW5kXFxjaGFydFxcbm9kZV9tb2R1bGVzXFxAbW9kdWxlLWZlZGVyYXRpb25cXG5leHRqcy1tZlxcZGlzdFxcc3JjXFxwbHVnaW5zXFxjb250YWluZXJcXHJ1bnRpbWVQbHVnaW4uY2pzP3J1bnRpbWVQbHVnaW4iXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG5mdW5jdGlvbiBkZWZhdWx0XzEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ25leHQtaW50ZXJuYWwtcGx1Z2luJyxcbiAgICAgICAgY3JlYXRlU2NyaXB0OiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYXJncy51cmw7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IGFyZ3MuYXR0cnM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzPy5bJ2Nyb3Nzb3JpZ2luJ107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc2NyaXB0OiBzY3JpcHQsIHRpbWVvdXQ6IDgwMDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yTG9hZFJlbW90ZTogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gYXJncy5pZDtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gYXJncy5lcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhcmdzLmZyb207XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIGdsb2JhbFRoaXMubW9kdWxlR3JhcGhEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGlkLCAnb2ZmbGluZScpO1xuICAgICAgICAgICAgY29uc3QgcGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihpZCwgJ29mZmxpbmUnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGcuZ2V0SW5pdGlhbFByb3BzID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgbW9kO1xuICAgICAgICAgICAgaWYgKGZyb20gPT09ICdidWlsZCcpIHtcbiAgICAgICAgICAgICAgICBtb2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2VzTW9kdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcGcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRTZXJ2ZXJTaWRlUHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwcm9wczoge30gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcGcsXG4gICAgICAgICAgICAgICAgICAgIGdldFNlcnZlclNpZGVQcm9wczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJvcHM6IHt9IH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2Q7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZUluaXQ6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICBpZiAoIWdsb2JhbFRoaXMudXNlZENodW5rcylcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLnVzZWRDaHVua3MgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIF9fd2VicGFja19ydW50aW1lX2lkX18gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgIV9fd2VicGFja19ydW50aW1lX2lkX18uc3RhcnRzV2l0aCgnd2VicGFjaycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVDYWNoZSA9IGFyZ3Mub3JpZ2luLm1vZHVsZUNhY2hlO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGFyZ3Mub3JpZ2luLm5hbWU7XG4gICAgICAgICAgICBsZXQgZ3M7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGdzID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gZ2xvYmFsVGhpcycpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGdzID0gZ2xvYmFsVGhpczsgLy8gZmFsbGJhY2sgZm9yIGJyb3dzZXJzIHdpdGhvdXQgJ3Vuc2FmZS1ldmFsJyBDU1AgcG9saWN5IGVuYWJsZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYXR0YWNoZWRSZW1vdGUgPSBnc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChhdHRhY2hlZFJlbW90ZSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZUNhY2hlLnNldChuYW1lLCBhdHRhY2hlZFJlbW90ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICBiZWZvcmVSZXF1ZXN0OiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGlkID0gYXJncy5pZDtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZU5hbWUgPSBpZC5zcGxpdCgnLycpLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCByZW1vdGUgPSBvcHRpb25zLnJlbW90ZXMuZmluZChmdW5jdGlvbiAocmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW90ZS5uYW1lID09PSByZW1vdGVOYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlbW90ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIGlmIChyZW1vdGUgJiYgcmVtb3RlLmVudHJ5ICYmIHJlbW90ZS5lbnRyeS5pbmNsdWRlcygnP3Q9JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW90ZS5lbnRyeSA9IHJlbW90ZS5lbnRyeSArICc/dD0nICsgRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlclJlc29sdmU6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgb25Mb2FkOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgY29uc3QgZXhwb3NlTW9kdWxlRmFjdG9yeSA9IGFyZ3MuZXhwb3NlTW9kdWxlRmFjdG9yeTtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9zZU1vZHVsZSA9IGFyZ3MuZXhwb3NlTW9kdWxlO1xuICAgICAgICAgICAgY29uc3QgaWQgPSBhcmdzLmlkO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlT3JGYWN0b3J5ID0gZXhwb3NlTW9kdWxlRmFjdG9yeSB8fCBleHBvc2VNb2R1bGU7XG4gICAgICAgICAgICBpZiAoIW1vZHVsZU9yRmFjdG9yeSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBleHBvc2VkTW9kdWxlRXhwb3J0cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBleHBvc2VkTW9kdWxlRXhwb3J0cyA9IG1vZHVsZU9yRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBvc2VkTW9kdWxlRXhwb3J0cyA9IG1vZHVsZU9yRmFjdG9yeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gZXhwb3NlZE1vZHVsZUV4cG9ydHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZXhwb3NlZE1vZHVsZUV4cG9ydHNbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLnVzZWRDaHVua3MuYWRkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9zZWRNb2R1bGVFeHBvcnRzW3Byb3BdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbE1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3hpZWRGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy51c2VkQ2h1bmtzLmFkZChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob3JpZ2luYWxNZXRob2QpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3hpZWRGdW5jdGlvbiwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsTWV0aG9kW3Byb3BdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveGllZEZ1bmN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBvc2VkTW9kdWxlRXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBleHBvc2VkTW9kdWxlRXhwb3J0cyA9IG5ldyBQcm94eShleHBvc2VkTW9kdWxlRXhwb3J0cywgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRpY1Byb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXhwb3NlZE1vZHVsZUV4cG9ydHMpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cG9zZWRNb2R1bGVFeHBvcnRzW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlZE1vZHVsZUV4cG9ydHNbcHJvcF0gPSBuZXcgUHJveHkoZXhwb3NlZE1vZHVsZUV4cG9ydHNbcHJvcF0sIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBvc2VkTW9kdWxlRXhwb3J0cztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRNb2R1bGVFeHBvcnRzID0gbmV3IFByb3h5KGV4cG9zZWRNb2R1bGVFeHBvcnRzLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9zZWRNb2R1bGVFeHBvcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWRSZW1vdGVTbmFwc2hvdChhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZyb20sIHJlbW90ZVNuYXBzaG90LCBtYW5pZmVzdFVybCwgbWFuaWZlc3RKc29uLCBvcHRpb25zIH0gPSBhcmdzO1xuICAgICAgICAgICAgLy8gZW5zdXJlIHNuYXBzaG90IGlzIGxvYWRlZCBmcm9tIG1hbmlmZXN0XG4gICAgICAgICAgICBpZiAoZnJvbSAhPT0gJ21hbmlmZXN0JyB8fFxuICAgICAgICAgICAgICAgICFtYW5pZmVzdFVybCB8fFxuICAgICAgICAgICAgICAgICFtYW5pZmVzdEpzb24gfHxcbiAgICAgICAgICAgICAgICAhKCdwdWJsaWNQYXRoJyBpbiByZW1vdGVTbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlLWFzc2lnbiBwdWJsaWNQYXRoIGJhc2VkIG9uIHJlbW90ZUVudHJ5IGxvY2F0aW9uIGlmIGluIGJyb3dzZXIgbmV4dGpzIHJlbW90ZVxuICAgICAgICAgICAgY29uc3QgeyBwdWJsaWNQYXRoIH0gPSByZW1vdGVTbmFwc2hvdDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluQnJvd3NlciAmJiBwdWJsaWNQYXRoLmluY2x1ZGVzKCcvX25leHQvJykpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdC5wdWJsaWNQYXRoID0gcHVibGljUGF0aC5zdWJzdHJpbmcoMCwgcHVibGljUGF0aC5sYXN0SW5kZXhPZignL19uZXh0LycpICsgNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJQdWJsaWNQYXRoID0gbWFuaWZlc3RVcmwuc3Vic3RyaW5nKDAsIG1hbmlmZXN0VXJsLmluZGV4T2YoJ21mLW1hbmlmZXN0Lmpzb24nKSk7XG4gICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3QucHVibGljUGF0aCA9IHNlcnZlclB1YmxpY1BhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3B1YmxpY1BhdGgnIGluIG1hbmlmZXN0SnNvbi5tZXRhRGF0YSkge1xuICAgICAgICAgICAgICAgIG1hbmlmZXN0SnNvbi5tZXRhRGF0YS5wdWJsaWNQYXRoID0gcmVtb3RlU25hcHNob3QucHVibGljUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlU2hhcmU6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5wa2dOYW1lICE9PSAncmVhY3QnICYmXG4gICAgICAgICAgICAgICAgYXJncy5wa2dOYW1lICE9PSAncmVhY3QtZG9tJyAmJlxuICAgICAgICAgICAgICAgICFhcmdzLnBrZ05hbWUuc3RhcnRzV2l0aCgnbmV4dC8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2hhcmVTY29wZU1hcCA9IGFyZ3Muc2hhcmVTY29wZU1hcDtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlID0gYXJncy5zY29wZTtcbiAgICAgICAgICAgIGNvbnN0IHBrZ05hbWUgPSBhcmdzLnBrZ05hbWU7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXJncy52ZXJzaW9uO1xuICAgICAgICAgICAgY29uc3QgR2xvYmFsRmVkZXJhdGlvbiA9IGFyZ3MuR2xvYmFsRmVkZXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGhvc3QgPSBHbG9iYWxGZWRlcmF0aW9uWydfX0lOU1RBTkNFU19fJ11bMF07XG4gICAgICAgICAgICBpZiAoIWhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaG9zdC5vcHRpb25zLnNoYXJlZFtwa2dOYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5yZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzaGFyZVNjb3BlTWFwW3Njb3BlXVtwa2dOYW1lXVt2ZXJzaW9uXSA9XG4gICAgICAgICAgICAgICAgICAgIGhvc3Qub3B0aW9ucy5zaGFyZWRbcGtnTmFtZV1bMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYXJlU2NvcGVNYXBbc2NvcGVdW3BrZ05hbWVdW3ZlcnNpb25dO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICBiZWZvcmVMb2FkU2hhcmU6IGFzeW5jIGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVudGltZVBsdWdpbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.cjs?runtimePlugin\n");

/***/ }),

/***/ "./node_modules/@module-federation/node/dist/src/runtimePlugin.js?runtimePlugin":
/*!**************************************************************************************!*\
  !*** ./node_modules/@module-federation/node/dist/src/runtimePlugin.js?runtimePlugin ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setupWebpackRequirePatching = exports.setupChunkHandler = exports.setupScriptLoader = exports.deleteChunk = exports.installChunk = exports.loadChunk = exports.resolveUrl = exports.fetchAndRun = exports.loadFromFs = exports.returnFromGlobalInstances = exports.returnFromCache = exports.resolveFile = exports.nodeRuntimeImportCache = void 0;\nexports.importNodeModule = importNodeModule;\nexports[\"default\"] = default_1;\nexports.nodeRuntimeImportCache = new Map();\nfunction importNodeModule(name) {\n    if (!name) {\n        throw new Error('import specifier is required');\n    }\n    // Check cache to prevent infinite recursion\n    if (exports.nodeRuntimeImportCache.has(name)) {\n        return exports.nodeRuntimeImportCache.get(name);\n    }\n    const importModule = new Function('name', `return import(name)`);\n    const promise = importModule(name)\n        .then((res) => res.default)\n        .catch((error) => {\n        console.error(`Error importing module ${name}:`, error);\n        // Remove from cache on error so it can be retried\n        exports.nodeRuntimeImportCache.delete(name);\n        throw error;\n    });\n    // Cache the promise to prevent recursive calls\n    exports.nodeRuntimeImportCache.set(name, promise);\n    return promise;\n}\n// Hoisted utility function to resolve file paths for chunks\nconst resolveFile = (rootOutputDir, chunkId) => {\n    const path = require('path');\n    return path.join(__dirname, rootOutputDir + __webpack_require__.u(chunkId));\n};\nexports.resolveFile = resolveFile;\n// Hoisted utility function to get remote entry from cache\nconst returnFromCache = (remoteName) => {\n    const globalThisVal = new Function('return globalThis')();\n    const federationInstances = globalThisVal['__FEDERATION__']['__INSTANCES__'];\n    for (const instance of federationInstances) {\n        const moduleContainer = instance.moduleCache.get(remoteName);\n        if (moduleContainer?.remoteInfo)\n            return moduleContainer.remoteInfo.entry;\n    }\n    return null;\n};\nexports.returnFromCache = returnFromCache;\n// Hoisted utility function to get remote entry from global instances\nconst returnFromGlobalInstances = (remoteName) => {\n    const globalThisVal = new Function('return globalThis')();\n    const federationInstances = globalThisVal['__FEDERATION__']['__INSTANCES__'];\n    for (const instance of federationInstances) {\n        for (const remote of instance.options.remotes) {\n            if (remote.name === remoteName || remote.alias === remoteName) {\n                console.log('Backup remote entry found:', remote.entry);\n                return remote.entry;\n            }\n        }\n    }\n    return null;\n};\nexports.returnFromGlobalInstances = returnFromGlobalInstances;\n// Hoisted utility function to load chunks from filesystem\nconst loadFromFs = (filename, callback) => {\n    const fs = require('fs');\n    const path = require('path');\n    const vm = require('vm');\n    if (fs.existsSync(filename)) {\n        fs.readFile(filename, 'utf-8', (err, content) => {\n            if (err)\n                return callback(err, null);\n            const chunk = {};\n            try {\n                const script = new vm.Script(`(function(exports, require, __dirname, __filename) {${content}\\n})`, {\n                    filename,\n                    importModuleDynamically: \n                    //@ts-ignore\n                    vm.constants?.USE_MAIN_CONTEXT_DEFAULT_LOADER ?? importNodeModule,\n                });\n                script.runInThisContext()(chunk, require, path.dirname(filename), filename);\n                callback(null, chunk);\n            }\n            catch (e) {\n                console.log(\"'runInThisContext threw'\", e);\n                callback(e, null);\n            }\n        });\n    }\n    else {\n        callback(new Error(`File ${filename} does not exist`), null);\n    }\n};\nexports.loadFromFs = loadFromFs;\n// Hoisted utility function to fetch and execute chunks from remote URLs\nconst fetchAndRun = (url, chunkName, callback, args) => {\n    (typeof fetch === 'undefined'\n        ? importNodeModule('node-fetch').then((mod) => mod.default)\n        : Promise.resolve(fetch))\n        .then((fetchFunction) => {\n        return args.origin.loaderHook.lifecycle.fetch\n            .emit(url.href, {})\n            .then((res) => {\n            if (!res || !(res instanceof Response)) {\n                return fetchFunction(url.href).then((response) => response.text());\n            }\n            return res.text();\n        });\n    })\n        .then((data) => {\n        const chunk = {};\n        try {\n            eval(`(function(exports, require, __dirname, __filename) {${data}\\n})`)(chunk, require, url.pathname.split('/').slice(0, -1).join('/'), chunkName);\n            callback(null, chunk);\n        }\n        catch (e) {\n            callback(e, null);\n        }\n    })\n        .catch((err) => callback(err, null));\n};\nexports.fetchAndRun = fetchAndRun;\n// Hoisted utility function to resolve URLs for chunks\nconst resolveUrl = (remoteName, chunkName) => {\n    try {\n        return new URL(chunkName, __webpack_require__.p);\n    }\n    catch {\n        const entryUrl = (0, exports.returnFromCache)(remoteName) || (0, exports.returnFromGlobalInstances)(remoteName);\n        if (!entryUrl)\n            return null;\n        const url = new URL(entryUrl);\n        const path = require('path');\n        // Extract the directory path from the remote entry URL\n        // e.g., from \"http://url/static/js/remoteEntry.js\" to \"/static/js/\"\n        const urlPath = url.pathname;\n        const lastSlashIndex = urlPath.lastIndexOf('/');\n        const directoryPath = lastSlashIndex >= 0 ? urlPath.substring(0, lastSlashIndex + 1) : '/';\n        // Get rootDir from webpack configuration\n        const rootDir = __webpack_require__.federation.rootOutputDir || '';\n        // Use path.join to combine the paths properly while handling slashes\n        // Convert Windows-style paths to URL-style paths\n        const combinedPath = path\n            .join(directoryPath, rootDir, chunkName)\n            .replace(/\\\\/g, '/');\n        // Create the final URL\n        return new URL(combinedPath, url.origin);\n    }\n};\nexports.resolveUrl = resolveUrl;\n// Hoisted utility function to load chunks based on different strategies\nconst loadChunk = (strategy, chunkId, rootOutputDir, callback, args) => {\n    if (strategy === 'filesystem') {\n        return (0, exports.loadFromFs)((0, exports.resolveFile)(rootOutputDir, chunkId), callback);\n    }\n    const url = (0, exports.resolveUrl)(rootOutputDir, chunkId);\n    if (!url)\n        return callback(null, { modules: {}, ids: [], runtime: null });\n    // Using fetchAndRun directly with args\n    (0, exports.fetchAndRun)(url, chunkId, callback, args);\n};\nexports.loadChunk = loadChunk;\n// Hoisted utility function to install a chunk into webpack\nconst installChunk = (chunk, installedChunks) => {\n    for (const moduleId in chunk.modules) {\n        __webpack_require__.m[moduleId] = chunk.modules[moduleId];\n    }\n    if (chunk.runtime)\n        chunk.runtime(__webpack_require__);\n    for (const chunkId of chunk.ids) {\n        if (installedChunks[chunkId])\n            installedChunks[chunkId][0]();\n        installedChunks[chunkId] = 0;\n    }\n};\nexports.installChunk = installChunk;\n// Hoisted utility function to remove a chunk on fail\nconst deleteChunk = (chunkId, installedChunks) => {\n    delete installedChunks[chunkId];\n    return true;\n};\nexports.deleteChunk = deleteChunk;\n// Hoisted function to set up webpack script loader\nconst setupScriptLoader = () => {\n    __webpack_require__.l = (url, done, key, chunkId) => {\n        if (!key || chunkId)\n            throw new Error(`__webpack_require__.l name is required for ${url}`);\n        __webpack_require__.federation.runtime\n            .loadScriptNode(url, { attrs: { globalName: key } })\n            .then((res) => {\n            const enhancedRemote = __webpack_require__.federation.instance.initRawContainer(key, url, res);\n            new Function('return globalThis')()[key] = enhancedRemote;\n            done(enhancedRemote);\n        })\n            .catch(done);\n    };\n};\nexports.setupScriptLoader = setupScriptLoader;\n// Hoisted function to set up chunk handler\nconst setupChunkHandler = (installedChunks, args) => {\n    return (chunkId, promises) => {\n        let installedChunkData = installedChunks[chunkId];\n        if (installedChunkData !== 0) {\n            if (installedChunkData) {\n                promises.push(installedChunkData[2]);\n            }\n            else {\n                const matcher = __webpack_require__.federation.chunkMatcher\n                    ? __webpack_require__.federation.chunkMatcher(chunkId)\n                    : true;\n                if (matcher) {\n                    const promise = new Promise((resolve, reject) => {\n                        installedChunkData = installedChunks[chunkId] = [resolve, reject];\n                        const fs = typeof process !== 'undefined'\n                            ? require('fs')\n                            : false;\n                        const filename = typeof process !== 'undefined'\n                            ? (0, exports.resolveFile)(__webpack_require__.federation.rootOutputDir || '', chunkId)\n                            : false;\n                        if (fs && fs.existsSync(filename)) {\n                            (0, exports.loadChunk)('filesystem', chunkId, __webpack_require__.federation.rootOutputDir || '', (err, chunk) => {\n                                if (err)\n                                    return (0, exports.deleteChunk)(chunkId, installedChunks) && reject(err);\n                                if (chunk)\n                                    (0, exports.installChunk)(chunk, installedChunks);\n                                resolve(chunk);\n                            }, args);\n                        }\n                        else {\n                            const chunkName = __webpack_require__.u(chunkId);\n                            const loadingStrategy = typeof process === 'undefined' ? 'http-eval' : 'http-vm';\n                            (0, exports.loadChunk)(loadingStrategy, chunkName, __webpack_require__.federation.initOptions.name, (err, chunk) => {\n                                if (err)\n                                    return (0, exports.deleteChunk)(chunkId, installedChunks) && reject(err);\n                                if (chunk)\n                                    (0, exports.installChunk)(chunk, installedChunks);\n                                resolve(chunk);\n                            }, args);\n                        }\n                    });\n                    promises.push((installedChunkData[2] = promise));\n                }\n                else {\n                    installedChunks[chunkId] = 0;\n                }\n            }\n        }\n    };\n};\nexports.setupChunkHandler = setupChunkHandler;\n// Hoisted function to set up webpack require patching\nconst setupWebpackRequirePatching = (handle) => {\n    if (__webpack_require__.f) {\n        if (__webpack_require__.f.require) {\n            console.warn('\\x1b[33m%s\\x1b[0m', 'CAUTION: build target is not set to \"async-node\", attempting to patch additional chunk handlers. This may not work');\n            __webpack_require__.f.require = handle;\n        }\n        if (__webpack_require__.f.readFileVm) {\n            __webpack_require__.f.readFileVm = handle;\n        }\n    }\n};\nexports.setupWebpackRequirePatching = setupWebpackRequirePatching;\nfunction default_1() {\n    return {\n        name: 'node-federation-plugin',\n        beforeInit(args) {\n            // Patch webpack chunk loading handlers\n            (() => {\n                // Create the chunk tracking object\n                const installedChunks = {};\n                // Set up webpack script loader\n                (0, exports.setupScriptLoader)();\n                // Create and set up the chunk handler\n                const handle = (0, exports.setupChunkHandler)(installedChunks, args);\n                // Patch webpack require\n                (0, exports.setupWebpackRequirePatching)(handle);\n            })();\n            return args;\n        },\n    };\n}\n//# sourceMappingURL=runtimePlugin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL25vZGUvZGlzdC9zcmMvcnVudGltZVBsdWdpbi5qcz9ydW50aW1lUGx1Z2luIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQyxHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLGlDQUFpQyxHQUFHLHVCQUF1QixHQUFHLG1CQUFtQixHQUFHLDhCQUE4QjtBQUNqVix3QkFBd0I7QUFDeEIsa0JBQWU7QUFDZiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUF1QjtBQUN4QyxnREFBZ0QsbUJBQW1CO0FBQ25FO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsZUFBZSxPQUF1QjtBQUN0QyxpQkFBaUIsT0FBdUI7QUFDeEMsZUFBZSxPQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csRUFBRSxRQUFRLEdBQUc7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaURBQWlELE9BQXVCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsRUFBRSxLQUFLLEdBQUcsV0FBVyxPQUF1QjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBLDBFQUEwRSxJQUFJO0FBQzlFLFFBQVEsbUJBQW1CO0FBQzNCLG1DQUFtQyxTQUFTLG1CQUFtQjtBQUMvRDtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRCxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBdUI7QUFDckQ7QUFDQTtBQUNBLHVEQUF1RCxtQkFBbUI7QUFDMUU7QUFDQTtBQUNBLDBFQUEwRSxtQkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBLCtFQUErRSxtQkFBbUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcV2luIDExXFxEZXNrdG9wXFxSZWFjdC1NaWNyb0Zyb250ZW5kXFxtaWNyby1mcm9udGVuZFxcY2hhcnRcXG5vZGVfbW9kdWxlc1xcQG1vZHVsZS1mZWRlcmF0aW9uXFxub2RlXFxkaXN0XFxzcmNcXHJ1bnRpbWVQbHVnaW4uanM/cnVudGltZVBsdWdpbiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXBXZWJwYWNrUmVxdWlyZVBhdGNoaW5nID0gZXhwb3J0cy5zZXR1cENodW5rSGFuZGxlciA9IGV4cG9ydHMuc2V0dXBTY3JpcHRMb2FkZXIgPSBleHBvcnRzLmRlbGV0ZUNodW5rID0gZXhwb3J0cy5pbnN0YWxsQ2h1bmsgPSBleHBvcnRzLmxvYWRDaHVuayA9IGV4cG9ydHMucmVzb2x2ZVVybCA9IGV4cG9ydHMuZmV0Y2hBbmRSdW4gPSBleHBvcnRzLmxvYWRGcm9tRnMgPSBleHBvcnRzLnJldHVybkZyb21HbG9iYWxJbnN0YW5jZXMgPSBleHBvcnRzLnJldHVybkZyb21DYWNoZSA9IGV4cG9ydHMucmVzb2x2ZUZpbGUgPSBleHBvcnRzLm5vZGVSdW50aW1lSW1wb3J0Q2FjaGUgPSB2b2lkIDA7XG5leHBvcnRzLmltcG9ydE5vZGVNb2R1bGUgPSBpbXBvcnROb2RlTW9kdWxlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuZXhwb3J0cy5ub2RlUnVudGltZUltcG9ydENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gaW1wb3J0Tm9kZU1vZHVsZShuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW1wb3J0IHNwZWNpZmllciBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICAvLyBDaGVjayBjYWNoZSB0byBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvblxuICAgIGlmIChleHBvcnRzLm5vZGVSdW50aW1lSW1wb3J0Q2FjaGUuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLm5vZGVSdW50aW1lSW1wb3J0Q2FjaGUuZ2V0KG5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBpbXBvcnRNb2R1bGUgPSBuZXcgRnVuY3Rpb24oJ25hbWUnLCBgcmV0dXJuIGltcG9ydChuYW1lKWApO1xuICAgIGNvbnN0IHByb21pc2UgPSBpbXBvcnRNb2R1bGUobmFtZSlcbiAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmRlZmF1bHQpXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW1wb3J0aW5nIG1vZHVsZSAke25hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gY2FjaGUgb24gZXJyb3Igc28gaXQgY2FuIGJlIHJldHJpZWRcbiAgICAgICAgZXhwb3J0cy5ub2RlUnVudGltZUltcG9ydENhY2hlLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgLy8gQ2FjaGUgdGhlIHByb21pc2UgdG8gcHJldmVudCByZWN1cnNpdmUgY2FsbHNcbiAgICBleHBvcnRzLm5vZGVSdW50aW1lSW1wb3J0Q2FjaGUuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuLy8gSG9pc3RlZCB1dGlsaXR5IGZ1bmN0aW9uIHRvIHJlc29sdmUgZmlsZSBwYXRocyBmb3IgY2h1bmtzXG5jb25zdCByZXNvbHZlRmlsZSA9IChyb290T3V0cHV0RGlyLCBjaHVua0lkKSA9PiB7XG4gICAgY29uc3QgcGF0aCA9IF9fbm9uX3dlYnBhY2tfcmVxdWlyZV9fKCdwYXRoJyk7XG4gICAgcmV0dXJuIHBhdGguam9pbihfX2Rpcm5hbWUsIHJvb3RPdXRwdXREaXIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLnUoY2h1bmtJZCkpO1xufTtcbmV4cG9ydHMucmVzb2x2ZUZpbGUgPSByZXNvbHZlRmlsZTtcbi8vIEhvaXN0ZWQgdXRpbGl0eSBmdW5jdGlvbiB0byBnZXQgcmVtb3RlIGVudHJ5IGZyb20gY2FjaGVcbmNvbnN0IHJldHVybkZyb21DYWNoZSA9IChyZW1vdGVOYW1lKSA9PiB7XG4gICAgY29uc3QgZ2xvYmFsVGhpc1ZhbCA9IG5ldyBGdW5jdGlvbigncmV0dXJuIGdsb2JhbFRoaXMnKSgpO1xuICAgIGNvbnN0IGZlZGVyYXRpb25JbnN0YW5jZXMgPSBnbG9iYWxUaGlzVmFsWydfX0ZFREVSQVRJT05fXyddWydfX0lOU1RBTkNFU19fJ107XG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBmZWRlcmF0aW9uSW5zdGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZUNvbnRhaW5lciA9IGluc3RhbmNlLm1vZHVsZUNhY2hlLmdldChyZW1vdGVOYW1lKTtcbiAgICAgICAgaWYgKG1vZHVsZUNvbnRhaW5lcj8ucmVtb3RlSW5mbylcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVDb250YWluZXIucmVtb3RlSW5mby5lbnRyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0cy5yZXR1cm5Gcm9tQ2FjaGUgPSByZXR1cm5Gcm9tQ2FjaGU7XG4vLyBIb2lzdGVkIHV0aWxpdHkgZnVuY3Rpb24gdG8gZ2V0IHJlbW90ZSBlbnRyeSBmcm9tIGdsb2JhbCBpbnN0YW5jZXNcbmNvbnN0IHJldHVybkZyb21HbG9iYWxJbnN0YW5jZXMgPSAocmVtb3RlTmFtZSkgPT4ge1xuICAgIGNvbnN0IGdsb2JhbFRoaXNWYWwgPSBuZXcgRnVuY3Rpb24oJ3JldHVybiBnbG9iYWxUaGlzJykoKTtcbiAgICBjb25zdCBmZWRlcmF0aW9uSW5zdGFuY2VzID0gZ2xvYmFsVGhpc1ZhbFsnX19GRURFUkFUSU9OX18nXVsnX19JTlNUQU5DRVNfXyddO1xuICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgZmVkZXJhdGlvbkluc3RhbmNlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlbW90ZSBvZiBpbnN0YW5jZS5vcHRpb25zLnJlbW90ZXMpIHtcbiAgICAgICAgICAgIGlmIChyZW1vdGUubmFtZSA9PT0gcmVtb3RlTmFtZSB8fCByZW1vdGUuYWxpYXMgPT09IHJlbW90ZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQmFja3VwIHJlbW90ZSBlbnRyeSBmb3VuZDonLCByZW1vdGUuZW50cnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdGUuZW50cnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0cy5yZXR1cm5Gcm9tR2xvYmFsSW5zdGFuY2VzID0gcmV0dXJuRnJvbUdsb2JhbEluc3RhbmNlcztcbi8vIEhvaXN0ZWQgdXRpbGl0eSBmdW5jdGlvbiB0byBsb2FkIGNodW5rcyBmcm9tIGZpbGVzeXN0ZW1cbmNvbnN0IGxvYWRGcm9tRnMgPSAoZmlsZW5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgZnMgPSBfX25vbl93ZWJwYWNrX3JlcXVpcmVfXygnZnMnKTtcbiAgICBjb25zdCBwYXRoID0gX19ub25fd2VicGFja19yZXF1aXJlX18oJ3BhdGgnKTtcbiAgICBjb25zdCB2bSA9IF9fbm9uX3dlYnBhY2tfcmVxdWlyZV9fKCd2bScpO1xuICAgIGlmIChmcy5leGlzdHNTeW5jKGZpbGVuYW1lKSkge1xuICAgICAgICBmcy5yZWFkRmlsZShmaWxlbmFtZSwgJ3V0Zi04JywgKGVyciwgY29udGVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0ge307XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IG5ldyB2bS5TY3JpcHQoYChmdW5jdGlvbihleHBvcnRzLCByZXF1aXJlLCBfX2Rpcm5hbWUsIF9fZmlsZW5hbWUpIHske2NvbnRlbnR9XFxufSlgLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRNb2R1bGVEeW5hbWljYWxseTogXG4gICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB2bS5jb25zdGFudHM/LlVTRV9NQUlOX0NPTlRFWFRfREVGQVVMVF9MT0FERVIgPz8gaW1wb3J0Tm9kZU1vZHVsZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQucnVuSW5UaGlzQ29udGV4dCgpKGNodW5rLCBfX25vbl93ZWJwYWNrX3JlcXVpcmVfXywgcGF0aC5kaXJuYW1lKGZpbGVuYW1lKSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIncnVuSW5UaGlzQ29udGV4dCB0aHJldydcIiwgZSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBGaWxlICR7ZmlsZW5hbWV9IGRvZXMgbm90IGV4aXN0YCksIG51bGwpO1xuICAgIH1cbn07XG5leHBvcnRzLmxvYWRGcm9tRnMgPSBsb2FkRnJvbUZzO1xuLy8gSG9pc3RlZCB1dGlsaXR5IGZ1bmN0aW9uIHRvIGZldGNoIGFuZCBleGVjdXRlIGNodW5rcyBmcm9tIHJlbW90ZSBVUkxzXG5jb25zdCBmZXRjaEFuZFJ1biA9ICh1cmwsIGNodW5rTmFtZSwgY2FsbGJhY2ssIGFyZ3MpID0+IHtcbiAgICAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGltcG9ydE5vZGVNb2R1bGUoJ25vZGUtZmV0Y2gnKS50aGVuKChtb2QpID0+IG1vZC5kZWZhdWx0KVxuICAgICAgICA6IFByb21pc2UucmVzb2x2ZShmZXRjaCkpXG4gICAgICAgIC50aGVuKChmZXRjaEZ1bmN0aW9uKSA9PiB7XG4gICAgICAgIHJldHVybiBhcmdzLm9yaWdpbi5sb2FkZXJIb29rLmxpZmVjeWNsZS5mZXRjaFxuICAgICAgICAgICAgLmVtaXQodXJsLmhyZWYsIHt9KVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hGdW5jdGlvbih1cmwuaHJlZikudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKTtcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2YWwoYChmdW5jdGlvbihleHBvcnRzLCByZXF1aXJlLCBfX2Rpcm5hbWUsIF9fZmlsZW5hbWUpIHske2RhdGF9XFxufSlgKShjaHVuaywgX19ub25fd2VicGFja19yZXF1aXJlX18sIHVybC5wYXRobmFtZS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5qb2luKCcvJyksIGNodW5rTmFtZSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IGNhbGxiYWNrKGVyciwgbnVsbCkpO1xufTtcbmV4cG9ydHMuZmV0Y2hBbmRSdW4gPSBmZXRjaEFuZFJ1bjtcbi8vIEhvaXN0ZWQgdXRpbGl0eSBmdW5jdGlvbiB0byByZXNvbHZlIFVSTHMgZm9yIGNodW5rc1xuY29uc3QgcmVzb2x2ZVVybCA9IChyZW1vdGVOYW1lLCBjaHVua05hbWUpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTChjaHVua05hbWUsIF9fd2VicGFja19yZXF1aXJlX18ucCk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgY29uc3QgZW50cnlVcmwgPSAoMCwgZXhwb3J0cy5yZXR1cm5Gcm9tQ2FjaGUpKHJlbW90ZU5hbWUpIHx8ICgwLCBleHBvcnRzLnJldHVybkZyb21HbG9iYWxJbnN0YW5jZXMpKHJlbW90ZU5hbWUpO1xuICAgICAgICBpZiAoIWVudHJ5VXJsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoZW50cnlVcmwpO1xuICAgICAgICBjb25zdCBwYXRoID0gX19ub25fd2VicGFja19yZXF1aXJlX18oJ3BhdGgnKTtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgZGlyZWN0b3J5IHBhdGggZnJvbSB0aGUgcmVtb3RlIGVudHJ5IFVSTFxuICAgICAgICAvLyBlLmcuLCBmcm9tIFwiaHR0cDovL3VybC9zdGF0aWMvanMvcmVtb3RlRW50cnkuanNcIiB0byBcIi9zdGF0aWMvanMvXCJcbiAgICAgICAgY29uc3QgdXJsUGF0aCA9IHVybC5wYXRobmFtZTtcbiAgICAgICAgY29uc3QgbGFzdFNsYXNoSW5kZXggPSB1cmxQYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIGNvbnN0IGRpcmVjdG9yeVBhdGggPSBsYXN0U2xhc2hJbmRleCA+PSAwID8gdXJsUGF0aC5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoSW5kZXggKyAxKSA6ICcvJztcbiAgICAgICAgLy8gR2V0IHJvb3REaXIgZnJvbSB3ZWJwYWNrIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgY29uc3Qgcm9vdERpciA9IF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5yb290T3V0cHV0RGlyIHx8ICcnO1xuICAgICAgICAvLyBVc2UgcGF0aC5qb2luIHRvIGNvbWJpbmUgdGhlIHBhdGhzIHByb3Blcmx5IHdoaWxlIGhhbmRsaW5nIHNsYXNoZXNcbiAgICAgICAgLy8gQ29udmVydCBXaW5kb3dzLXN0eWxlIHBhdGhzIHRvIFVSTC1zdHlsZSBwYXRoc1xuICAgICAgICBjb25zdCBjb21iaW5lZFBhdGggPSBwYXRoXG4gICAgICAgICAgICAuam9pbihkaXJlY3RvcnlQYXRoLCByb290RGlyLCBjaHVua05hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGZpbmFsIFVSTFxuICAgICAgICByZXR1cm4gbmV3IFVSTChjb21iaW5lZFBhdGgsIHVybC5vcmlnaW4pO1xuICAgIH1cbn07XG5leHBvcnRzLnJlc29sdmVVcmwgPSByZXNvbHZlVXJsO1xuLy8gSG9pc3RlZCB1dGlsaXR5IGZ1bmN0aW9uIHRvIGxvYWQgY2h1bmtzIGJhc2VkIG9uIGRpZmZlcmVudCBzdHJhdGVnaWVzXG5jb25zdCBsb2FkQ2h1bmsgPSAoc3RyYXRlZ3ksIGNodW5rSWQsIHJvb3RPdXRwdXREaXIsIGNhbGxiYWNrLCBhcmdzKSA9PiB7XG4gICAgaWYgKHN0cmF0ZWd5ID09PSAnZmlsZXN5c3RlbScpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmxvYWRGcm9tRnMpKCgwLCBleHBvcnRzLnJlc29sdmVGaWxlKShyb290T3V0cHV0RGlyLCBjaHVua0lkKSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSAoMCwgZXhwb3J0cy5yZXNvbHZlVXJsKShyb290T3V0cHV0RGlyLCBjaHVua0lkKTtcbiAgICBpZiAoIXVybClcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHsgbW9kdWxlczoge30sIGlkczogW10sIHJ1bnRpbWU6IG51bGwgfSk7XG4gICAgLy8gVXNpbmcgZmV0Y2hBbmRSdW4gZGlyZWN0bHkgd2l0aCBhcmdzXG4gICAgKDAsIGV4cG9ydHMuZmV0Y2hBbmRSdW4pKHVybCwgY2h1bmtJZCwgY2FsbGJhY2ssIGFyZ3MpO1xufTtcbmV4cG9ydHMubG9hZENodW5rID0gbG9hZENodW5rO1xuLy8gSG9pc3RlZCB1dGlsaXR5IGZ1bmN0aW9uIHRvIGluc3RhbGwgYSBjaHVuayBpbnRvIHdlYnBhY2tcbmNvbnN0IGluc3RhbGxDaHVuayA9IChjaHVuaywgaW5zdGFsbGVkQ2h1bmtzKSA9PiB7XG4gICAgZm9yIChjb25zdCBtb2R1bGVJZCBpbiBjaHVuay5tb2R1bGVzKSB7XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBjaHVuay5tb2R1bGVzW21vZHVsZUlkXTtcbiAgICB9XG4gICAgaWYgKGNodW5rLnJ1bnRpbWUpXG4gICAgICAgIGNodW5rLnJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4gICAgZm9yIChjb25zdCBjaHVua0lkIG9mIGNodW5rLmlkcykge1xuICAgICAgICBpZiAoaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKVxuICAgICAgICAgICAgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKCk7XG4gICAgICAgIGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG4gICAgfVxufTtcbmV4cG9ydHMuaW5zdGFsbENodW5rID0gaW5zdGFsbENodW5rO1xuLy8gSG9pc3RlZCB1dGlsaXR5IGZ1bmN0aW9uIHRvIHJlbW92ZSBhIGNodW5rIG9uIGZhaWxcbmNvbnN0IGRlbGV0ZUNodW5rID0gKGNodW5rSWQsIGluc3RhbGxlZENodW5rcykgPT4ge1xuICAgIGRlbGV0ZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZXhwb3J0cy5kZWxldGVDaHVuayA9IGRlbGV0ZUNodW5rO1xuLy8gSG9pc3RlZCBmdW5jdGlvbiB0byBzZXQgdXAgd2VicGFjayBzY3JpcHQgbG9hZGVyXG5jb25zdCBzZXR1cFNjcmlwdExvYWRlciA9ICgpID0+IHtcbiAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmwgPSAodXJsLCBkb25lLCBrZXksIGNodW5rSWQpID0+IHtcbiAgICAgICAgaWYgKCFrZXkgfHwgY2h1bmtJZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgX193ZWJwYWNrX3JlcXVpcmVfXy5sIG5hbWUgaXMgcmVxdWlyZWQgZm9yICR7dXJsfWApO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24ucnVudGltZVxuICAgICAgICAgICAgLmxvYWRTY3JpcHROb2RlKHVybCwgeyBhdHRyczogeyBnbG9iYWxOYW1lOiBrZXkgfSB9KVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5oYW5jZWRSZW1vdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uaW5zdGFuY2UuaW5pdFJhd0NvbnRhaW5lcihrZXksIHVybCwgcmVzKTtcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIGdsb2JhbFRoaXMnKSgpW2tleV0gPSBlbmhhbmNlZFJlbW90ZTtcbiAgICAgICAgICAgIGRvbmUoZW5oYW5jZWRSZW1vdGUpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGRvbmUpO1xuICAgIH07XG59O1xuZXhwb3J0cy5zZXR1cFNjcmlwdExvYWRlciA9IHNldHVwU2NyaXB0TG9hZGVyO1xuLy8gSG9pc3RlZCBmdW5jdGlvbiB0byBzZXQgdXAgY2h1bmsgaGFuZGxlclxuY29uc3Qgc2V0dXBDaHVua0hhbmRsZXIgPSAoaW5zdGFsbGVkQ2h1bmtzLCBhcmdzKSA9PiB7XG4gICAgcmV0dXJuIChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuICAgICAgICBsZXQgaW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuICAgICAgICBpZiAoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlciA9IF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5jaHVua01hdGNoZXJcbiAgICAgICAgICAgICAgICAgICAgPyBfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uY2h1bmtNYXRjaGVyKGNodW5rSWQpXG4gICAgICAgICAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW3Jlc29sdmUsIHJlamVjdF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcyA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX19ub25fd2VicGFja19yZXF1aXJlX18oJ2ZzJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgwLCBleHBvcnRzLnJlc29sdmVGaWxlKShfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24ucm9vdE91dHB1dERpciB8fCAnJywgY2h1bmtJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZzICYmIGZzLmV4aXN0c1N5bmMoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGV4cG9ydHMubG9hZENodW5rKSgnZmlsZXN5c3RlbScsIGNodW5rSWQsIF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5yb290T3V0cHV0RGlyIHx8ICcnLCAoZXJyLCBjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmRlbGV0ZUNodW5rKShjaHVua0lkLCBpbnN0YWxsZWRDaHVua3MpICYmIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgZXhwb3J0cy5pbnN0YWxsQ2h1bmspKGNodW5rLCBpbnN0YWxsZWRDaHVua3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rTmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18udShjaHVua0lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkaW5nU3RyYXRlZ3kgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cC1ldmFsJyA6ICdodHRwLXZtJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgZXhwb3J0cy5sb2FkQ2h1bmspKGxvYWRpbmdTdHJhdGVneSwgY2h1bmtOYW1lLCBfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb24uaW5pdE9wdGlvbnMubmFtZSwgKGVyciwgY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5kZWxldGVDaHVuaykoY2h1bmtJZCwgaW5zdGFsbGVkQ2h1bmtzKSAmJiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGV4cG9ydHMuaW5zdGFsbENodW5rKShjaHVuaywgaW5zdGFsbGVkQ2h1bmtzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuZXhwb3J0cy5zZXR1cENodW5rSGFuZGxlciA9IHNldHVwQ2h1bmtIYW5kbGVyO1xuLy8gSG9pc3RlZCBmdW5jdGlvbiB0byBzZXQgdXAgd2VicGFjayByZXF1aXJlIHBhdGNoaW5nXG5jb25zdCBzZXR1cFdlYnBhY2tSZXF1aXJlUGF0Y2hpbmcgPSAoaGFuZGxlKSA9PiB7XG4gICAgaWYgKF9fd2VicGFja19yZXF1aXJlX18uZikge1xuICAgICAgICBpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5mLnJlcXVpcmUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignXFx4MWJbMzNtJXNcXHgxYlswbScsICdDQVVUSU9OOiBidWlsZCB0YXJnZXQgaXMgbm90IHNldCB0byBcImFzeW5jLW5vZGVcIiwgYXR0ZW1wdGluZyB0byBwYXRjaCBhZGRpdGlvbmFsIGNodW5rIGhhbmRsZXJzLiBUaGlzIG1heSBub3Qgd29yaycpO1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5mLnJlcXVpcmUgPSBoYW5kbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9fd2VicGFja19yZXF1aXJlX18uZi5yZWFkRmlsZVZtKSB7XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmYucmVhZEZpbGVWbSA9IGhhbmRsZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLnNldHVwV2VicGFja1JlcXVpcmVQYXRjaGluZyA9IHNldHVwV2VicGFja1JlcXVpcmVQYXRjaGluZztcbmZ1bmN0aW9uIGRlZmF1bHRfMSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnbm9kZS1mZWRlcmF0aW9uLXBsdWdpbicsXG4gICAgICAgIGJlZm9yZUluaXQoYXJncykge1xuICAgICAgICAgICAgLy8gUGF0Y2ggd2VicGFjayBjaHVuayBsb2FkaW5nIGhhbmRsZXJzXG4gICAgICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgY2h1bmsgdHJhY2tpbmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdGFsbGVkQ2h1bmtzID0ge307XG4gICAgICAgICAgICAgICAgLy8gU2V0IHVwIHdlYnBhY2sgc2NyaXB0IGxvYWRlclxuICAgICAgICAgICAgICAgICgwLCBleHBvcnRzLnNldHVwU2NyaXB0TG9hZGVyKSgpO1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgc2V0IHVwIHRoZSBjaHVuayBoYW5kbGVyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gKDAsIGV4cG9ydHMuc2V0dXBDaHVua0hhbmRsZXIpKGluc3RhbGxlZENodW5rcywgYXJncyk7XG4gICAgICAgICAgICAgICAgLy8gUGF0Y2ggd2VicGFjayByZXF1aXJlXG4gICAgICAgICAgICAgICAgKDAsIGV4cG9ydHMuc2V0dXBXZWJwYWNrUmVxdWlyZVBhdGNoaW5nKShoYW5kbGUpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydW50aW1lUGx1Z2luLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/node/dist/src/runtimePlugin.js?runtimePlugin\n");

/***/ }),

/***/ "./node_modules/@module-federation/runtime-core/dist/index.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/@module-federation/runtime-core/dist/index.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CurrentGlobal: () => (/* binding */ CurrentGlobal),\n/* harmony export */   Global: () => (/* binding */ Global),\n/* harmony export */   Module: () => (/* binding */ Module),\n/* harmony export */   ModuleFederation: () => (/* binding */ ModuleFederation),\n/* harmony export */   addGlobalSnapshot: () => (/* binding */ addGlobalSnapshot),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   getGlobalFederationConstructor: () => (/* binding */ getGlobalFederationConstructor),\n/* harmony export */   getGlobalSnapshot: () => (/* binding */ getGlobalSnapshot),\n/* harmony export */   getInfoWithoutType: () => (/* binding */ getInfoWithoutType),\n/* harmony export */   getRegisteredShare: () => (/* binding */ getRegisteredShare),\n/* harmony export */   getRemoteEntry: () => (/* binding */ getRemoteEntry),\n/* harmony export */   getRemoteInfo: () => (/* binding */ getRemoteInfo),\n/* harmony export */   helpers: () => (/* binding */ helpers),\n/* harmony export */   isStaticResourcesEqual: () => (/* binding */ isStaticResourcesEqual),\n/* harmony export */   loadScript: () => (/* reexport safe */ _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScript),\n/* harmony export */   loadScriptNode: () => (/* reexport safe */ _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScriptNode),\n/* harmony export */   matchRemoteWithNameAndExpose: () => (/* binding */ matchRemoteWithNameAndExpose),\n/* harmony export */   registerGlobalPlugins: () => (/* binding */ registerGlobalPlugins),\n/* harmony export */   resetFederationGlobalInfo: () => (/* binding */ resetFederationGlobalInfo),\n/* harmony export */   safeWrapper: () => (/* binding */ safeWrapper),\n/* harmony export */   satisfy: () => (/* binding */ satisfy),\n/* harmony export */   setGlobalFederationConstructor: () => (/* binding */ setGlobalFederationConstructor),\n/* harmony export */   setGlobalFederationInstance: () => (/* binding */ setGlobalFederationInstance),\n/* harmony export */   types: () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var _polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfills.esm.js */ \"./node_modules/@module-federation/runtime-core/dist/polyfills.esm.js\");\n/* harmony import */ var _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @module-federation/sdk */ \"./node_modules/@module-federation/sdk/dist/index.esm.js\");\n/* harmony import */ var _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @module-federation/error-codes */ \"./node_modules/@module-federation/error-codes/dist/index.esm.mjs\");\n\n\n\n\n\nconst LOG_CATEGORY = '[ Federation Runtime ]';\n// FIXME: pre-bundle ?\nconst logger = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLogger)(LOG_CATEGORY);\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction assert(condition, msg) {\n    if (!condition) {\n        error(msg);\n    }\n}\nfunction error(msg) {\n    if (msg instanceof Error) {\n        // Check if the message already starts with the log category to avoid duplication\n        if (!msg.message.startsWith(LOG_CATEGORY)) {\n            msg.message = `${LOG_CATEGORY}: ${msg.message}`;\n        }\n        throw msg;\n    }\n    throw new Error(`${LOG_CATEGORY}: ${msg}`);\n}\nfunction warn(msg) {\n    if (msg instanceof Error) {\n        // Check if the message already starts with the log category to avoid duplication\n        if (!msg.message.startsWith(LOG_CATEGORY)) {\n            msg.message = `${LOG_CATEGORY}: ${msg.message}`;\n        }\n        logger.warn(msg);\n    } else {\n        logger.warn(msg);\n    }\n}\n\nfunction addUniqueItem(arr, item) {\n    if (arr.findIndex((name)=>name === item) === -1) {\n        arr.push(item);\n    }\n    return arr;\n}\nfunction getFMId(remoteInfo) {\n    if ('version' in remoteInfo && remoteInfo.version) {\n        return `${remoteInfo.name}:${remoteInfo.version}`;\n    } else if ('entry' in remoteInfo && remoteInfo.entry) {\n        return `${remoteInfo.name}:${remoteInfo.entry}`;\n    } else {\n        return `${remoteInfo.name}`;\n    }\n}\nfunction isRemoteInfoWithEntry(remote) {\n    return typeof remote.entry !== 'undefined';\n}\nfunction isPureRemoteEntry(remote) {\n    return !remote.entry.includes('.json');\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function safeWrapper(callback, disableWarn) {\n    try {\n        const res = await callback();\n        return res;\n    } catch (e) {\n        !disableWarn && warn(e);\n        return;\n    }\n}\nfunction isObject(val) {\n    return val && typeof val === 'object';\n}\nconst objectToString = Object.prototype.toString;\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isPlainObject(val) {\n    return objectToString.call(val) === '[object Object]';\n}\nfunction isStaticResourcesEqual(url1, url2) {\n    const REG_EXP = /^(https?:)?\\/\\//i;\n    // Transform url1 and url2 into relative paths\n    const relativeUrl1 = url1.replace(REG_EXP, '').replace(/\\/$/, '');\n    const relativeUrl2 = url2.replace(REG_EXP, '').replace(/\\/$/, '');\n    // Check if the relative paths are identical\n    return relativeUrl1 === relativeUrl2;\n}\nfunction arrayOptions(options) {\n    return Array.isArray(options) ? options : [\n        options\n    ];\n}\nfunction getRemoteEntryInfoFromSnapshot(snapshot) {\n    const defaultRemoteEntryInfo = {\n        url: '',\n        type: 'global',\n        globalName: ''\n    };\n    if ((0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)() || (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isReactNativeEnv)()) {\n        return 'remoteEntry' in snapshot ? {\n            url: snapshot.remoteEntry,\n            type: snapshot.remoteEntryType,\n            globalName: snapshot.globalName\n        } : defaultRemoteEntryInfo;\n    }\n    if ('ssrRemoteEntry' in snapshot) {\n        return {\n            url: snapshot.ssrRemoteEntry || defaultRemoteEntryInfo.url,\n            type: snapshot.ssrRemoteEntryType || defaultRemoteEntryInfo.type,\n            globalName: snapshot.globalName\n        };\n    }\n    return defaultRemoteEntryInfo;\n}\nconst processModuleAlias = (name, subPath)=>{\n    // @host/ ./button -> @host/button\n    let moduleName;\n    if (name.endsWith('/')) {\n        moduleName = name.slice(0, -1);\n    } else {\n        moduleName = name;\n    }\n    if (subPath.startsWith('.')) {\n        subPath = subPath.slice(1);\n    }\n    moduleName = moduleName + subPath;\n    return moduleName;\n};\n\nconst CurrentGlobal = typeof globalThis === 'object' ? globalThis : window;\nconst nativeGlobal = (()=>{\n    try {\n        // get real window (incase of sandbox)\n        return document.defaultView;\n    } catch (e) {\n        // node env\n        return CurrentGlobal;\n    }\n})();\nconst Global = nativeGlobal;\nfunction definePropertyGlobalVal(target, key, val) {\n    Object.defineProperty(target, key, {\n        value: val,\n        configurable: false,\n        writable: true\n    });\n}\nfunction includeOwnProperty(target, key) {\n    return Object.hasOwnProperty.call(target, key);\n}\n// This section is to prevent encapsulation by certain microfrontend frameworks. Due to reuse policies, sandbox escapes.\n// The sandbox in the microfrontend does not replicate the value of 'configurable'.\n// If there is no loading content on the global object, this section defines the loading object.\nif (!includeOwnProperty(CurrentGlobal, '__GLOBAL_LOADING_REMOTE_ENTRY__')) {\n    definePropertyGlobalVal(CurrentGlobal, '__GLOBAL_LOADING_REMOTE_ENTRY__', {});\n}\nconst globalLoading = CurrentGlobal.__GLOBAL_LOADING_REMOTE_ENTRY__;\nfunction setGlobalDefaultVal(target) {\n    var _target___FEDERATION__, _target___FEDERATION__1, _target___FEDERATION__2, _target___FEDERATION__3, _target___FEDERATION__4, _target___FEDERATION__5;\n    if (includeOwnProperty(target, '__VMOK__') && !includeOwnProperty(target, '__FEDERATION__')) {\n        definePropertyGlobalVal(target, '__FEDERATION__', target.__VMOK__);\n    }\n    if (!includeOwnProperty(target, '__FEDERATION__')) {\n        definePropertyGlobalVal(target, '__FEDERATION__', {\n            __GLOBAL_PLUGIN__: [],\n            __INSTANCES__: [],\n            moduleInfo: {},\n            __SHARE__: {},\n            __MANIFEST_LOADING__: {},\n            __PRELOADED_MAP__: new Map()\n        });\n        definePropertyGlobalVal(target, '__VMOK__', target.__FEDERATION__);\n    }\n    var ___GLOBAL_PLUGIN__;\n    (___GLOBAL_PLUGIN__ = (_target___FEDERATION__ = target.__FEDERATION__).__GLOBAL_PLUGIN__) != null ? ___GLOBAL_PLUGIN__ : _target___FEDERATION__.__GLOBAL_PLUGIN__ = [];\n    var ___INSTANCES__;\n    (___INSTANCES__ = (_target___FEDERATION__1 = target.__FEDERATION__).__INSTANCES__) != null ? ___INSTANCES__ : _target___FEDERATION__1.__INSTANCES__ = [];\n    var _moduleInfo;\n    (_moduleInfo = (_target___FEDERATION__2 = target.__FEDERATION__).moduleInfo) != null ? _moduleInfo : _target___FEDERATION__2.moduleInfo = {};\n    var ___SHARE__;\n    (___SHARE__ = (_target___FEDERATION__3 = target.__FEDERATION__).__SHARE__) != null ? ___SHARE__ : _target___FEDERATION__3.__SHARE__ = {};\n    var ___MANIFEST_LOADING__;\n    (___MANIFEST_LOADING__ = (_target___FEDERATION__4 = target.__FEDERATION__).__MANIFEST_LOADING__) != null ? ___MANIFEST_LOADING__ : _target___FEDERATION__4.__MANIFEST_LOADING__ = {};\n    var ___PRELOADED_MAP__;\n    (___PRELOADED_MAP__ = (_target___FEDERATION__5 = target.__FEDERATION__).__PRELOADED_MAP__) != null ? ___PRELOADED_MAP__ : _target___FEDERATION__5.__PRELOADED_MAP__ = new Map();\n}\nsetGlobalDefaultVal(CurrentGlobal);\nsetGlobalDefaultVal(nativeGlobal);\nfunction resetFederationGlobalInfo() {\n    CurrentGlobal.__FEDERATION__.__GLOBAL_PLUGIN__ = [];\n    CurrentGlobal.__FEDERATION__.__INSTANCES__ = [];\n    CurrentGlobal.__FEDERATION__.moduleInfo = {};\n    CurrentGlobal.__FEDERATION__.__SHARE__ = {};\n    CurrentGlobal.__FEDERATION__.__MANIFEST_LOADING__ = {};\n    Object.keys(globalLoading).forEach((key)=>{\n        delete globalLoading[key];\n    });\n}\nfunction setGlobalFederationInstance(FederationInstance) {\n    CurrentGlobal.__FEDERATION__.__INSTANCES__.push(FederationInstance);\n}\nfunction getGlobalFederationConstructor() {\n    return CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR__;\n}\nfunction setGlobalFederationConstructor(FederationConstructor, isDebug = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isDebugMode)()) {\n    if (isDebug) {\n        CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = FederationConstructor;\n        CurrentGlobal.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = \"0.18.3\";\n    }\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getInfoWithoutType(target, key) {\n    if (typeof key === 'string') {\n        const keyRes = target[key];\n        if (keyRes) {\n            return {\n                value: target[key],\n                key: key\n            };\n        } else {\n            const targetKeys = Object.keys(target);\n            for (const targetKey of targetKeys){\n                const [targetTypeOrName, _] = targetKey.split(':');\n                const nKey = `${targetTypeOrName}:${key}`;\n                const typeWithKeyRes = target[nKey];\n                if (typeWithKeyRes) {\n                    return {\n                        value: typeWithKeyRes,\n                        key: nKey\n                    };\n                }\n            }\n            return {\n                value: undefined,\n                key: key\n            };\n        }\n    } else {\n        throw new Error('key must be string');\n    }\n}\nconst getGlobalSnapshot = ()=>nativeGlobal.__FEDERATION__.moduleInfo;\nconst getTargetSnapshotInfoByModuleInfo = (moduleInfo, snapshot)=>{\n    // Check if the remote is included in the hostSnapshot\n    const moduleKey = getFMId(moduleInfo);\n    const getModuleInfo = getInfoWithoutType(snapshot, moduleKey).value;\n    // The remoteSnapshot might not include a version\n    if (getModuleInfo && !getModuleInfo.version && 'version' in moduleInfo && moduleInfo['version']) {\n        getModuleInfo.version = moduleInfo['version'];\n    }\n    if (getModuleInfo) {\n        return getModuleInfo;\n    }\n    // If the remote is not included in the hostSnapshot, deploy a micro app snapshot\n    if ('version' in moduleInfo && moduleInfo['version']) {\n        const { version } = moduleInfo, resModuleInfo = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(moduleInfo, [\n            \"version\"\n        ]);\n        const moduleKeyWithoutVersion = getFMId(resModuleInfo);\n        const getModuleInfoWithoutVersion = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, moduleKeyWithoutVersion).value;\n        if ((getModuleInfoWithoutVersion == null ? void 0 : getModuleInfoWithoutVersion.version) === version) {\n            return getModuleInfoWithoutVersion;\n        }\n    }\n    return;\n};\nconst getGlobalSnapshotInfoByModuleInfo = (moduleInfo)=>getTargetSnapshotInfoByModuleInfo(moduleInfo, nativeGlobal.__FEDERATION__.moduleInfo);\nconst setGlobalSnapshotInfoByModuleInfo = (remoteInfo, moduleDetailInfo)=>{\n    const moduleKey = getFMId(remoteInfo);\n    nativeGlobal.__FEDERATION__.moduleInfo[moduleKey] = moduleDetailInfo;\n    return nativeGlobal.__FEDERATION__.moduleInfo;\n};\nconst addGlobalSnapshot = (moduleInfos)=>{\n    nativeGlobal.__FEDERATION__.moduleInfo = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, nativeGlobal.__FEDERATION__.moduleInfo, moduleInfos);\n    return ()=>{\n        const keys = Object.keys(moduleInfos);\n        for (const key of keys){\n            delete nativeGlobal.__FEDERATION__.moduleInfo[key];\n        }\n    };\n};\nconst getRemoteEntryExports = (name, globalName)=>{\n    const remoteEntryKey = globalName || `__FEDERATION_${name}:custom__`;\n    const entryExports = CurrentGlobal[remoteEntryKey];\n    return {\n        remoteEntryKey,\n        entryExports\n    };\n};\n// This function is used to register global plugins.\n// It iterates over the provided plugins and checks if they are already registered.\n// If a plugin is not registered, it is added to the global plugins.\n// If a plugin is already registered, a warning message is logged.\nconst registerGlobalPlugins = (plugins)=>{\n    const { __GLOBAL_PLUGIN__ } = nativeGlobal.__FEDERATION__;\n    plugins.forEach((plugin)=>{\n        if (__GLOBAL_PLUGIN__.findIndex((p)=>p.name === plugin.name) === -1) {\n            __GLOBAL_PLUGIN__.push(plugin);\n        } else {\n            warn(`The plugin ${plugin.name} has been registered.`);\n        }\n    });\n};\nconst getGlobalHostPlugins = ()=>nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__;\nconst getPreloaded = (id)=>CurrentGlobal.__FEDERATION__.__PRELOADED_MAP__.get(id);\nconst setPreloaded = (id)=>CurrentGlobal.__FEDERATION__.__PRELOADED_MAP__.set(id, true);\n\nconst DEFAULT_SCOPE = 'default';\nconst DEFAULT_REMOTE_TYPE = 'global';\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// those constants are based on https://www.rubydoc.info/gems/semantic_range/3.0.0/SemanticRange#BUILDIDENTIFIER-constant\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nconst buildIdentifier = '[0-9A-Za-z-]+';\nconst build = `(?:\\\\+(${buildIdentifier}(?:\\\\.${buildIdentifier})*))`;\nconst numericIdentifier = '0|[1-9]\\\\d*';\nconst numericIdentifierLoose = '[0-9]+';\nconst nonNumericIdentifier = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\nconst preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`;\nconst preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\\\.${preReleaseIdentifierLoose})*))`;\nconst preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`;\nconst preRelease = `(?:-(${preReleaseIdentifier}(?:\\\\.${preReleaseIdentifier})*))`;\nconst xRangeIdentifier = `${numericIdentifier}|x|X|\\\\*`;\nconst xRangePlain = `[v=\\\\s]*(${xRangeIdentifier})(?:\\\\.(${xRangeIdentifier})(?:\\\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`;\nconst hyphenRange = `^\\\\s*(${xRangePlain})\\\\s+-\\\\s+(${xRangePlain})\\\\s*$`;\nconst mainVersionLoose = `(${numericIdentifierLoose})\\\\.(${numericIdentifierLoose})\\\\.(${numericIdentifierLoose})`;\nconst loosePlain = `[v=\\\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`;\nconst gtlt = '((?:<|>)?=?)';\nconst comparatorTrim = `(\\\\s*)${gtlt}\\\\s*(${loosePlain}|${xRangePlain})`;\nconst loneTilde = '(?:~>?)';\nconst tildeTrim = `(\\\\s*)${loneTilde}\\\\s+`;\nconst loneCaret = '(?:\\\\^)';\nconst caretTrim = `(\\\\s*)${loneCaret}\\\\s+`;\nconst star = '(<|>)?=?\\\\s*\\\\*';\nconst caret = `^${loneCaret}${xRangePlain}$`;\nconst mainVersion = `(${numericIdentifier})\\\\.(${numericIdentifier})\\\\.(${numericIdentifier})`;\nconst fullPlain = `v?${mainVersion}${preRelease}?${build}?`;\nconst tilde = `^${loneTilde}${xRangePlain}$`;\nconst xRange = `^${gtlt}\\\\s*${xRangePlain}$`;\nconst comparator = `^${gtlt}\\\\s*(${fullPlain})$|^$`;\n// copy from semver package\nconst gte0 = '^\\\\s*>=\\\\s*0.0.0\\\\s*$';\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nfunction parseRegex(source) {\n    return new RegExp(source);\n}\nfunction isXVersion(version) {\n    return !version || version.toLowerCase() === 'x' || version === '*';\n}\nfunction pipe(...fns) {\n    return (x)=>fns.reduce((v, f)=>f(v), x);\n}\nfunction extractComparator(comparatorString) {\n    return comparatorString.match(parseRegex(comparator));\n}\nfunction combineVersion(major, minor, patch, preRelease) {\n    const mainVersion = `${major}.${minor}.${patch}`;\n    if (preRelease) {\n        return `${mainVersion}-${preRelease}`;\n    }\n    return mainVersion;\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nfunction parseHyphen(range) {\n    return range.replace(parseRegex(hyphenRange), (_range, from, fromMajor, fromMinor, fromPatch, _fromPreRelease, _fromBuild, to, toMajor, toMinor, toPatch, toPreRelease)=>{\n        if (isXVersion(fromMajor)) {\n            from = '';\n        } else if (isXVersion(fromMinor)) {\n            from = `>=${fromMajor}.0.0`;\n        } else if (isXVersion(fromPatch)) {\n            from = `>=${fromMajor}.${fromMinor}.0`;\n        } else {\n            from = `>=${from}`;\n        }\n        if (isXVersion(toMajor)) {\n            to = '';\n        } else if (isXVersion(toMinor)) {\n            to = `<${Number(toMajor) + 1}.0.0-0`;\n        } else if (isXVersion(toPatch)) {\n            to = `<${toMajor}.${Number(toMinor) + 1}.0-0`;\n        } else if (toPreRelease) {\n            to = `<=${toMajor}.${toMinor}.${toPatch}-${toPreRelease}`;\n        } else {\n            to = `<=${to}`;\n        }\n        return `${from} ${to}`.trim();\n    });\n}\nfunction parseComparatorTrim(range) {\n    return range.replace(parseRegex(comparatorTrim), '$1$2$3');\n}\nfunction parseTildeTrim(range) {\n    return range.replace(parseRegex(tildeTrim), '$1~');\n}\nfunction parseCaretTrim(range) {\n    return range.replace(parseRegex(caretTrim), '$1^');\n}\nfunction parseCarets(range) {\n    return range.trim().split(/\\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(caret), (_, major, minor, patch, preRelease)=>{\n            if (isXVersion(major)) {\n                return '';\n            } else if (isXVersion(minor)) {\n                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;\n            } else if (isXVersion(patch)) {\n                if (major === '0') {\n                    return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;\n                } else {\n                    return `>=${major}.${minor}.0 <${Number(major) + 1}.0.0-0`;\n                }\n            } else if (preRelease) {\n                if (major === '0') {\n                    if (minor === '0') {\n                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${minor}.${Number(patch) + 1}-0`;\n                    } else {\n                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n                    }\n                } else {\n                    return `>=${major}.${minor}.${patch}-${preRelease} <${Number(major) + 1}.0.0-0`;\n                }\n            } else {\n                if (major === '0') {\n                    if (minor === '0') {\n                        return `>=${major}.${minor}.${patch} <${major}.${minor}.${Number(patch) + 1}-0`;\n                    } else {\n                        return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;\n                    }\n                }\n                return `>=${major}.${minor}.${patch} <${Number(major) + 1}.0.0-0`;\n            }\n        })).join(' ');\n}\nfunction parseTildes(range) {\n    return range.trim().split(/\\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(tilde), (_, major, minor, patch, preRelease)=>{\n            if (isXVersion(major)) {\n                return '';\n            } else if (isXVersion(minor)) {\n                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;\n            } else if (isXVersion(patch)) {\n                return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;\n            } else if (preRelease) {\n                return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n            }\n            return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;\n        })).join(' ');\n}\nfunction parseXRanges(range) {\n    return range.split(/\\s+/).map((rangeVersion)=>rangeVersion.trim().replace(parseRegex(xRange), (ret, gtlt, major, minor, patch, preRelease)=>{\n            const isXMajor = isXVersion(major);\n            const isXMinor = isXMajor || isXVersion(minor);\n            const isXPatch = isXMinor || isXVersion(patch);\n            if (gtlt === '=' && isXPatch) {\n                gtlt = '';\n            }\n            preRelease = '';\n            if (isXMajor) {\n                if (gtlt === '>' || gtlt === '<') {\n                    // nothing is allowed\n                    return '<0.0.0-0';\n                } else {\n                    // nothing is forbidden\n                    return '*';\n                }\n            } else if (gtlt && isXPatch) {\n                // replace X with 0\n                if (isXMinor) {\n                    minor = 0;\n                }\n                patch = 0;\n                if (gtlt === '>') {\n                    // >1 => >=2.0.0\n                    // >1.2 => >=1.3.0\n                    gtlt = '>=';\n                    if (isXMinor) {\n                        major = Number(major) + 1;\n                        minor = 0;\n                        patch = 0;\n                    } else {\n                        minor = Number(minor) + 1;\n                        patch = 0;\n                    }\n                } else if (gtlt === '<=') {\n                    // <=0.7.x is actually <0.8.0, since any 0.7.x should pass\n                    // Similarly, <=7.x is actually <8.0.0, etc.\n                    gtlt = '<';\n                    if (isXMinor) {\n                        major = Number(major) + 1;\n                    } else {\n                        minor = Number(minor) + 1;\n                    }\n                }\n                if (gtlt === '<') {\n                    preRelease = '-0';\n                }\n                return `${gtlt + major}.${minor}.${patch}${preRelease}`;\n            } else if (isXMinor) {\n                return `>=${major}.0.0${preRelease} <${Number(major) + 1}.0.0-0`;\n            } else if (isXPatch) {\n                return `>=${major}.${minor}.0${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n            }\n            return ret;\n        })).join(' ');\n}\nfunction parseStar(range) {\n    return range.trim().replace(parseRegex(star), '');\n}\nfunction parseGTE0(comparatorString) {\n    return comparatorString.trim().replace(parseRegex(gte0), '');\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nfunction compareAtom(rangeAtom, versionAtom) {\n    rangeAtom = Number(rangeAtom) || rangeAtom;\n    versionAtom = Number(versionAtom) || versionAtom;\n    if (rangeAtom > versionAtom) {\n        return 1;\n    }\n    if (rangeAtom === versionAtom) {\n        return 0;\n    }\n    return -1;\n}\nfunction comparePreRelease(rangeAtom, versionAtom) {\n    const { preRelease: rangePreRelease } = rangeAtom;\n    const { preRelease: versionPreRelease } = versionAtom;\n    if (rangePreRelease === undefined && Boolean(versionPreRelease)) {\n        return 1;\n    }\n    if (Boolean(rangePreRelease) && versionPreRelease === undefined) {\n        return -1;\n    }\n    if (rangePreRelease === undefined && versionPreRelease === undefined) {\n        return 0;\n    }\n    for(let i = 0, n = rangePreRelease.length; i <= n; i++){\n        const rangeElement = rangePreRelease[i];\n        const versionElement = versionPreRelease[i];\n        if (rangeElement === versionElement) {\n            continue;\n        }\n        if (rangeElement === undefined && versionElement === undefined) {\n            return 0;\n        }\n        if (!rangeElement) {\n            return 1;\n        }\n        if (!versionElement) {\n            return -1;\n        }\n        return compareAtom(rangeElement, versionElement);\n    }\n    return 0;\n}\nfunction compareVersion(rangeAtom, versionAtom) {\n    return compareAtom(rangeAtom.major, versionAtom.major) || compareAtom(rangeAtom.minor, versionAtom.minor) || compareAtom(rangeAtom.patch, versionAtom.patch) || comparePreRelease(rangeAtom, versionAtom);\n}\nfunction eq(rangeAtom, versionAtom) {\n    return rangeAtom.version === versionAtom.version;\n}\nfunction compare(rangeAtom, versionAtom) {\n    switch(rangeAtom.operator){\n        case '':\n        case '=':\n            return eq(rangeAtom, versionAtom);\n        case '>':\n            return compareVersion(rangeAtom, versionAtom) < 0;\n        case '>=':\n            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) < 0;\n        case '<':\n            return compareVersion(rangeAtom, versionAtom) > 0;\n        case '<=':\n            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) > 0;\n        case undefined:\n            {\n                // mean * or x -> all versions\n                return true;\n            }\n        default:\n            return false;\n    }\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nfunction parseComparatorString(range) {\n    return pipe(// handle caret\n    // ^ --> * (any, kinda silly)\n    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n    // ^1.2.3 --> >=1.2.3 <2.0.0-0\n    // ^1.2.0 --> >=1.2.0 <2.0.0-0\n    parseCarets, // handle tilde\n    // ~, ~> --> * (any, kinda silly)\n    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n    parseTildes, parseXRanges, parseStar)(range);\n}\nfunction parseRange(range) {\n    return pipe(// handle hyphenRange\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    parseHyphen, // handle trim comparator\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    parseComparatorTrim, // handle trim tilde\n    // `~ 1.2.3` => `~1.2.3`\n    parseTildeTrim, // handle trim caret\n    // `^ 1.2.3` => `^1.2.3`\n    parseCaretTrim)(range.trim()).split(/\\s+/).join(' ');\n}\nfunction satisfy(version, range) {\n    if (!version) {\n        return false;\n    }\n    // Extract version details once\n    const extractedVersion = extractComparator(version);\n    if (!extractedVersion) {\n        // If the version string is invalid, it can't satisfy any range\n        return false;\n    }\n    const [, versionOperator, , versionMajor, versionMinor, versionPatch, versionPreRelease] = extractedVersion;\n    const versionAtom = {\n        operator: versionOperator,\n        version: combineVersion(versionMajor, versionMinor, versionPatch, versionPreRelease),\n        major: versionMajor,\n        minor: versionMinor,\n        patch: versionPatch,\n        preRelease: versionPreRelease == null ? void 0 : versionPreRelease.split('.')\n    };\n    // Split the range by || to handle OR conditions\n    const orRanges = range.split('||');\n    for (const orRange of orRanges){\n        const trimmedOrRange = orRange.trim();\n        if (!trimmedOrRange) {\n            // An empty range string signifies wildcard *, satisfy any valid version\n            // (We already checked if the version itself is valid)\n            return true;\n        }\n        // Handle simple wildcards explicitly before complex parsing\n        if (trimmedOrRange === '*' || trimmedOrRange === 'x') {\n            return true;\n        }\n        try {\n            // Apply existing parsing logic to the current OR sub-range\n            const parsedSubRange = parseRange(trimmedOrRange); // Handles hyphens, trims etc.\n            // Check if the result of initial parsing is empty, which can happen\n            // for some wildcard cases handled by parseRange/parseComparatorString.\n            // E.g. `parseStar` used in `parseComparatorString` returns ''.\n            if (!parsedSubRange.trim()) {\n                // If parsing results in empty string, treat as wildcard match\n                return true;\n            }\n            const parsedComparatorString = parsedSubRange.split(' ').map((rangeVersion)=>parseComparatorString(rangeVersion)) // Expands ^, ~\n            .join(' ');\n            // Check again if the comparator string became empty after specific parsing like ^ or ~\n            if (!parsedComparatorString.trim()) {\n                return true;\n            }\n            // Split the sub-range by space for implicit AND conditions\n            const comparators = parsedComparatorString.split(/\\s+/).map((comparator)=>parseGTE0(comparator))// Filter out empty strings that might result from multiple spaces\n            .filter(Boolean);\n            // If a sub-range becomes empty after parsing (e.g., invalid characters),\n            // it cannot be satisfied. This check might be redundant now but kept for safety.\n            if (comparators.length === 0) {\n                continue;\n            }\n            let subRangeSatisfied = true;\n            for (const comparator of comparators){\n                const extractedComparator = extractComparator(comparator);\n                // If any part of the AND sub-range is invalid, the sub-range is not satisfied\n                if (!extractedComparator) {\n                    subRangeSatisfied = false;\n                    break;\n                }\n                const [, rangeOperator, , rangeMajor, rangeMinor, rangePatch, rangePreRelease] = extractedComparator;\n                const rangeAtom = {\n                    operator: rangeOperator,\n                    version: combineVersion(rangeMajor, rangeMinor, rangePatch, rangePreRelease),\n                    major: rangeMajor,\n                    minor: rangeMinor,\n                    patch: rangePatch,\n                    preRelease: rangePreRelease == null ? void 0 : rangePreRelease.split('.')\n                };\n                // Check if the version satisfies this specific comparator in the AND chain\n                if (!compare(rangeAtom, versionAtom)) {\n                    subRangeSatisfied = false; // This part of the AND condition failed\n                    break; // No need to check further comparators in this sub-range\n                }\n            }\n            // If all AND conditions within this OR sub-range were met, the overall range is satisfied\n            if (subRangeSatisfied) {\n                return true;\n            }\n        } catch (e) {\n            // Log error and treat this sub-range as unsatisfied\n            console.error(`[semver] Error processing range part \"${trimmedOrRange}\":`, e);\n            continue;\n        }\n    }\n    // If none of the OR sub-ranges were satisfied\n    return false;\n}\n\nfunction formatShare(shareArgs, from, name, shareStrategy) {\n    let get;\n    if ('get' in shareArgs) {\n        // eslint-disable-next-line prefer-destructuring\n        get = shareArgs.get;\n    } else if ('lib' in shareArgs) {\n        get = ()=>Promise.resolve(shareArgs.lib);\n    } else {\n        get = ()=>Promise.resolve(()=>{\n                throw new Error(`Can not get shared '${name}'!`);\n            });\n    }\n    var _shareArgs_version, _shareArgs_scope, _shareArgs_strategy;\n    return (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n        deps: [],\n        useIn: [],\n        from,\n        loading: null\n    }, shareArgs, {\n        shareConfig: (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n            requiredVersion: `^${shareArgs.version}`,\n            singleton: false,\n            eager: false,\n            strictVersion: false\n        }, shareArgs.shareConfig),\n        get,\n        loaded: (shareArgs == null ? void 0 : shareArgs.loaded) || 'lib' in shareArgs ? true : undefined,\n        version: (_shareArgs_version = shareArgs.version) != null ? _shareArgs_version : '0',\n        scope: Array.isArray(shareArgs.scope) ? shareArgs.scope : [\n            (_shareArgs_scope = shareArgs.scope) != null ? _shareArgs_scope : 'default'\n        ],\n        strategy: ((_shareArgs_strategy = shareArgs.strategy) != null ? _shareArgs_strategy : shareStrategy) || 'version-first'\n    });\n}\nfunction formatShareConfigs(globalOptions, userOptions) {\n    const shareArgs = userOptions.shared || {};\n    const from = userOptions.name;\n    const shareInfos = Object.keys(shareArgs).reduce((res, pkgName)=>{\n        const arrayShareArgs = arrayOptions(shareArgs[pkgName]);\n        res[pkgName] = res[pkgName] || [];\n        arrayShareArgs.forEach((shareConfig)=>{\n            res[pkgName].push(formatShare(shareConfig, from, pkgName, userOptions.shareStrategy));\n        });\n        return res;\n    }, {});\n    const shared = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, globalOptions.shared);\n    Object.keys(shareInfos).forEach((shareKey)=>{\n        if (!shared[shareKey]) {\n            shared[shareKey] = shareInfos[shareKey];\n        } else {\n            shareInfos[shareKey].forEach((newUserSharedOptions)=>{\n                const isSameVersion = shared[shareKey].find((sharedVal)=>sharedVal.version === newUserSharedOptions.version);\n                if (!isSameVersion) {\n                    shared[shareKey].push(newUserSharedOptions);\n                }\n            });\n        }\n    });\n    return {\n        shared,\n        shareInfos\n    };\n}\nfunction versionLt(a, b) {\n    const transformInvalidVersion = (version)=>{\n        const isNumberVersion = !Number.isNaN(Number(version));\n        if (isNumberVersion) {\n            const splitArr = version.split('.');\n            let validVersion = version;\n            for(let i = 0; i < 3 - splitArr.length; i++){\n                validVersion += '.0';\n            }\n            return validVersion;\n        }\n        return version;\n    };\n    if (satisfy(transformInvalidVersion(a), `<=${transformInvalidVersion(b)}`)) {\n        return true;\n    } else {\n        return false;\n    }\n}\nconst findVersion = (shareVersionMap, cb)=>{\n    const callback = cb || function(prev, cur) {\n        return versionLt(prev, cur);\n    };\n    return Object.keys(shareVersionMap).reduce((prev, cur)=>{\n        if (!prev) {\n            return cur;\n        }\n        if (callback(prev, cur)) {\n            return cur;\n        }\n        // default version is '0' https://github.com/webpack/webpack/blob/main/lib/sharing/ProvideSharedModule.js#L136\n        if (prev === '0') {\n            return cur;\n        }\n        return prev;\n    }, 0);\n};\nconst isLoaded = (shared)=>{\n    return Boolean(shared.loaded) || typeof shared.lib === 'function';\n};\nconst isLoading = (shared)=>{\n    return Boolean(shared.loading);\n};\nfunction findSingletonVersionOrderByVersion(shareScopeMap, scope, pkgName) {\n    const versions = shareScopeMap[scope][pkgName];\n    const callback = function(prev, cur) {\n        return !isLoaded(versions[prev]) && versionLt(prev, cur);\n    };\n    return findVersion(shareScopeMap[scope][pkgName], callback);\n}\nfunction findSingletonVersionOrderByLoaded(shareScopeMap, scope, pkgName) {\n    const versions = shareScopeMap[scope][pkgName];\n    const callback = function(prev, cur) {\n        const isLoadingOrLoaded = (shared)=>{\n            return isLoaded(shared) || isLoading(shared);\n        };\n        if (isLoadingOrLoaded(versions[cur])) {\n            if (isLoadingOrLoaded(versions[prev])) {\n                return Boolean(versionLt(prev, cur));\n            } else {\n                return true;\n            }\n        }\n        if (isLoadingOrLoaded(versions[prev])) {\n            return false;\n        }\n        return versionLt(prev, cur);\n    };\n    return findVersion(shareScopeMap[scope][pkgName], callback);\n}\nfunction getFindShareFunction(strategy) {\n    if (strategy === 'loaded-first') {\n        return findSingletonVersionOrderByLoaded;\n    }\n    return findSingletonVersionOrderByVersion;\n}\nfunction getRegisteredShare(localShareScopeMap, pkgName, shareInfo, resolveShare) {\n    if (!localShareScopeMap) {\n        return;\n    }\n    const { shareConfig, scope = DEFAULT_SCOPE, strategy } = shareInfo;\n    const scopes = Array.isArray(scope) ? scope : [\n        scope\n    ];\n    for (const sc of scopes){\n        if (shareConfig && localShareScopeMap[sc] && localShareScopeMap[sc][pkgName]) {\n            const { requiredVersion } = shareConfig;\n            const findShareFunction = getFindShareFunction(strategy);\n            const maxOrSingletonVersion = findShareFunction(localShareScopeMap, sc, pkgName);\n            //@ts-ignore\n            const defaultResolver = ()=>{\n                if (shareConfig.singleton) {\n                    if (typeof requiredVersion === 'string' && !satisfy(maxOrSingletonVersion, requiredVersion)) {\n                        const msg = `Version ${maxOrSingletonVersion} from ${maxOrSingletonVersion && localShareScopeMap[sc][pkgName][maxOrSingletonVersion].from} of shared singleton module ${pkgName} does not satisfy the requirement of ${shareInfo.from} which needs ${requiredVersion})`;\n                        if (shareConfig.strictVersion) {\n                            error(msg);\n                        } else {\n                            warn(msg);\n                        }\n                    }\n                    return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                } else {\n                    if (requiredVersion === false || requiredVersion === '*') {\n                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                    }\n                    if (satisfy(maxOrSingletonVersion, requiredVersion)) {\n                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                    }\n                    for (const [versionKey, versionValue] of Object.entries(localShareScopeMap[sc][pkgName])){\n                        if (satisfy(versionKey, requiredVersion)) {\n                            return versionValue;\n                        }\n                    }\n                }\n            };\n            const params = {\n                shareScopeMap: localShareScopeMap,\n                scope: sc,\n                pkgName,\n                version: maxOrSingletonVersion,\n                GlobalFederation: Global.__FEDERATION__,\n                resolver: defaultResolver\n            };\n            const resolveShared = resolveShare.emit(params) || params;\n            return resolveShared.resolver();\n        }\n    }\n}\nfunction getGlobalShareScope() {\n    return Global.__FEDERATION__.__SHARE__;\n}\nfunction getTargetSharedOptions(options) {\n    const { pkgName, extraOptions, shareInfos } = options;\n    const defaultResolver = (sharedOptions)=>{\n        if (!sharedOptions) {\n            return undefined;\n        }\n        const shareVersionMap = {};\n        sharedOptions.forEach((shared)=>{\n            shareVersionMap[shared.version] = shared;\n        });\n        const callback = function(prev, cur) {\n            return !isLoaded(shareVersionMap[prev]) && versionLt(prev, cur);\n        };\n        const maxVersion = findVersion(shareVersionMap, callback);\n        return shareVersionMap[maxVersion];\n    };\n    var _extraOptions_resolver;\n    const resolver = (_extraOptions_resolver = extraOptions == null ? void 0 : extraOptions.resolver) != null ? _extraOptions_resolver : defaultResolver;\n    return Object.assign({}, resolver(shareInfos[pkgName]), extraOptions == null ? void 0 : extraOptions.customShareInfo);\n}\n\nfunction getBuilderId() {\n    //@ts-ignore\n    return  true ? \"chart_app:0.1.0\" : 0;\n}\n\n// Function to match a remote with its name and expose\n// id: pkgName(@federation/app1) + expose(button) = @federation/app1/button\n// id: alias(app1) + expose(button) = app1/button\n// id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort\nfunction matchRemoteWithNameAndExpose(remotes, id) {\n    for (const remote of remotes){\n        // match pkgName\n        const isNameMatched = id.startsWith(remote.name);\n        let expose = id.replace(remote.name, '');\n        if (isNameMatched) {\n            if (expose.startsWith('/')) {\n                const pkgNameOrAlias = remote.name;\n                expose = `.${expose}`;\n                return {\n                    pkgNameOrAlias,\n                    expose,\n                    remote\n                };\n            } else if (expose === '') {\n                return {\n                    pkgNameOrAlias: remote.name,\n                    expose: '.',\n                    remote\n                };\n            }\n        }\n        // match alias\n        const isAliasMatched = remote.alias && id.startsWith(remote.alias);\n        let exposeWithAlias = remote.alias && id.replace(remote.alias, '');\n        if (remote.alias && isAliasMatched) {\n            if (exposeWithAlias && exposeWithAlias.startsWith('/')) {\n                const pkgNameOrAlias = remote.alias;\n                exposeWithAlias = `.${exposeWithAlias}`;\n                return {\n                    pkgNameOrAlias,\n                    expose: exposeWithAlias,\n                    remote\n                };\n            } else if (exposeWithAlias === '') {\n                return {\n                    pkgNameOrAlias: remote.alias,\n                    expose: '.',\n                    remote\n                };\n            }\n        }\n    }\n    return;\n}\n// Function to match a remote with its name or alias\nfunction matchRemote(remotes, nameOrAlias) {\n    for (const remote of remotes){\n        const isNameMatched = nameOrAlias === remote.name;\n        if (isNameMatched) {\n            return remote;\n        }\n        const isAliasMatched = remote.alias && nameOrAlias === remote.alias;\n        if (isAliasMatched) {\n            return remote;\n        }\n    }\n    return;\n}\n\nfunction registerPlugins(plugins, instance) {\n    const globalPlugins = getGlobalHostPlugins();\n    const hookInstances = [\n        instance.hooks,\n        instance.remoteHandler.hooks,\n        instance.sharedHandler.hooks,\n        instance.snapshotHandler.hooks,\n        instance.loaderHook,\n        instance.bridgeHook\n    ];\n    // Incorporate global plugins\n    if (globalPlugins.length > 0) {\n        globalPlugins.forEach((plugin)=>{\n            if (plugins == null ? void 0 : plugins.find((item)=>item.name !== plugin.name)) {\n                plugins.push(plugin);\n            }\n        });\n    }\n    if (plugins && plugins.length > 0) {\n        plugins.forEach((plugin)=>{\n            hookInstances.forEach((hookInstance)=>{\n                hookInstance.applyPlugin(plugin, instance);\n            });\n        });\n    }\n    return plugins;\n}\n\nconst importCallback = '.then(callbacks[0]).catch(callbacks[1])';\nasync function loadEsmEntry({ entry, remoteEntryExports }) {\n    return new Promise((resolve, reject)=>{\n        try {\n            if (!remoteEntryExports) {\n                if (typeof FEDERATION_ALLOW_NEW_FUNCTION !== 'undefined') {\n                    new Function('callbacks', `import(\"${entry}\")${importCallback}`)([\n                        resolve,\n                        reject\n                    ]);\n                } else {\n                    import(/* webpackIgnore: true */ /* @vite-ignore */ entry).then(resolve).catch(reject);\n                }\n            } else {\n                resolve(remoteEntryExports);\n            }\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\nasync function loadSystemJsEntry({ entry, remoteEntryExports }) {\n    return new Promise((resolve, reject)=>{\n        try {\n            if (!remoteEntryExports) {\n                //@ts-ignore\n                if (false) // removed by dead control flow\n{} else {\n                    new Function('callbacks', `System.import(\"${entry}\")${importCallback}`)([\n                        resolve,\n                        reject\n                    ]);\n                }\n            } else {\n                resolve(remoteEntryExports);\n            }\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\nfunction handleRemoteEntryLoaded(name, globalName, entry) {\n    const { remoteEntryKey, entryExports } = getRemoteEntryExports(name, globalName);\n    assert(entryExports, (0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.RUNTIME_001, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.runtimeDescMap, {\n        remoteName: name,\n        remoteEntryUrl: entry,\n        remoteEntryKey\n    }));\n    return entryExports;\n}\nasync function loadEntryScript({ name, globalName, entry, loaderHook }) {\n    const { entryExports: remoteEntryExports } = getRemoteEntryExports(name, globalName);\n    if (remoteEntryExports) {\n        return remoteEntryExports;\n    }\n    return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScript)(entry, {\n        attrs: {},\n        createScriptHook: (url, attrs)=>{\n            const res = loaderHook.lifecycle.createScript.emit({\n                url,\n                attrs\n            });\n            if (!res) return;\n            if (res instanceof HTMLScriptElement) {\n                return res;\n            }\n            if ('script' in res || 'timeout' in res) {\n                return res;\n            }\n            return;\n        }\n    }).then(()=>{\n        return handleRemoteEntryLoaded(name, globalName, entry);\n    }).catch((e)=>{\n        assert(undefined, (0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.RUNTIME_008, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.runtimeDescMap, {\n            remoteName: name,\n            resourceUrl: entry\n        }));\n        throw e;\n    });\n}\nasync function loadEntryDom({ remoteInfo, remoteEntryExports, loaderHook }) {\n    const { entry, entryGlobalName: globalName, name, type } = remoteInfo;\n    switch(type){\n        case 'esm':\n        case 'module':\n            return loadEsmEntry({\n                entry,\n                remoteEntryExports\n            });\n        case 'system':\n            return loadSystemJsEntry({\n                entry,\n                remoteEntryExports\n            });\n        default:\n            return loadEntryScript({\n                entry,\n                globalName,\n                name,\n                loaderHook\n            });\n    }\n}\nasync function loadEntryNode({ remoteInfo, loaderHook }) {\n    const { entry, entryGlobalName: globalName, name, type } = remoteInfo;\n    const { entryExports: remoteEntryExports } = getRemoteEntryExports(name, globalName);\n    if (remoteEntryExports) {\n        return remoteEntryExports;\n    }\n    return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScriptNode)(entry, {\n        attrs: {\n            name,\n            globalName,\n            type\n        },\n        loaderHook: {\n            createScriptHook: (url, attrs = {})=>{\n                const res = loaderHook.lifecycle.createScript.emit({\n                    url,\n                    attrs\n                });\n                if (!res) return;\n                if ('url' in res) {\n                    return res;\n                }\n                return;\n            }\n        }\n    }).then(()=>{\n        return handleRemoteEntryLoaded(name, globalName, entry);\n    }).catch((e)=>{\n        throw e;\n    });\n}\nfunction getRemoteEntryUniqueKey(remoteInfo) {\n    const { entry, name } = remoteInfo;\n    return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.composeKeyWithSeparator)(name, entry);\n}\nasync function getRemoteEntry({ origin, remoteEntryExports, remoteInfo }) {\n    const uniqueKey = getRemoteEntryUniqueKey(remoteInfo);\n    if (remoteEntryExports) {\n        return remoteEntryExports;\n    }\n    if (!globalLoading[uniqueKey]) {\n        const loadEntryHook = origin.remoteHandler.hooks.lifecycle.loadEntry;\n        const loaderHook = origin.loaderHook;\n        globalLoading[uniqueKey] = loadEntryHook.emit({\n            loaderHook,\n            remoteInfo,\n            remoteEntryExports\n        }).then((res)=>{\n            if (res) {\n                return res;\n            }\n            // Use ENV_TARGET if defined, otherwise fallback to isBrowserEnv, must keep this\n            const isWebEnvironment = typeof ENV_TARGET !== 'undefined' ? ENV_TARGET === 'web' : (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)();\n            return isWebEnvironment ? loadEntryDom({\n                remoteInfo,\n                remoteEntryExports,\n                loaderHook\n            }) : loadEntryNode({\n                remoteInfo,\n                loaderHook\n            });\n        });\n    }\n    return globalLoading[uniqueKey];\n}\nfunction getRemoteInfo(remote) {\n    return (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, remote, {\n        entry: 'entry' in remote ? remote.entry : '',\n        type: remote.type || DEFAULT_REMOTE_TYPE,\n        entryGlobalName: remote.entryGlobalName || remote.name,\n        shareScope: remote.shareScope || DEFAULT_SCOPE\n    });\n}\n\nfunction defaultPreloadArgs(preloadConfig) {\n    return (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n        resourceCategory: 'sync',\n        share: true,\n        depsRemote: true,\n        prefetchInterface: false\n    }, preloadConfig);\n}\nfunction formatPreloadArgs(remotes, preloadArgs) {\n    return preloadArgs.map((args)=>{\n        const remoteInfo = matchRemote(remotes, args.nameOrAlias);\n        assert(remoteInfo, `Unable to preload ${args.nameOrAlias} as it is not included in ${!remoteInfo && (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.safeToString)({\n            remoteInfo,\n            remotes\n        })}`);\n        return {\n            remote: remoteInfo,\n            preloadConfig: defaultPreloadArgs(args)\n        };\n    });\n}\nfunction normalizePreloadExposes(exposes) {\n    if (!exposes) {\n        return [];\n    }\n    return exposes.map((expose)=>{\n        if (expose === '.') {\n            return expose;\n        }\n        if (expose.startsWith('./')) {\n            return expose.replace('./', '');\n        }\n        return expose;\n    });\n}\nfunction preloadAssets(remoteInfo, host, assets, // It is used to distinguish preload from load remote parallel loading\nuseLinkPreload = true) {\n    const { cssAssets, jsAssetsWithoutEntry, entryAssets } = assets;\n    if (host.options.inBrowser) {\n        entryAssets.forEach((asset)=>{\n            const { moduleInfo } = asset;\n            const module = host.moduleCache.get(remoteInfo.name);\n            if (module) {\n                getRemoteEntry({\n                    origin: host,\n                    remoteInfo: moduleInfo,\n                    remoteEntryExports: module.remoteEntryExports\n                });\n            } else {\n                getRemoteEntry({\n                    origin: host,\n                    remoteInfo: moduleInfo,\n                    remoteEntryExports: undefined\n                });\n            }\n        });\n        if (useLinkPreload) {\n            const defaultAttrs = {\n                rel: 'preload',\n                as: 'style'\n            };\n            cssAssets.forEach((cssUrl)=>{\n                const { link: cssEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLink)({\n                    url: cssUrl,\n                    cb: ()=>{\n                    // noop\n                    },\n                    attrs: defaultAttrs,\n                    createLinkHook: (url, attrs)=>{\n                        const res = host.loaderHook.lifecycle.createLink.emit({\n                            url,\n                            attrs\n                        });\n                        if (res instanceof HTMLLinkElement) {\n                            return res;\n                        }\n                        return;\n                    }\n                });\n                needAttach && document.head.appendChild(cssEl);\n            });\n        } else {\n            const defaultAttrs = {\n                rel: 'stylesheet',\n                type: 'text/css'\n            };\n            cssAssets.forEach((cssUrl)=>{\n                const { link: cssEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLink)({\n                    url: cssUrl,\n                    cb: ()=>{\n                    // noop\n                    },\n                    attrs: defaultAttrs,\n                    createLinkHook: (url, attrs)=>{\n                        const res = host.loaderHook.lifecycle.createLink.emit({\n                            url,\n                            attrs\n                        });\n                        if (res instanceof HTMLLinkElement) {\n                            return res;\n                        }\n                        return;\n                    },\n                    needDeleteLink: false\n                });\n                needAttach && document.head.appendChild(cssEl);\n            });\n        }\n        if (useLinkPreload) {\n            const defaultAttrs = {\n                rel: 'preload',\n                as: 'script'\n            };\n            jsAssetsWithoutEntry.forEach((jsUrl)=>{\n                const { link: linkEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLink)({\n                    url: jsUrl,\n                    cb: ()=>{\n                    // noop\n                    },\n                    attrs: defaultAttrs,\n                    createLinkHook: (url, attrs)=>{\n                        const res = host.loaderHook.lifecycle.createLink.emit({\n                            url,\n                            attrs\n                        });\n                        if (res instanceof HTMLLinkElement) {\n                            return res;\n                        }\n                        return;\n                    }\n                });\n                needAttach && document.head.appendChild(linkEl);\n            });\n        } else {\n            const defaultAttrs = {\n                fetchpriority: 'high',\n                type: (remoteInfo == null ? void 0 : remoteInfo.type) === 'module' ? 'module' : 'text/javascript'\n            };\n            jsAssetsWithoutEntry.forEach((jsUrl)=>{\n                const { script: scriptEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createScript)({\n                    url: jsUrl,\n                    cb: ()=>{\n                    // noop\n                    },\n                    attrs: defaultAttrs,\n                    createScriptHook: (url, attrs)=>{\n                        const res = host.loaderHook.lifecycle.createScript.emit({\n                            url,\n                            attrs\n                        });\n                        if (res instanceof HTMLScriptElement) {\n                            return res;\n                        }\n                        return;\n                    },\n                    needDeleteScript: true\n                });\n                needAttach && document.head.appendChild(scriptEl);\n            });\n        }\n    }\n}\n\nconst ShareUtils = {\n    getRegisteredShare,\n    getGlobalShareScope\n};\nconst GlobalUtils = {\n    Global,\n    nativeGlobal,\n    resetFederationGlobalInfo,\n    setGlobalFederationInstance,\n    getGlobalFederationConstructor,\n    setGlobalFederationConstructor,\n    getInfoWithoutType,\n    getGlobalSnapshot,\n    getTargetSnapshotInfoByModuleInfo,\n    getGlobalSnapshotInfoByModuleInfo,\n    setGlobalSnapshotInfoByModuleInfo,\n    addGlobalSnapshot,\n    getRemoteEntryExports,\n    registerGlobalPlugins,\n    getGlobalHostPlugins,\n    getPreloaded,\n    setPreloaded\n};\nvar helpers = {\n    global: GlobalUtils,\n    share: ShareUtils,\n    utils: {\n        matchRemoteWithNameAndExpose,\n        preloadAssets,\n        getRemoteInfo\n    }\n};\n\nlet Module = class Module {\n    async getEntry() {\n        if (this.remoteEntryExports) {\n            return this.remoteEntryExports;\n        }\n        let remoteEntryExports;\n        try {\n            remoteEntryExports = await getRemoteEntry({\n                origin: this.host,\n                remoteInfo: this.remoteInfo,\n                remoteEntryExports: this.remoteEntryExports\n            });\n        } catch (err) {\n            const uniqueKey = getRemoteEntryUniqueKey(this.remoteInfo);\n            remoteEntryExports = await this.host.loaderHook.lifecycle.loadEntryError.emit({\n                getRemoteEntry,\n                origin: this.host,\n                remoteInfo: this.remoteInfo,\n                remoteEntryExports: this.remoteEntryExports,\n                globalLoading,\n                uniqueKey\n            });\n        }\n        assert(remoteEntryExports, `remoteEntryExports is undefined \\n ${(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.safeToString)(this.remoteInfo)}`);\n        this.remoteEntryExports = remoteEntryExports;\n        return this.remoteEntryExports;\n    }\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    async get(id, expose, options, remoteSnapshot) {\n        const { loadFactory = true } = options || {\n            loadFactory: true\n        };\n        // Get remoteEntry.js\n        const remoteEntryExports = await this.getEntry();\n        if (!this.inited) {\n            const localShareScopeMap = this.host.shareScopeMap;\n            const shareScopeKeys = Array.isArray(this.remoteInfo.shareScope) ? this.remoteInfo.shareScope : [\n                this.remoteInfo.shareScope\n            ];\n            if (!shareScopeKeys.length) {\n                shareScopeKeys.push('default');\n            }\n            shareScopeKeys.forEach((shareScopeKey)=>{\n                if (!localShareScopeMap[shareScopeKey]) {\n                    localShareScopeMap[shareScopeKey] = {};\n                }\n            });\n            // TODO: compate legacy init params, should use shareScopeMap if exist\n            const shareScope = localShareScopeMap[shareScopeKeys[0]];\n            const initScope = [];\n            const remoteEntryInitOptions = {\n                version: this.remoteInfo.version || '',\n                shareScopeKeys: Array.isArray(this.remoteInfo.shareScope) ? shareScopeKeys : this.remoteInfo.shareScope || 'default'\n            };\n            // Help to find host instance\n            Object.defineProperty(remoteEntryInitOptions, 'shareScopeMap', {\n                value: localShareScopeMap,\n                // remoteEntryInitOptions will be traversed and assigned during container init, ,so this attribute is not allowed to be traversed\n                enumerable: false\n            });\n            const initContainerOptions = await this.host.hooks.lifecycle.beforeInitContainer.emit({\n                shareScope,\n                // @ts-ignore shareScopeMap will be set by Object.defineProperty\n                remoteEntryInitOptions,\n                initScope,\n                remoteInfo: this.remoteInfo,\n                origin: this.host\n            });\n            if (typeof (remoteEntryExports == null ? void 0 : remoteEntryExports.init) === 'undefined') {\n                error((0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.RUNTIME_002, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.runtimeDescMap, {\n                    hostName: this.host.name,\n                    remoteName: this.remoteInfo.name,\n                    remoteEntryUrl: this.remoteInfo.entry,\n                    remoteEntryKey: this.remoteInfo.entryGlobalName\n                }));\n            }\n            await remoteEntryExports.init(initContainerOptions.shareScope, initContainerOptions.initScope, initContainerOptions.remoteEntryInitOptions);\n            await this.host.hooks.lifecycle.initContainer.emit((0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, initContainerOptions, {\n                id,\n                remoteSnapshot,\n                remoteEntryExports\n            }));\n        }\n        this.lib = remoteEntryExports;\n        this.inited = true;\n        let moduleFactory;\n        moduleFactory = await this.host.loaderHook.lifecycle.getModuleFactory.emit({\n            remoteEntryExports,\n            expose,\n            moduleInfo: this.remoteInfo\n        });\n        // get exposeGetter\n        if (!moduleFactory) {\n            moduleFactory = await remoteEntryExports.get(expose);\n        }\n        assert(moduleFactory, `${getFMId(this.remoteInfo)} remote don't export ${expose}.`);\n        // keep symbol for module name always one format\n        const symbolName = processModuleAlias(this.remoteInfo.name, expose);\n        const wrapModuleFactory = this.wraperFactory(moduleFactory, symbolName);\n        if (!loadFactory) {\n            return wrapModuleFactory;\n        }\n        const exposeContent = await wrapModuleFactory();\n        return exposeContent;\n    }\n    wraperFactory(moduleFactory, id) {\n        function defineModuleId(res, id) {\n            if (res && typeof res === 'object' && Object.isExtensible(res) && !Object.getOwnPropertyDescriptor(res, Symbol.for('mf_module_id'))) {\n                Object.defineProperty(res, Symbol.for('mf_module_id'), {\n                    value: id,\n                    enumerable: false\n                });\n            }\n        }\n        if (moduleFactory instanceof Promise) {\n            return async ()=>{\n                const res = await moduleFactory();\n                // This parameter is used for bridge debugging\n                defineModuleId(res, id);\n                return res;\n            };\n        } else {\n            return ()=>{\n                const res = moduleFactory();\n                // This parameter is used for bridge debugging\n                defineModuleId(res, id);\n                return res;\n            };\n        }\n    }\n    constructor({ remoteInfo, host }){\n        this.inited = false;\n        this.lib = undefined;\n        this.remoteInfo = remoteInfo;\n        this.host = host;\n    }\n};\n\nclass SyncHook {\n    on(fn) {\n        if (typeof fn === 'function') {\n            this.listeners.add(fn);\n        }\n    }\n    once(fn) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        this.on(function wrapper(...args) {\n            self.remove(wrapper);\n            // eslint-disable-next-line prefer-spread\n            return fn.apply(null, args);\n        });\n    }\n    emit(...data) {\n        let result;\n        if (this.listeners.size > 0) {\n            // eslint-disable-next-line prefer-spread\n            this.listeners.forEach((fn)=>{\n                result = fn(...data);\n            });\n        }\n        return result;\n    }\n    remove(fn) {\n        this.listeners.delete(fn);\n    }\n    removeAll() {\n        this.listeners.clear();\n    }\n    constructor(type){\n        this.type = '';\n        this.listeners = new Set();\n        if (type) {\n            this.type = type;\n        }\n    }\n}\n\nclass AsyncHook extends SyncHook {\n    emit(...data) {\n        let result;\n        const ls = Array.from(this.listeners);\n        if (ls.length > 0) {\n            let i = 0;\n            const call = (prev)=>{\n                if (prev === false) {\n                    return false; // Abort process\n                } else if (i < ls.length) {\n                    return Promise.resolve(ls[i++].apply(null, data)).then(call);\n                } else {\n                    return prev;\n                }\n            };\n            result = call();\n        }\n        return Promise.resolve(result);\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction checkReturnData(originalData, returnedData) {\n    if (!isObject(returnedData)) {\n        return false;\n    }\n    if (originalData !== returnedData) {\n        // eslint-disable-next-line no-restricted-syntax\n        for(const key in originalData){\n            if (!(key in returnedData)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nclass SyncWaterfallHook extends SyncHook {\n    emit(data) {\n        if (!isObject(data)) {\n            error(`The data for the \"${this.type}\" hook should be an object.`);\n        }\n        for (const fn of this.listeners){\n            try {\n                const tempData = fn(data);\n                if (checkReturnData(data, tempData)) {\n                    data = tempData;\n                } else {\n                    this.onerror(`A plugin returned an unacceptable value for the \"${this.type}\" type.`);\n                    break;\n                }\n            } catch (e) {\n                warn(e);\n                this.onerror(e);\n            }\n        }\n        return data;\n    }\n    constructor(type){\n        super();\n        this.onerror = error;\n        this.type = type;\n    }\n}\n\nclass AsyncWaterfallHook extends SyncHook {\n    emit(data) {\n        if (!isObject(data)) {\n            error(`The response data for the \"${this.type}\" hook must be an object.`);\n        }\n        const ls = Array.from(this.listeners);\n        if (ls.length > 0) {\n            let i = 0;\n            const processError = (e)=>{\n                warn(e);\n                this.onerror(e);\n                return data;\n            };\n            const call = (prevData)=>{\n                if (checkReturnData(data, prevData)) {\n                    data = prevData;\n                    if (i < ls.length) {\n                        try {\n                            return Promise.resolve(ls[i++](data)).then(call, processError);\n                        } catch (e) {\n                            return processError(e);\n                        }\n                    }\n                } else {\n                    this.onerror(`A plugin returned an incorrect value for the \"${this.type}\" type.`);\n                }\n                return data;\n            };\n            return Promise.resolve(call(data));\n        }\n        return Promise.resolve(data);\n    }\n    constructor(type){\n        super();\n        this.onerror = error;\n        this.type = type;\n    }\n}\n\nclass PluginSystem {\n    applyPlugin(plugin, instance) {\n        assert(isPlainObject(plugin), 'Plugin configuration is invalid.');\n        // The plugin's name is mandatory and must be unique\n        const pluginName = plugin.name;\n        assert(pluginName, 'A name must be provided by the plugin.');\n        if (!this.registerPlugins[pluginName]) {\n            this.registerPlugins[pluginName] = plugin;\n            plugin.apply == null ? void 0 : plugin.apply.call(plugin, instance);\n            Object.keys(this.lifecycle).forEach((key)=>{\n                const pluginLife = plugin[key];\n                if (pluginLife) {\n                    this.lifecycle[key].on(pluginLife);\n                }\n            });\n        }\n    }\n    removePlugin(pluginName) {\n        assert(pluginName, 'A name is required.');\n        const plugin = this.registerPlugins[pluginName];\n        assert(plugin, `The plugin \"${pluginName}\" is not registered.`);\n        Object.keys(plugin).forEach((key)=>{\n            if (key !== 'name') {\n                this.lifecycle[key].remove(plugin[key]);\n            }\n        });\n    }\n    constructor(lifecycle){\n        this.registerPlugins = {};\n        this.lifecycle = lifecycle;\n        this.lifecycleKeys = Object.keys(lifecycle);\n    }\n}\n\nfunction assignRemoteInfo(remoteInfo, remoteSnapshot) {\n    const remoteEntryInfo = getRemoteEntryInfoFromSnapshot(remoteSnapshot);\n    if (!remoteEntryInfo.url) {\n        error(`The attribute remoteEntry of ${remoteInfo.name} must not be undefined.`);\n    }\n    let entryUrl = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(remoteSnapshot, remoteEntryInfo.url);\n    if (!(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)() && !entryUrl.startsWith('http')) {\n        entryUrl = `https:${entryUrl}`;\n    }\n    remoteInfo.type = remoteEntryInfo.type;\n    remoteInfo.entryGlobalName = remoteEntryInfo.globalName;\n    remoteInfo.entry = entryUrl;\n    remoteInfo.version = remoteSnapshot.version;\n    remoteInfo.buildVersion = remoteSnapshot.buildVersion;\n}\nfunction snapshotPlugin() {\n    return {\n        name: 'snapshot-plugin',\n        async afterResolve (args) {\n            const { remote, pkgNameOrAlias, expose, origin, remoteInfo, id } = args;\n            if (!isRemoteInfoWithEntry(remote) || !isPureRemoteEntry(remote)) {\n                const { remoteSnapshot, globalSnapshot } = await origin.snapshotHandler.loadRemoteSnapshotInfo({\n                    moduleInfo: remote,\n                    id\n                });\n                assignRemoteInfo(remoteInfo, remoteSnapshot);\n                // preloading assets\n                const preloadOptions = {\n                    remote,\n                    preloadConfig: {\n                        nameOrAlias: pkgNameOrAlias,\n                        exposes: [\n                            expose\n                        ],\n                        resourceCategory: 'sync',\n                        share: false,\n                        depsRemote: false\n                    }\n                };\n                const assets = await origin.remoteHandler.hooks.lifecycle.generatePreloadAssets.emit({\n                    origin,\n                    preloadOptions,\n                    remoteInfo,\n                    remote,\n                    remoteSnapshot,\n                    globalSnapshot\n                });\n                if (assets) {\n                    preloadAssets(remoteInfo, origin, assets, false);\n                }\n                return (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, args, {\n                    remoteSnapshot\n                });\n            }\n            return args;\n        }\n    };\n}\n\n// name\n// name:version\nfunction splitId(id) {\n    const splitInfo = id.split(':');\n    if (splitInfo.length === 1) {\n        return {\n            name: splitInfo[0],\n            version: undefined\n        };\n    } else if (splitInfo.length === 2) {\n        return {\n            name: splitInfo[0],\n            version: splitInfo[1]\n        };\n    } else {\n        return {\n            name: splitInfo[1],\n            version: splitInfo[2]\n        };\n    }\n}\n// Traverse all nodes in moduleInfo and traverse the entire snapshot\nfunction traverseModuleInfo(globalSnapshot, remoteInfo, traverse, isRoot, memo = {}, remoteSnapshot) {\n    const id = getFMId(remoteInfo);\n    const { value: snapshotValue } = getInfoWithoutType(globalSnapshot, id);\n    const effectiveRemoteSnapshot = remoteSnapshot || snapshotValue;\n    if (effectiveRemoteSnapshot && !(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isManifestProvider)(effectiveRemoteSnapshot)) {\n        traverse(effectiveRemoteSnapshot, remoteInfo, isRoot);\n        if (effectiveRemoteSnapshot.remotesInfo) {\n            const remoteKeys = Object.keys(effectiveRemoteSnapshot.remotesInfo);\n            for (const key of remoteKeys){\n                if (memo[key]) {\n                    continue;\n                }\n                memo[key] = true;\n                const subRemoteInfo = splitId(key);\n                const remoteValue = effectiveRemoteSnapshot.remotesInfo[key];\n                traverseModuleInfo(globalSnapshot, {\n                    name: subRemoteInfo.name,\n                    version: remoteValue.matchedVersion\n                }, traverse, false, memo, undefined);\n            }\n        }\n    }\n}\nconst isExisted = (type, url)=>{\n    return document.querySelector(`${type}[${type === 'link' ? 'href' : 'src'}=\"${url}\"]`);\n};\n// eslint-disable-next-line max-lines-per-function\nfunction generatePreloadAssets(origin, preloadOptions, remote, globalSnapshot, remoteSnapshot) {\n    const cssAssets = [];\n    const jsAssets = [];\n    const entryAssets = [];\n    const loadedSharedJsAssets = new Set();\n    const loadedSharedCssAssets = new Set();\n    const { options } = origin;\n    const { preloadConfig: rootPreloadConfig } = preloadOptions;\n    const { depsRemote } = rootPreloadConfig;\n    const memo = {};\n    traverseModuleInfo(globalSnapshot, remote, (moduleInfoSnapshot, remoteInfo, isRoot)=>{\n        let preloadConfig;\n        if (isRoot) {\n            preloadConfig = rootPreloadConfig;\n        } else {\n            if (Array.isArray(depsRemote)) {\n                // eslint-disable-next-line array-callback-return\n                const findPreloadConfig = depsRemote.find((remoteConfig)=>{\n                    if (remoteConfig.nameOrAlias === remoteInfo.name || remoteConfig.nameOrAlias === remoteInfo.alias) {\n                        return true;\n                    }\n                    return false;\n                });\n                if (!findPreloadConfig) {\n                    return;\n                }\n                preloadConfig = defaultPreloadArgs(findPreloadConfig);\n            } else if (depsRemote === true) {\n                preloadConfig = rootPreloadConfig;\n            } else {\n                return;\n            }\n        }\n        const remoteEntryUrl = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(moduleInfoSnapshot, getRemoteEntryInfoFromSnapshot(moduleInfoSnapshot).url);\n        if (remoteEntryUrl) {\n            entryAssets.push({\n                name: remoteInfo.name,\n                moduleInfo: {\n                    name: remoteInfo.name,\n                    entry: remoteEntryUrl,\n                    type: 'remoteEntryType' in moduleInfoSnapshot ? moduleInfoSnapshot.remoteEntryType : 'global',\n                    entryGlobalName: 'globalName' in moduleInfoSnapshot ? moduleInfoSnapshot.globalName : remoteInfo.name,\n                    shareScope: '',\n                    version: 'version' in moduleInfoSnapshot ? moduleInfoSnapshot.version : undefined\n                },\n                url: remoteEntryUrl\n            });\n        }\n        let moduleAssetsInfo = 'modules' in moduleInfoSnapshot ? moduleInfoSnapshot.modules : [];\n        const normalizedPreloadExposes = normalizePreloadExposes(preloadConfig.exposes);\n        if (normalizedPreloadExposes.length && 'modules' in moduleInfoSnapshot) {\n            var _moduleInfoSnapshot_modules;\n            moduleAssetsInfo = moduleInfoSnapshot == null ? void 0 : (_moduleInfoSnapshot_modules = moduleInfoSnapshot.modules) == null ? void 0 : _moduleInfoSnapshot_modules.reduce((assets, moduleAssetInfo)=>{\n                if ((normalizedPreloadExposes == null ? void 0 : normalizedPreloadExposes.indexOf(moduleAssetInfo.moduleName)) !== -1) {\n                    assets.push(moduleAssetInfo);\n                }\n                return assets;\n            }, []);\n        }\n        function handleAssets(assets) {\n            const assetsRes = assets.map((asset)=>(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(moduleInfoSnapshot, asset));\n            if (preloadConfig.filter) {\n                return assetsRes.filter(preloadConfig.filter);\n            }\n            return assetsRes;\n        }\n        if (moduleAssetsInfo) {\n            const assetsLength = moduleAssetsInfo.length;\n            for(let index = 0; index < assetsLength; index++){\n                const assetsInfo = moduleAssetsInfo[index];\n                const exposeFullPath = `${remoteInfo.name}/${assetsInfo.moduleName}`;\n                origin.remoteHandler.hooks.lifecycle.handlePreloadModule.emit({\n                    id: assetsInfo.moduleName === '.' ? remoteInfo.name : exposeFullPath,\n                    name: remoteInfo.name,\n                    remoteSnapshot: moduleInfoSnapshot,\n                    preloadConfig,\n                    remote: remoteInfo,\n                    origin\n                });\n                const preloaded = getPreloaded(exposeFullPath);\n                if (preloaded) {\n                    continue;\n                }\n                if (preloadConfig.resourceCategory === 'all') {\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.async));\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.async));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));\n                // eslint-disable-next-line no-constant-condition\n                } else if (preloadConfig.resourceCategory = 'sync') {\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));\n                }\n                setPreloaded(exposeFullPath);\n            }\n        }\n    }, true, memo, remoteSnapshot);\n    if (remoteSnapshot.shared && remoteSnapshot.shared.length > 0) {\n        const collectSharedAssets = (shareInfo, snapshotShared)=>{\n            const registeredShared = getRegisteredShare(origin.shareScopeMap, snapshotShared.sharedName, shareInfo, origin.sharedHandler.hooks.lifecycle.resolveShare);\n            // If the global share does not exist, or the lib function does not exist, it means that the shared has not been loaded yet and can be preloaded.\n            if (registeredShared && typeof registeredShared.lib === 'function') {\n                snapshotShared.assets.js.sync.forEach((asset)=>{\n                    loadedSharedJsAssets.add(asset);\n                });\n                snapshotShared.assets.css.sync.forEach((asset)=>{\n                    loadedSharedCssAssets.add(asset);\n                });\n            }\n        };\n        remoteSnapshot.shared.forEach((shared)=>{\n            var _options_shared;\n            const shareInfos = (_options_shared = options.shared) == null ? void 0 : _options_shared[shared.sharedName];\n            if (!shareInfos) {\n                return;\n            }\n            // if no version, preload all shared\n            const sharedOptions = shared.version ? shareInfos.find((s)=>s.version === shared.version) : shareInfos;\n            if (!sharedOptions) {\n                return;\n            }\n            const arrayShareInfo = arrayOptions(sharedOptions);\n            arrayShareInfo.forEach((s)=>{\n                collectSharedAssets(s, shared);\n            });\n        });\n    }\n    const needPreloadJsAssets = jsAssets.filter((asset)=>!loadedSharedJsAssets.has(asset) && !isExisted('script', asset));\n    const needPreloadCssAssets = cssAssets.filter((asset)=>!loadedSharedCssAssets.has(asset) && !isExisted('link', asset));\n    return {\n        cssAssets: needPreloadCssAssets,\n        jsAssetsWithoutEntry: needPreloadJsAssets,\n        entryAssets: entryAssets.filter((entry)=>!isExisted('script', entry.url))\n    };\n}\nconst generatePreloadAssetsPlugin = function() {\n    return {\n        name: 'generate-preload-assets-plugin',\n        async generatePreloadAssets (args) {\n            const { origin, preloadOptions, remoteInfo, remote, globalSnapshot, remoteSnapshot } = args;\n            if (!(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)()) {\n                return {\n                    cssAssets: [],\n                    jsAssetsWithoutEntry: [],\n                    entryAssets: []\n                };\n            }\n            if (isRemoteInfoWithEntry(remote) && isPureRemoteEntry(remote)) {\n                return {\n                    cssAssets: [],\n                    jsAssetsWithoutEntry: [],\n                    entryAssets: [\n                        {\n                            name: remote.name,\n                            url: remote.entry,\n                            moduleInfo: {\n                                name: remoteInfo.name,\n                                entry: remote.entry,\n                                type: remoteInfo.type || 'global',\n                                entryGlobalName: '',\n                                shareScope: ''\n                            }\n                        }\n                    ]\n                };\n            }\n            assignRemoteInfo(remoteInfo, remoteSnapshot);\n            const assets = generatePreloadAssets(origin, preloadOptions, remoteInfo, globalSnapshot, remoteSnapshot);\n            return assets;\n        }\n    };\n};\n\nfunction getGlobalRemoteInfo(moduleInfo, origin) {\n    const hostGlobalSnapshot = getGlobalSnapshotInfoByModuleInfo({\n        name: origin.name,\n        version: origin.options.version\n    });\n    // get remote detail info from global\n    const globalRemoteInfo = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && getInfoWithoutType(hostGlobalSnapshot.remotesInfo, moduleInfo.name).value;\n    if (globalRemoteInfo && globalRemoteInfo.matchedVersion) {\n        return {\n            hostGlobalSnapshot,\n            globalSnapshot: getGlobalSnapshot(),\n            remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({\n                name: moduleInfo.name,\n                version: globalRemoteInfo.matchedVersion\n            })\n        };\n    }\n    return {\n        hostGlobalSnapshot: undefined,\n        globalSnapshot: getGlobalSnapshot(),\n        remoteSnapshot: getGlobalSnapshotInfoByModuleInfo({\n            name: moduleInfo.name,\n            version: 'version' in moduleInfo ? moduleInfo.version : undefined\n        })\n    };\n}\nclass SnapshotHandler {\n    // eslint-disable-next-line max-lines-per-function\n    async loadRemoteSnapshotInfo({ moduleInfo, id, expose }) {\n        const { options } = this.HostInstance;\n        await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({\n            options,\n            moduleInfo\n        });\n        let hostSnapshot = getGlobalSnapshotInfoByModuleInfo({\n            name: this.HostInstance.options.name,\n            version: this.HostInstance.options.version\n        });\n        if (!hostSnapshot) {\n            hostSnapshot = {\n                version: this.HostInstance.options.version || '',\n                remoteEntry: '',\n                remotesInfo: {}\n            };\n            addGlobalSnapshot({\n                [this.HostInstance.options.name]: hostSnapshot\n            });\n        }\n        // In dynamic loadRemote scenarios, incomplete remotesInfo delivery may occur. In such cases, the remotesInfo in the host needs to be completed in the snapshot at runtime.\n        // This ensures the snapshot's integrity and helps the chrome plugin correctly identify all producer modules, ensuring that proxyable producer modules will not be missing.\n        if (hostSnapshot && 'remotesInfo' in hostSnapshot && !getInfoWithoutType(hostSnapshot.remotesInfo, moduleInfo.name).value) {\n            if ('version' in moduleInfo || 'entry' in moduleInfo) {\n                hostSnapshot.remotesInfo = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, hostSnapshot == null ? void 0 : hostSnapshot.remotesInfo, {\n                    [moduleInfo.name]: {\n                        matchedVersion: 'version' in moduleInfo ? moduleInfo.version : moduleInfo.entry\n                    }\n                });\n            }\n        }\n        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);\n        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({\n            options,\n            moduleInfo,\n            hostGlobalSnapshot,\n            remoteSnapshot,\n            globalSnapshot\n        });\n        let mSnapshot;\n        let gSnapshot;\n        // global snapshot includes manifest or module info includes manifest\n        if (globalRemoteSnapshot) {\n            if ((0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isManifestProvider)(globalRemoteSnapshot)) {\n                const remoteEntry = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)() ? globalRemoteSnapshot.remoteEntry : globalRemoteSnapshot.ssrRemoteEntry || globalRemoteSnapshot.remoteEntry || '';\n                const moduleSnapshot = await this.getManifestJson(remoteEntry, moduleInfo, {});\n                // eslint-disable-next-line @typescript-eslint/no-shadow\n                const globalSnapshotRes = setGlobalSnapshotInfoByModuleInfo((0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, moduleInfo, {\n                    // The global remote may be overridden\n                    // Therefore, set the snapshot key to the global address of the actual request\n                    entry: remoteEntry\n                }), moduleSnapshot);\n                mSnapshot = moduleSnapshot;\n                gSnapshot = globalSnapshotRes;\n            } else {\n                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                    options: this.HostInstance.options,\n                    moduleInfo,\n                    remoteSnapshot: globalRemoteSnapshot,\n                    from: 'global'\n                });\n                mSnapshot = remoteSnapshotRes;\n                gSnapshot = globalSnapshotRes;\n            }\n        } else {\n            if (isRemoteInfoWithEntry(moduleInfo)) {\n                // get from manifest.json and merge remote info from remote server\n                const moduleSnapshot = await this.getManifestJson(moduleInfo.entry, moduleInfo, {});\n                // eslint-disable-next-line @typescript-eslint/no-shadow\n                const globalSnapshotRes = setGlobalSnapshotInfoByModuleInfo(moduleInfo, moduleSnapshot);\n                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                    options: this.HostInstance.options,\n                    moduleInfo,\n                    remoteSnapshot: moduleSnapshot,\n                    from: 'global'\n                });\n                mSnapshot = remoteSnapshotRes;\n                gSnapshot = globalSnapshotRes;\n            } else {\n                error((0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.RUNTIME_007, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.runtimeDescMap, {\n                    hostName: moduleInfo.name,\n                    hostVersion: moduleInfo.version,\n                    globalSnapshot: JSON.stringify(globalSnapshotRes)\n                }));\n            }\n        }\n        await this.hooks.lifecycle.afterLoadSnapshot.emit({\n            id,\n            host: this.HostInstance,\n            options,\n            moduleInfo,\n            remoteSnapshot: mSnapshot\n        });\n        return {\n            remoteSnapshot: mSnapshot,\n            globalSnapshot: gSnapshot\n        };\n    }\n    getGlobalRemoteInfo(moduleInfo) {\n        return getGlobalRemoteInfo(moduleInfo, this.HostInstance);\n    }\n    async getManifestJson(manifestUrl, moduleInfo, extraOptions) {\n        const getManifest = async ()=>{\n            let manifestJson = this.manifestCache.get(manifestUrl);\n            if (manifestJson) {\n                return manifestJson;\n            }\n            try {\n                let res = await this.loaderHook.lifecycle.fetch.emit(manifestUrl, {});\n                if (!res || !(res instanceof Response)) {\n                    res = await fetch(manifestUrl, {});\n                }\n                manifestJson = await res.json();\n            } catch (err) {\n                manifestJson = await this.HostInstance.remoteHandler.hooks.lifecycle.errorLoadRemote.emit({\n                    id: manifestUrl,\n                    error: err,\n                    from: 'runtime',\n                    lifecycle: 'afterResolve',\n                    origin: this.HostInstance\n                });\n                if (!manifestJson) {\n                    delete this.manifestLoading[manifestUrl];\n                    error((0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.RUNTIME_003, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.runtimeDescMap, {\n                        manifestUrl,\n                        moduleName: moduleInfo.name,\n                        hostName: this.HostInstance.options.name\n                    }, `${err}`));\n                }\n            }\n            assert(manifestJson.metaData && manifestJson.exposes && manifestJson.shared, `${manifestUrl} is not a federation manifest`);\n            this.manifestCache.set(manifestUrl, manifestJson);\n            return manifestJson;\n        };\n        const asyncLoadProcess = async ()=>{\n            const manifestJson = await getManifest();\n            const remoteSnapshot = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.generateSnapshotFromManifest)(manifestJson, {\n                version: manifestUrl\n            });\n            const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                options: this.HostInstance.options,\n                moduleInfo,\n                manifestJson,\n                remoteSnapshot,\n                manifestUrl,\n                from: 'manifest'\n            });\n            return remoteSnapshotRes;\n        };\n        if (!this.manifestLoading[manifestUrl]) {\n            this.manifestLoading[manifestUrl] = asyncLoadProcess().then((res)=>res);\n        }\n        return this.manifestLoading[manifestUrl];\n    }\n    constructor(HostInstance){\n        this.loadingHostSnapshot = null;\n        this.manifestCache = new Map();\n        this.hooks = new PluginSystem({\n            beforeLoadRemoteSnapshot: new AsyncHook('beforeLoadRemoteSnapshot'),\n            loadSnapshot: new AsyncWaterfallHook('loadGlobalSnapshot'),\n            loadRemoteSnapshot: new AsyncWaterfallHook('loadRemoteSnapshot'),\n            afterLoadSnapshot: new AsyncWaterfallHook('afterLoadSnapshot')\n        });\n        this.manifestLoading = Global.__FEDERATION__.__MANIFEST_LOADING__;\n        this.HostInstance = HostInstance;\n        this.loaderHook = HostInstance.loaderHook;\n    }\n}\n\nclass SharedHandler {\n    // register shared in shareScopeMap\n    registerShared(globalOptions, userOptions) {\n        const { shareInfos, shared } = formatShareConfigs(globalOptions, userOptions);\n        const sharedKeys = Object.keys(shareInfos);\n        sharedKeys.forEach((sharedKey)=>{\n            const sharedVals = shareInfos[sharedKey];\n            sharedVals.forEach((sharedVal)=>{\n                const registeredShared = getRegisteredShare(this.shareScopeMap, sharedKey, sharedVal, this.hooks.lifecycle.resolveShare);\n                if (!registeredShared && sharedVal && sharedVal.lib) {\n                    this.setShared({\n                        pkgName: sharedKey,\n                        lib: sharedVal.lib,\n                        get: sharedVal.get,\n                        loaded: true,\n                        shared: sharedVal,\n                        from: userOptions.name\n                    });\n                }\n            });\n        });\n        return {\n            shareInfos,\n            shared\n        };\n    }\n    async loadShare(pkgName, extraOptions) {\n        const { host } = this;\n        // This function performs the following steps:\n        // 1. Checks if the currently loaded share already exists, if not, it throws an error\n        // 2. Searches globally for a matching share, if found, it uses it directly\n        // 3. If not found, it retrieves it from the current share and stores the obtained share globally.\n        const shareOptions = getTargetSharedOptions({\n            pkgName,\n            extraOptions,\n            shareInfos: host.options.shared\n        });\n        if (shareOptions == null ? void 0 : shareOptions.scope) {\n            await Promise.all(shareOptions.scope.map(async (shareScope)=>{\n                await Promise.all(this.initializeSharing(shareScope, {\n                    strategy: shareOptions.strategy\n                }));\n                return;\n            }));\n        }\n        const loadShareRes = await this.hooks.lifecycle.beforeLoadShare.emit({\n            pkgName,\n            shareInfo: shareOptions,\n            shared: host.options.shared,\n            origin: host\n        });\n        const { shareInfo: shareOptionsRes } = loadShareRes;\n        // Assert that shareInfoRes exists, if not, throw an error\n        assert(shareOptionsRes, `Cannot find ${pkgName} Share in the ${host.options.name}. Please ensure that the ${pkgName} Share parameters have been injected`);\n        // Retrieve from cache\n        const registeredShared = getRegisteredShare(this.shareScopeMap, pkgName, shareOptionsRes, this.hooks.lifecycle.resolveShare);\n        const addUseIn = (shared)=>{\n            if (!shared.useIn) {\n                shared.useIn = [];\n            }\n            addUniqueItem(shared.useIn, host.options.name);\n        };\n        if (registeredShared && registeredShared.lib) {\n            addUseIn(registeredShared);\n            return registeredShared.lib;\n        } else if (registeredShared && registeredShared.loading && !registeredShared.loaded) {\n            const factory = await registeredShared.loading;\n            registeredShared.loaded = true;\n            if (!registeredShared.lib) {\n                registeredShared.lib = factory;\n            }\n            addUseIn(registeredShared);\n            return factory;\n        } else if (registeredShared) {\n            const asyncLoadProcess = async ()=>{\n                const factory = await registeredShared.get();\n                addUseIn(registeredShared);\n                registeredShared.loaded = true;\n                registeredShared.lib = factory;\n                return factory;\n            };\n            const loading = asyncLoadProcess();\n            this.setShared({\n                pkgName,\n                loaded: false,\n                shared: registeredShared,\n                from: host.options.name,\n                lib: null,\n                loading\n            });\n            return loading;\n        } else {\n            if (extraOptions == null ? void 0 : extraOptions.customShareInfo) {\n                return false;\n            }\n            const asyncLoadProcess = async ()=>{\n                const factory = await shareOptionsRes.get();\n                shareOptionsRes.lib = factory;\n                shareOptionsRes.loaded = true;\n                addUseIn(shareOptionsRes);\n                const gShared = getRegisteredShare(this.shareScopeMap, pkgName, shareOptionsRes, this.hooks.lifecycle.resolveShare);\n                if (gShared) {\n                    gShared.lib = factory;\n                    gShared.loaded = true;\n                    gShared.from = shareOptionsRes.from;\n                }\n                return factory;\n            };\n            const loading = asyncLoadProcess();\n            this.setShared({\n                pkgName,\n                loaded: false,\n                shared: shareOptionsRes,\n                from: host.options.name,\n                lib: null,\n                loading\n            });\n            return loading;\n        }\n    }\n    /**\n     * This function initializes the sharing sequence (executed only once per share scope).\n     * It accepts one argument, the name of the share scope.\n     * If the share scope does not exist, it creates one.\n     */ // eslint-disable-next-line @typescript-eslint/member-ordering\n    initializeSharing(shareScopeName = DEFAULT_SCOPE, extraOptions) {\n        const { host } = this;\n        const from = extraOptions == null ? void 0 : extraOptions.from;\n        const strategy = extraOptions == null ? void 0 : extraOptions.strategy;\n        let initScope = extraOptions == null ? void 0 : extraOptions.initScope;\n        const promises = [];\n        if (from !== 'build') {\n            const { initTokens } = this;\n            if (!initScope) initScope = [];\n            let initToken = initTokens[shareScopeName];\n            if (!initToken) initToken = initTokens[shareScopeName] = {\n                from: this.host.name\n            };\n            if (initScope.indexOf(initToken) >= 0) return promises;\n            initScope.push(initToken);\n        }\n        const shareScope = this.shareScopeMap;\n        const hostName = host.options.name;\n        // Creates a new share scope if necessary\n        if (!shareScope[shareScopeName]) {\n            shareScope[shareScopeName] = {};\n        }\n        // Executes all initialization snippets from all accessible modules\n        const scope = shareScope[shareScopeName];\n        const register = (name, shared)=>{\n            var _activeVersion_shareConfig;\n            const { version, eager } = shared;\n            scope[name] = scope[name] || {};\n            const versions = scope[name];\n            const activeVersion = versions[version];\n            const activeVersionEager = Boolean(activeVersion && (activeVersion.eager || ((_activeVersion_shareConfig = activeVersion.shareConfig) == null ? void 0 : _activeVersion_shareConfig.eager)));\n            if (!activeVersion || activeVersion.strategy !== 'loaded-first' && !activeVersion.loaded && (Boolean(!eager) !== !activeVersionEager ? eager : hostName > activeVersion.from)) {\n                versions[version] = shared;\n            }\n        };\n        const initFn = (mod)=>mod && mod.init && mod.init(shareScope[shareScopeName], initScope);\n        const initRemoteModule = async (key)=>{\n            const { module } = await host.remoteHandler.getRemoteModuleAndOptions({\n                id: key\n            });\n            if (module.getEntry) {\n                let remoteEntryExports;\n                try {\n                    remoteEntryExports = await module.getEntry();\n                } catch (error) {\n                    remoteEntryExports = await host.remoteHandler.hooks.lifecycle.errorLoadRemote.emit({\n                        id: key,\n                        error,\n                        from: 'runtime',\n                        lifecycle: 'beforeLoadShare',\n                        origin: host\n                    });\n                }\n                if (!module.inited) {\n                    await initFn(remoteEntryExports);\n                    module.inited = true;\n                }\n            }\n        };\n        Object.keys(host.options.shared).forEach((shareName)=>{\n            const sharedArr = host.options.shared[shareName];\n            sharedArr.forEach((shared)=>{\n                if (shared.scope.includes(shareScopeName)) {\n                    register(shareName, shared);\n                }\n            });\n        });\n        // TODO: strategy==='version-first' need to be removed in the future\n        if (host.options.shareStrategy === 'version-first' || strategy === 'version-first') {\n            host.options.remotes.forEach((remote)=>{\n                if (remote.shareScope === shareScopeName) {\n                    promises.push(initRemoteModule(remote.name));\n                }\n            });\n        }\n        return promises;\n    }\n    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.\n    // 1. If the loaded shared already exists globally, then it will be reused\n    // 2. If lib exists in local shared, it will be used directly\n    // 3. If the local get returns something other than Promise, then it will be used directly\n    loadShareSync(pkgName, extraOptions) {\n        const { host } = this;\n        const shareOptions = getTargetSharedOptions({\n            pkgName,\n            extraOptions,\n            shareInfos: host.options.shared\n        });\n        if (shareOptions == null ? void 0 : shareOptions.scope) {\n            shareOptions.scope.forEach((shareScope)=>{\n                this.initializeSharing(shareScope, {\n                    strategy: shareOptions.strategy\n                });\n            });\n        }\n        const registeredShared = getRegisteredShare(this.shareScopeMap, pkgName, shareOptions, this.hooks.lifecycle.resolveShare);\n        const addUseIn = (shared)=>{\n            if (!shared.useIn) {\n                shared.useIn = [];\n            }\n            addUniqueItem(shared.useIn, host.options.name);\n        };\n        if (registeredShared) {\n            if (typeof registeredShared.lib === 'function') {\n                addUseIn(registeredShared);\n                if (!registeredShared.loaded) {\n                    registeredShared.loaded = true;\n                    if (registeredShared.from === host.options.name) {\n                        shareOptions.loaded = true;\n                    }\n                }\n                return registeredShared.lib;\n            }\n            if (typeof registeredShared.get === 'function') {\n                const module = registeredShared.get();\n                if (!(module instanceof Promise)) {\n                    addUseIn(registeredShared);\n                    this.setShared({\n                        pkgName,\n                        loaded: true,\n                        from: host.options.name,\n                        lib: module,\n                        shared: registeredShared\n                    });\n                    return module;\n                }\n            }\n        }\n        if (shareOptions.lib) {\n            if (!shareOptions.loaded) {\n                shareOptions.loaded = true;\n            }\n            return shareOptions.lib;\n        }\n        if (shareOptions.get) {\n            const module = shareOptions.get();\n            if (module instanceof Promise) {\n                const errorCode = (extraOptions == null ? void 0 : extraOptions.from) === 'build' ? _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.RUNTIME_005 : _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.RUNTIME_006;\n                throw new Error((0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.getShortErrorMsg)(errorCode, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.runtimeDescMap, {\n                    hostName: host.options.name,\n                    sharedPkgName: pkgName\n                }));\n            }\n            shareOptions.lib = module;\n            this.setShared({\n                pkgName,\n                loaded: true,\n                from: host.options.name,\n                lib: shareOptions.lib,\n                shared: shareOptions\n            });\n            return shareOptions.lib;\n        }\n        throw new Error((0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.RUNTIME_006, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.runtimeDescMap, {\n            hostName: host.options.name,\n            sharedPkgName: pkgName\n        }));\n    }\n    initShareScopeMap(scopeName, shareScope, extraOptions = {}) {\n        const { host } = this;\n        this.shareScopeMap[scopeName] = shareScope;\n        this.hooks.lifecycle.initContainerShareScopeMap.emit({\n            shareScope,\n            options: host.options,\n            origin: host,\n            scopeName,\n            hostShareScopeMap: extraOptions.hostShareScopeMap\n        });\n    }\n    setShared({ pkgName, shared, from, lib, loading, loaded, get }) {\n        const { version, scope = 'default' } = shared, shareInfo = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(shared, [\n            \"version\",\n            \"scope\"\n        ]);\n        const scopes = Array.isArray(scope) ? scope : [\n            scope\n        ];\n        scopes.forEach((sc)=>{\n            if (!this.shareScopeMap[sc]) {\n                this.shareScopeMap[sc] = {};\n            }\n            if (!this.shareScopeMap[sc][pkgName]) {\n                this.shareScopeMap[sc][pkgName] = {};\n            }\n            if (!this.shareScopeMap[sc][pkgName][version]) {\n                this.shareScopeMap[sc][pkgName][version] = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n                    version,\n                    scope: [\n                        'default'\n                    ]\n                }, shareInfo, {\n                    lib,\n                    loaded,\n                    loading\n                });\n                if (get) {\n                    this.shareScopeMap[sc][pkgName][version].get = get;\n                }\n                return;\n            }\n            const registeredShared = this.shareScopeMap[sc][pkgName][version];\n            if (loading && !registeredShared.loading) {\n                registeredShared.loading = loading;\n            }\n            if (loaded && !registeredShared.loaded) {\n                registeredShared.loaded = loaded;\n            }\n            if (from && registeredShared.from !== from) {\n                registeredShared.from = from;\n            }\n        });\n    }\n    _setGlobalShareScopeMap(hostOptions) {\n        const globalShareScopeMap = getGlobalShareScope();\n        const identifier = hostOptions.id || hostOptions.name;\n        if (identifier && !globalShareScopeMap[identifier]) {\n            globalShareScopeMap[identifier] = this.shareScopeMap;\n        }\n    }\n    constructor(host){\n        this.hooks = new PluginSystem({\n            afterResolve: new AsyncWaterfallHook('afterResolve'),\n            beforeLoadShare: new AsyncWaterfallHook('beforeLoadShare'),\n            // not used yet\n            loadShare: new AsyncHook(),\n            resolveShare: new SyncWaterfallHook('resolveShare'),\n            // maybe will change, temporarily for internal use only\n            initContainerShareScopeMap: new SyncWaterfallHook('initContainerShareScopeMap')\n        });\n        this.host = host;\n        this.shareScopeMap = {};\n        this.initTokens = {};\n        this._setGlobalShareScopeMap(host.options);\n    }\n}\n\nclass RemoteHandler {\n    formatAndRegisterRemote(globalOptions, userOptions) {\n        const userRemotes = userOptions.remotes || [];\n        return userRemotes.reduce((res, remote)=>{\n            this.registerRemote(remote, res, {\n                force: false\n            });\n            return res;\n        }, globalOptions.remotes);\n    }\n    setIdToRemoteMap(id, remoteMatchInfo) {\n        const { remote, expose } = remoteMatchInfo;\n        const { name, alias } = remote;\n        this.idToRemoteMap[id] = {\n            name: remote.name,\n            expose\n        };\n        if (alias && id.startsWith(name)) {\n            const idWithAlias = id.replace(name, alias);\n            this.idToRemoteMap[idWithAlias] = {\n                name: remote.name,\n                expose\n            };\n            return;\n        }\n        if (alias && id.startsWith(alias)) {\n            const idWithName = id.replace(alias, name);\n            this.idToRemoteMap[idWithName] = {\n                name: remote.name,\n                expose\n            };\n        }\n    }\n    // eslint-disable-next-line max-lines-per-function\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async loadRemote(id, options) {\n        const { host } = this;\n        try {\n            const { loadFactory = true } = options || {\n                loadFactory: true\n            };\n            // 1. Validate the parameters of the retrieved module. There are two module request methods: pkgName + expose and alias + expose.\n            // 2. Request the snapshot information of the current host and globally store the obtained snapshot information. The retrieved module information is partially offline and partially online. The online module information will retrieve the modules used online.\n            // 3. Retrieve the detailed information of the current module from global (remoteEntry address, expose resource address)\n            // 4. After retrieving remoteEntry, call the init of the module, and then retrieve the exported content of the module through get\n            // id: pkgName(@federation/app1) + expose(button) = @federation/app1/button\n            // id: alias(app1) + expose(button) = app1/button\n            // id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort\n            const { module, moduleOptions, remoteMatchInfo } = await this.getRemoteModuleAndOptions({\n                id\n            });\n            const { pkgNameOrAlias, remote, expose, id: idRes, remoteSnapshot } = remoteMatchInfo;\n            const moduleOrFactory = await module.get(idRes, expose, options, remoteSnapshot);\n            const moduleWrapper = await this.hooks.lifecycle.onLoad.emit({\n                id: idRes,\n                pkgNameOrAlias,\n                expose,\n                exposeModule: loadFactory ? moduleOrFactory : undefined,\n                exposeModuleFactory: loadFactory ? undefined : moduleOrFactory,\n                remote,\n                options: moduleOptions,\n                moduleInstance: module,\n                origin: host\n            });\n            this.setIdToRemoteMap(id, remoteMatchInfo);\n            if (typeof moduleWrapper === 'function') {\n                return moduleWrapper;\n            }\n            return moduleOrFactory;\n        } catch (error) {\n            const { from = 'runtime' } = options || {\n                from: 'runtime'\n            };\n            const failOver = await this.hooks.lifecycle.errorLoadRemote.emit({\n                id,\n                error,\n                from,\n                lifecycle: 'onLoad',\n                origin: host\n            });\n            if (!failOver) {\n                throw error;\n            }\n            return failOver;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async preloadRemote(preloadOptions) {\n        const { host } = this;\n        await this.hooks.lifecycle.beforePreloadRemote.emit({\n            preloadOps: preloadOptions,\n            options: host.options,\n            origin: host\n        });\n        const preloadOps = formatPreloadArgs(host.options.remotes, preloadOptions);\n        await Promise.all(preloadOps.map(async (ops)=>{\n            const { remote } = ops;\n            const remoteInfo = getRemoteInfo(remote);\n            const { globalSnapshot, remoteSnapshot } = await host.snapshotHandler.loadRemoteSnapshotInfo({\n                moduleInfo: remote\n            });\n            const assets = await this.hooks.lifecycle.generatePreloadAssets.emit({\n                origin: host,\n                preloadOptions: ops,\n                remote,\n                remoteInfo,\n                globalSnapshot,\n                remoteSnapshot\n            });\n            if (!assets) {\n                return;\n            }\n            preloadAssets(remoteInfo, host, assets);\n        }));\n    }\n    registerRemotes(remotes, options) {\n        const { host } = this;\n        remotes.forEach((remote)=>{\n            this.registerRemote(remote, host.options.remotes, {\n                force: options == null ? void 0 : options.force\n            });\n        });\n    }\n    async getRemoteModuleAndOptions(options) {\n        const { host } = this;\n        const { id } = options;\n        let loadRemoteArgs;\n        try {\n            loadRemoteArgs = await this.hooks.lifecycle.beforeRequest.emit({\n                id,\n                options: host.options,\n                origin: host\n            });\n        } catch (error) {\n            loadRemoteArgs = await this.hooks.lifecycle.errorLoadRemote.emit({\n                id,\n                options: host.options,\n                origin: host,\n                from: 'runtime',\n                error,\n                lifecycle: 'beforeRequest'\n            });\n            if (!loadRemoteArgs) {\n                throw error;\n            }\n        }\n        const { id: idRes } = loadRemoteArgs;\n        const remoteSplitInfo = matchRemoteWithNameAndExpose(host.options.remotes, idRes);\n        assert(remoteSplitInfo, (0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.RUNTIME_004, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_2__.runtimeDescMap, {\n            hostName: host.options.name,\n            requestId: idRes\n        }));\n        const { remote: rawRemote } = remoteSplitInfo;\n        const remoteInfo = getRemoteInfo(rawRemote);\n        const matchInfo = await host.sharedHandler.hooks.lifecycle.afterResolve.emit((0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n            id: idRes\n        }, remoteSplitInfo, {\n            options: host.options,\n            origin: host,\n            remoteInfo\n        }));\n        const { remote, expose } = matchInfo;\n        assert(remote && expose, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${idRes}.`);\n        let module = host.moduleCache.get(remote.name);\n        const moduleOptions = {\n            host: host,\n            remoteInfo\n        };\n        if (!module) {\n            module = new Module(moduleOptions);\n            host.moduleCache.set(remote.name, module);\n        }\n        return {\n            module,\n            moduleOptions,\n            remoteMatchInfo: matchInfo\n        };\n    }\n    registerRemote(remote, targetRemotes, options) {\n        const { host } = this;\n        const normalizeRemote = ()=>{\n            if (remote.alias) {\n                // Validate if alias equals the prefix of remote.name and remote.alias, if so, throw an error\n                // As multi-level path references cannot guarantee unique names, alias being a prefix of remote.name is not supported\n                const findEqual = targetRemotes.find((item)=>{\n                    var _item_alias;\n                    return remote.alias && (item.name.startsWith(remote.alias) || ((_item_alias = item.alias) == null ? void 0 : _item_alias.startsWith(remote.alias)));\n                });\n                assert(!findEqual, `The alias ${remote.alias} of remote ${remote.name} is not allowed to be the prefix of ${findEqual && findEqual.name} name or alias`);\n            }\n            // Set the remote entry to a complete path\n            if ('entry' in remote) {\n                if ((0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)() && !remote.entry.startsWith('http')) {\n                    remote.entry = new URL(remote.entry, window.location.origin).href;\n                }\n            }\n            if (!remote.shareScope) {\n                remote.shareScope = DEFAULT_SCOPE;\n            }\n            if (!remote.type) {\n                remote.type = DEFAULT_REMOTE_TYPE;\n            }\n        };\n        this.hooks.lifecycle.beforeRegisterRemote.emit({\n            remote,\n            origin: host\n        });\n        const registeredRemote = targetRemotes.find((item)=>item.name === remote.name);\n        if (!registeredRemote) {\n            normalizeRemote();\n            targetRemotes.push(remote);\n            this.hooks.lifecycle.registerRemote.emit({\n                remote,\n                origin: host\n            });\n        } else {\n            const messages = [\n                `The remote \"${remote.name}\" is already registered.`,\n                'Please note that overriding it may cause unexpected errors.'\n            ];\n            if (options == null ? void 0 : options.force) {\n                // remove registered remote\n                this.removeRemote(registeredRemote);\n                normalizeRemote();\n                targetRemotes.push(remote);\n                this.hooks.lifecycle.registerRemote.emit({\n                    remote,\n                    origin: host\n                });\n                (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.warn)(messages.join(' '));\n            }\n        }\n    }\n    removeRemote(remote) {\n        try {\n            const { host } = this;\n            const { name } = remote;\n            const remoteIndex = host.options.remotes.findIndex((item)=>item.name === name);\n            if (remoteIndex !== -1) {\n                host.options.remotes.splice(remoteIndex, 1);\n            }\n            const loadedModule = host.moduleCache.get(remote.name);\n            if (loadedModule) {\n                const remoteInfo = loadedModule.remoteInfo;\n                const key = remoteInfo.entryGlobalName;\n                if (CurrentGlobal[key]) {\n                    var _Object_getOwnPropertyDescriptor;\n                    if ((_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(CurrentGlobal, key)) == null ? void 0 : _Object_getOwnPropertyDescriptor.configurable) {\n                        delete CurrentGlobal[key];\n                    } else {\n                        // @ts-ignore\n                        CurrentGlobal[key] = undefined;\n                    }\n                }\n                const remoteEntryUniqueKey = getRemoteEntryUniqueKey(loadedModule.remoteInfo);\n                if (globalLoading[remoteEntryUniqueKey]) {\n                    delete globalLoading[remoteEntryUniqueKey];\n                }\n                host.snapshotHandler.manifestCache.delete(remoteInfo.entry);\n                // delete unloaded shared and instance\n                let remoteInsId = remoteInfo.buildVersion ? (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.composeKeyWithSeparator)(remoteInfo.name, remoteInfo.buildVersion) : remoteInfo.name;\n                const remoteInsIndex = CurrentGlobal.__FEDERATION__.__INSTANCES__.findIndex((ins)=>{\n                    if (remoteInfo.buildVersion) {\n                        return ins.options.id === remoteInsId;\n                    } else {\n                        return ins.name === remoteInsId;\n                    }\n                });\n                if (remoteInsIndex !== -1) {\n                    const remoteIns = CurrentGlobal.__FEDERATION__.__INSTANCES__[remoteInsIndex];\n                    remoteInsId = remoteIns.options.id || remoteInsId;\n                    const globalShareScopeMap = getGlobalShareScope();\n                    let isAllSharedNotUsed = true;\n                    const needDeleteKeys = [];\n                    Object.keys(globalShareScopeMap).forEach((instId)=>{\n                        const shareScopeMap = globalShareScopeMap[instId];\n                        shareScopeMap && Object.keys(shareScopeMap).forEach((shareScope)=>{\n                            const shareScopeVal = shareScopeMap[shareScope];\n                            shareScopeVal && Object.keys(shareScopeVal).forEach((shareName)=>{\n                                const sharedPkgs = shareScopeVal[shareName];\n                                sharedPkgs && Object.keys(sharedPkgs).forEach((shareVersion)=>{\n                                    const shared = sharedPkgs[shareVersion];\n                                    if (shared && typeof shared === 'object' && shared.from === remoteInfo.name) {\n                                        if (shared.loaded || shared.loading) {\n                                            shared.useIn = shared.useIn.filter((usedHostName)=>usedHostName !== remoteInfo.name);\n                                            if (shared.useIn.length) {\n                                                isAllSharedNotUsed = false;\n                                            } else {\n                                                needDeleteKeys.push([\n                                                    instId,\n                                                    shareScope,\n                                                    shareName,\n                                                    shareVersion\n                                                ]);\n                                            }\n                                        } else {\n                                            needDeleteKeys.push([\n                                                instId,\n                                                shareScope,\n                                                shareName,\n                                                shareVersion\n                                            ]);\n                                        }\n                                    }\n                                });\n                            });\n                        });\n                    });\n                    if (isAllSharedNotUsed) {\n                        remoteIns.shareScopeMap = {};\n                        delete globalShareScopeMap[remoteInsId];\n                    }\n                    needDeleteKeys.forEach(([insId, shareScope, shareName, shareVersion])=>{\n                        var _globalShareScopeMap_insId_shareScope_shareName, _globalShareScopeMap_insId_shareScope, _globalShareScopeMap_insId;\n                        (_globalShareScopeMap_insId = globalShareScopeMap[insId]) == null ? true : (_globalShareScopeMap_insId_shareScope = _globalShareScopeMap_insId[shareScope]) == null ? true : (_globalShareScopeMap_insId_shareScope_shareName = _globalShareScopeMap_insId_shareScope[shareName]) == null ? true : delete _globalShareScopeMap_insId_shareScope_shareName[shareVersion];\n                    });\n                    CurrentGlobal.__FEDERATION__.__INSTANCES__.splice(remoteInsIndex, 1);\n                }\n                const { hostGlobalSnapshot } = getGlobalRemoteInfo(remote, host);\n                if (hostGlobalSnapshot) {\n                    const remoteKey = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && getInfoWithoutType(hostGlobalSnapshot.remotesInfo, remote.name).key;\n                    if (remoteKey) {\n                        delete hostGlobalSnapshot.remotesInfo[remoteKey];\n                        if (//eslint-disable-next-line no-extra-boolean-cast\n                        Boolean(Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey])) {\n                            delete Global.__FEDERATION__.__MANIFEST_LOADING__[remoteKey];\n                        }\n                    }\n                }\n                host.moduleCache.delete(remote.name);\n            }\n        } catch (err) {\n            logger.log('removeRemote fail: ', err);\n        }\n    }\n    constructor(host){\n        this.hooks = new PluginSystem({\n            beforeRegisterRemote: new SyncWaterfallHook('beforeRegisterRemote'),\n            registerRemote: new SyncWaterfallHook('registerRemote'),\n            beforeRequest: new AsyncWaterfallHook('beforeRequest'),\n            onLoad: new AsyncHook('onLoad'),\n            handlePreloadModule: new SyncHook('handlePreloadModule'),\n            errorLoadRemote: new AsyncHook('errorLoadRemote'),\n            beforePreloadRemote: new AsyncHook('beforePreloadRemote'),\n            generatePreloadAssets: new AsyncHook('generatePreloadAssets'),\n            // not used yet\n            afterPreloadRemote: new AsyncHook(),\n            loadEntry: new AsyncHook()\n        });\n        this.host = host;\n        this.idToRemoteMap = {};\n    }\n}\n\nconst USE_SNAPSHOT =  true ? !false : 0; // Default to true (use snapshot) when not explicitly defined\nclass ModuleFederation {\n    initOptions(userOptions) {\n        this.registerPlugins(userOptions.plugins);\n        const options = this.formatOptions(this.options, userOptions);\n        this.options = options;\n        return options;\n    }\n    async loadShare(pkgName, extraOptions) {\n        return this.sharedHandler.loadShare(pkgName, extraOptions);\n    }\n    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.\n    // 1. If the loaded shared already exists globally, then it will be reused\n    // 2. If lib exists in local shared, it will be used directly\n    // 3. If the local get returns something other than Promise, then it will be used directly\n    loadShareSync(pkgName, extraOptions) {\n        return this.sharedHandler.loadShareSync(pkgName, extraOptions);\n    }\n    initializeSharing(shareScopeName = DEFAULT_SCOPE, extraOptions) {\n        return this.sharedHandler.initializeSharing(shareScopeName, extraOptions);\n    }\n    initRawContainer(name, url, container) {\n        const remoteInfo = getRemoteInfo({\n            name,\n            entry: url\n        });\n        const module = new Module({\n            host: this,\n            remoteInfo\n        });\n        module.remoteEntryExports = container;\n        this.moduleCache.set(name, module);\n        return module;\n    }\n    // eslint-disable-next-line max-lines-per-function\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async loadRemote(id, options) {\n        return this.remoteHandler.loadRemote(id, options);\n    }\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async preloadRemote(preloadOptions) {\n        return this.remoteHandler.preloadRemote(preloadOptions);\n    }\n    initShareScopeMap(scopeName, shareScope, extraOptions = {}) {\n        this.sharedHandler.initShareScopeMap(scopeName, shareScope, extraOptions);\n    }\n    formatOptions(globalOptions, userOptions) {\n        const { shared } = formatShareConfigs(globalOptions, userOptions);\n        const { userOptions: userOptionsRes, options: globalOptionsRes } = this.hooks.lifecycle.beforeInit.emit({\n            origin: this,\n            userOptions,\n            options: globalOptions,\n            shareInfo: shared\n        });\n        const remotes = this.remoteHandler.formatAndRegisterRemote(globalOptionsRes, userOptionsRes);\n        const { shared: handledShared } = this.sharedHandler.registerShared(globalOptionsRes, userOptionsRes);\n        const plugins = [\n            ...globalOptionsRes.plugins\n        ];\n        if (userOptionsRes.plugins) {\n            userOptionsRes.plugins.forEach((plugin)=>{\n                if (!plugins.includes(plugin)) {\n                    plugins.push(plugin);\n                }\n            });\n        }\n        const optionsRes = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, globalOptions, userOptions, {\n            plugins,\n            remotes,\n            shared: handledShared\n        });\n        this.hooks.lifecycle.init.emit({\n            origin: this,\n            options: optionsRes\n        });\n        return optionsRes;\n    }\n    registerPlugins(plugins) {\n        const pluginRes = registerPlugins(plugins, this);\n        // Merge plugin\n        this.options.plugins = this.options.plugins.reduce((res, plugin)=>{\n            if (!plugin) return res;\n            if (res && !res.find((item)=>item.name === plugin.name)) {\n                res.push(plugin);\n            }\n            return res;\n        }, pluginRes || []);\n    }\n    registerRemotes(remotes, options) {\n        return this.remoteHandler.registerRemotes(remotes, options);\n    }\n    registerShared(shared) {\n        this.sharedHandler.registerShared(this.options, (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, this.options, {\n            shared\n        }));\n    }\n    constructor(userOptions){\n        this.hooks = new PluginSystem({\n            beforeInit: new SyncWaterfallHook('beforeInit'),\n            init: new SyncHook(),\n            // maybe will change, temporarily for internal use only\n            beforeInitContainer: new AsyncWaterfallHook('beforeInitContainer'),\n            // maybe will change, temporarily for internal use only\n            initContainer: new AsyncWaterfallHook('initContainer')\n        });\n        this.version = \"0.18.3\";\n        this.moduleCache = new Map();\n        this.loaderHook = new PluginSystem({\n            // FIXME: may not be suitable , not open to the public yet\n            getModuleInfo: new SyncHook(),\n            createScript: new SyncHook(),\n            createLink: new SyncHook(),\n            fetch: new AsyncHook(),\n            loadEntryError: new AsyncHook(),\n            getModuleFactory: new AsyncHook()\n        });\n        this.bridgeHook = new PluginSystem({\n            beforeBridgeRender: new SyncHook(),\n            afterBridgeRender: new SyncHook(),\n            beforeBridgeDestroy: new SyncHook(),\n            afterBridgeDestroy: new SyncHook()\n        });\n        const plugins = USE_SNAPSHOT ? [\n            snapshotPlugin(),\n            generatePreloadAssetsPlugin()\n        ] : [];\n        // TODO: Validate the details of the options\n        // Initialize options with default values\n        const defaultOptions = {\n            id: getBuilderId(),\n            name: userOptions.name,\n            plugins,\n            remotes: [],\n            shared: {},\n            inBrowser: (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)()\n        };\n        this.name = userOptions.name;\n        this.options = defaultOptions;\n        this.snapshotHandler = new SnapshotHandler(this);\n        this.sharedHandler = new SharedHandler(this);\n        this.remoteHandler = new RemoteHandler(this);\n        this.shareScopeMap = this.sharedHandler.shareScopeMap;\n        this.registerPlugins([\n            ...defaultOptions.plugins,\n            ...userOptions.plugins || []\n        ]);\n        this.options = this.formatOptions(defaultOptions, userOptions);\n    }\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3J1bnRpbWUtY29yZS9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEY7QUFDd0w7QUFDOU07QUFDc0g7O0FBRTFMO0FBQ0E7QUFDQSxlQUFlLG9FQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWEsSUFBSSxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhLElBQUksSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWEsSUFBSSxZQUFZO0FBQzFEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCLEdBQUcsbUJBQW1CO0FBQ3hELE1BQU07QUFDTixrQkFBa0IsZ0JBQWdCLEdBQUcsaUJBQWlCO0FBQ3RELE1BQU07QUFDTixrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRUFBWSxNQUFNLHdFQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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VDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDJCQUEyQixvREFBUSxHQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG9EQUFRLEdBQUc7QUFDbkU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUIsb0VBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFbWEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcV2luIDExXFxEZXNrdG9wXFxSZWFjdC1NaWNyb0Zyb250ZW5kXFxtaWNyby1mcm9udGVuZFxcY2hhcnRcXG5vZGVfbW9kdWxlc1xcQG1vZHVsZS1mZWRlcmF0aW9uXFxydW50aW1lLWNvcmVcXGRpc3RcXGluZGV4LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfIGFzIF9leHRlbmRzLCBhIGFzIF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlIH0gZnJvbSAnLi9wb2x5ZmlsbHMuZXNtLmpzJztcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciwgaXNCcm93c2VyRW52LCBpc1JlYWN0TmF0aXZlRW52LCBpc0RlYnVnTW9kZSwgY29tcG9zZUtleVdpdGhTZXBhcmF0b3IsIGxvYWRTY3JpcHROb2RlLCBsb2FkU2NyaXB0LCBjcmVhdGVMaW5rLCBjcmVhdGVTY3JpcHQsIHNhZmVUb1N0cmluZywgZ2V0UmVzb3VyY2VVcmwsIGlzTWFuaWZlc3RQcm92aWRlciwgZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdCwgd2FybiBhcyB3YXJuJDEgfSBmcm9tICdAbW9kdWxlLWZlZGVyYXRpb24vc2RrJztcbmV4cG9ydCB7IGxvYWRTY3JpcHQsIGxvYWRTY3JpcHROb2RlIH0gZnJvbSAnQG1vZHVsZS1mZWRlcmF0aW9uL3Nkayc7XG5pbXBvcnQgeyBnZXRTaG9ydEVycm9yTXNnLCBSVU5USU1FXzAwOCwgcnVudGltZURlc2NNYXAsIFJVTlRJTUVfMDAxLCBSVU5USU1FXzAwMiwgUlVOVElNRV8wMDcsIFJVTlRJTUVfMDAzLCBSVU5USU1FXzAwNSwgUlVOVElNRV8wMDYsIFJVTlRJTUVfMDA0IH0gZnJvbSAnQG1vZHVsZS1mZWRlcmF0aW9uL2Vycm9yLWNvZGVzJztcblxuY29uc3QgTE9HX0NBVEVHT1JZID0gJ1sgRmVkZXJhdGlvbiBSdW50aW1lIF0nO1xuLy8gRklYTUU6IHByZS1idW5kbGUgP1xuY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKExPR19DQVRFR09SWSk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgZXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgICBpZiAobXNnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1lc3NhZ2UgYWxyZWFkeSBzdGFydHMgd2l0aCB0aGUgbG9nIGNhdGVnb3J5IHRvIGF2b2lkIGR1cGxpY2F0aW9uXG4gICAgICAgIGlmICghbXNnLm1lc3NhZ2Uuc3RhcnRzV2l0aChMT0dfQ0FURUdPUlkpKSB7XG4gICAgICAgICAgICBtc2cubWVzc2FnZSA9IGAke0xPR19DQVRFR09SWX06ICR7bXNnLm1lc3NhZ2V9YDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBtc2c7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtMT0dfQ0FURUdPUll9OiAke21zZ31gKTtcbn1cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgaWYgKG1zZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBtZXNzYWdlIGFscmVhZHkgc3RhcnRzIHdpdGggdGhlIGxvZyBjYXRlZ29yeSB0byBhdm9pZCBkdXBsaWNhdGlvblxuICAgICAgICBpZiAoIW1zZy5tZXNzYWdlLnN0YXJ0c1dpdGgoTE9HX0NBVEVHT1JZKSkge1xuICAgICAgICAgICAgbXNnLm1lc3NhZ2UgPSBgJHtMT0dfQ0FURUdPUll9OiAke21zZy5tZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLndhcm4obXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2Fybihtc2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkVW5pcXVlSXRlbShhcnIsIGl0ZW0pIHtcbiAgICBpZiAoYXJyLmZpbmRJbmRleCgobmFtZSk9Pm5hbWUgPT09IGl0ZW0pID09PSAtMSkge1xuICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGdldEZNSWQocmVtb3RlSW5mbykge1xuICAgIGlmICgndmVyc2lvbicgaW4gcmVtb3RlSW5mbyAmJiByZW1vdGVJbmZvLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGAke3JlbW90ZUluZm8ubmFtZX06JHtyZW1vdGVJbmZvLnZlcnNpb259YDtcbiAgICB9IGVsc2UgaWYgKCdlbnRyeScgaW4gcmVtb3RlSW5mbyAmJiByZW1vdGVJbmZvLmVudHJ5KSB7XG4gICAgICAgIHJldHVybiBgJHtyZW1vdGVJbmZvLm5hbWV9OiR7cmVtb3RlSW5mby5lbnRyeX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtyZW1vdGVJbmZvLm5hbWV9YDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1JlbW90ZUluZm9XaXRoRW50cnkocmVtb3RlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiByZW1vdGUuZW50cnkgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gaXNQdXJlUmVtb3RlRW50cnkocmVtb3RlKSB7XG4gICAgcmV0dXJuICFyZW1vdGUuZW50cnkuaW5jbHVkZXMoJy5qc29uJyk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuYXN5bmMgZnVuY3Rpb24gc2FmZVdyYXBwZXIoY2FsbGJhY2ssIGRpc2FibGVXYXJuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICFkaXNhYmxlV2FybiAmJiB3YXJuKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gICAgcmV0dXJuIHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNSZXNvdXJjZXNFcXVhbCh1cmwxLCB1cmwyKSB7XG4gICAgY29uc3QgUkVHX0VYUCA9IC9eKGh0dHBzPzopP1xcL1xcLy9pO1xuICAgIC8vIFRyYW5zZm9ybSB1cmwxIGFuZCB1cmwyIGludG8gcmVsYXRpdmUgcGF0aHNcbiAgICBjb25zdCByZWxhdGl2ZVVybDEgPSB1cmwxLnJlcGxhY2UoUkVHX0VYUCwgJycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgY29uc3QgcmVsYXRpdmVVcmwyID0gdXJsMi5yZXBsYWNlKFJFR19FWFAsICcnKS5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgIC8vIENoZWNrIGlmIHRoZSByZWxhdGl2ZSBwYXRocyBhcmUgaWRlbnRpY2FsXG4gICAgcmV0dXJuIHJlbGF0aXZlVXJsMSA9PT0gcmVsYXRpdmVVcmwyO1xufVxuZnVuY3Rpb24gYXJyYXlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvcHRpb25zKSA/IG9wdGlvbnMgOiBbXG4gICAgICAgIG9wdGlvbnNcbiAgICBdO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3RlRW50cnlJbmZvRnJvbVNuYXBzaG90KHNuYXBzaG90KSB7XG4gICAgY29uc3QgZGVmYXVsdFJlbW90ZUVudHJ5SW5mbyA9IHtcbiAgICAgICAgdXJsOiAnJyxcbiAgICAgICAgdHlwZTogJ2dsb2JhbCcsXG4gICAgICAgIGdsb2JhbE5hbWU6ICcnXG4gICAgfTtcbiAgICBpZiAoaXNCcm93c2VyRW52KCkgfHwgaXNSZWFjdE5hdGl2ZUVudigpKSB7XG4gICAgICAgIHJldHVybiAncmVtb3RlRW50cnknIGluIHNuYXBzaG90ID8ge1xuICAgICAgICAgICAgdXJsOiBzbmFwc2hvdC5yZW1vdGVFbnRyeSxcbiAgICAgICAgICAgIHR5cGU6IHNuYXBzaG90LnJlbW90ZUVudHJ5VHlwZSxcbiAgICAgICAgICAgIGdsb2JhbE5hbWU6IHNuYXBzaG90Lmdsb2JhbE5hbWVcbiAgICAgICAgfSA6IGRlZmF1bHRSZW1vdGVFbnRyeUluZm87XG4gICAgfVxuICAgIGlmICgnc3NyUmVtb3RlRW50cnknIGluIHNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IHNuYXBzaG90LnNzclJlbW90ZUVudHJ5IHx8IGRlZmF1bHRSZW1vdGVFbnRyeUluZm8udXJsLFxuICAgICAgICAgICAgdHlwZTogc25hcHNob3Quc3NyUmVtb3RlRW50cnlUeXBlIHx8IGRlZmF1bHRSZW1vdGVFbnRyeUluZm8udHlwZSxcbiAgICAgICAgICAgIGdsb2JhbE5hbWU6IHNuYXBzaG90Lmdsb2JhbE5hbWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZW1vdGVFbnRyeUluZm87XG59XG5jb25zdCBwcm9jZXNzTW9kdWxlQWxpYXMgPSAobmFtZSwgc3ViUGF0aCk9PntcbiAgICAvLyBAaG9zdC8gLi9idXR0b24gLT4gQGhvc3QvYnV0dG9uXG4gICAgbGV0IG1vZHVsZU5hbWU7XG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICBtb2R1bGVOYW1lID0gbmFtZS5zbGljZSgwLCAtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbW9kdWxlTmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIGlmIChzdWJQYXRoLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICBzdWJQYXRoID0gc3ViUGF0aC5zbGljZSgxKTtcbiAgICB9XG4gICAgbW9kdWxlTmFtZSA9IG1vZHVsZU5hbWUgKyBzdWJQYXRoO1xuICAgIHJldHVybiBtb2R1bGVOYW1lO1xufTtcblxuY29uc3QgQ3VycmVudEdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyA/IGdsb2JhbFRoaXMgOiB3aW5kb3c7XG5jb25zdCBuYXRpdmVHbG9iYWwgPSAoKCk9PntcbiAgICB0cnkge1xuICAgICAgICAvLyBnZXQgcmVhbCB3aW5kb3cgKGluY2FzZSBvZiBzYW5kYm94KVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBub2RlIGVudlxuICAgICAgICByZXR1cm4gQ3VycmVudEdsb2JhbDtcbiAgICB9XG59KSgpO1xuY29uc3QgR2xvYmFsID0gbmF0aXZlR2xvYmFsO1xuZnVuY3Rpb24gZGVmaW5lUHJvcGVydHlHbG9iYWxWYWwodGFyZ2V0LCBrZXksIHZhbCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5jbHVkZU93blByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KTtcbn1cbi8vIFRoaXMgc2VjdGlvbiBpcyB0byBwcmV2ZW50IGVuY2Fwc3VsYXRpb24gYnkgY2VydGFpbiBtaWNyb2Zyb250ZW5kIGZyYW1ld29ya3MuIER1ZSB0byByZXVzZSBwb2xpY2llcywgc2FuZGJveCBlc2NhcGVzLlxuLy8gVGhlIHNhbmRib3ggaW4gdGhlIG1pY3JvZnJvbnRlbmQgZG9lcyBub3QgcmVwbGljYXRlIHRoZSB2YWx1ZSBvZiAnY29uZmlndXJhYmxlJy5cbi8vIElmIHRoZXJlIGlzIG5vIGxvYWRpbmcgY29udGVudCBvbiB0aGUgZ2xvYmFsIG9iamVjdCwgdGhpcyBzZWN0aW9uIGRlZmluZXMgdGhlIGxvYWRpbmcgb2JqZWN0LlxuaWYgKCFpbmNsdWRlT3duUHJvcGVydHkoQ3VycmVudEdsb2JhbCwgJ19fR0xPQkFMX0xPQURJTkdfUkVNT1RFX0VOVFJZX18nKSkge1xuICAgIGRlZmluZVByb3BlcnR5R2xvYmFsVmFsKEN1cnJlbnRHbG9iYWwsICdfX0dMT0JBTF9MT0FESU5HX1JFTU9URV9FTlRSWV9fJywge30pO1xufVxuY29uc3QgZ2xvYmFsTG9hZGluZyA9IEN1cnJlbnRHbG9iYWwuX19HTE9CQUxfTE9BRElOR19SRU1PVEVfRU5UUllfXztcbmZ1bmN0aW9uIHNldEdsb2JhbERlZmF1bHRWYWwodGFyZ2V0KSB7XG4gICAgdmFyIF90YXJnZXRfX19GRURFUkFUSU9OX18sIF90YXJnZXRfX19GRURFUkFUSU9OX18xLCBfdGFyZ2V0X19fRkVERVJBVElPTl9fMiwgX3RhcmdldF9fX0ZFREVSQVRJT05fXzMsIF90YXJnZXRfX19GRURFUkFUSU9OX180LCBfdGFyZ2V0X19fRkVERVJBVElPTl9fNTtcbiAgICBpZiAoaW5jbHVkZU93blByb3BlcnR5KHRhcmdldCwgJ19fVk1PS19fJykgJiYgIWluY2x1ZGVPd25Qcm9wZXJ0eSh0YXJnZXQsICdfX0ZFREVSQVRJT05fXycpKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5R2xvYmFsVmFsKHRhcmdldCwgJ19fRkVERVJBVElPTl9fJywgdGFyZ2V0Ll9fVk1PS19fKTtcbiAgICB9XG4gICAgaWYgKCFpbmNsdWRlT3duUHJvcGVydHkodGFyZ2V0LCAnX19GRURFUkFUSU9OX18nKSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eUdsb2JhbFZhbCh0YXJnZXQsICdfX0ZFREVSQVRJT05fXycsIHtcbiAgICAgICAgICAgIF9fR0xPQkFMX1BMVUdJTl9fOiBbXSxcbiAgICAgICAgICAgIF9fSU5TVEFOQ0VTX186IFtdLFxuICAgICAgICAgICAgbW9kdWxlSW5mbzoge30sXG4gICAgICAgICAgICBfX1NIQVJFX186IHt9LFxuICAgICAgICAgICAgX19NQU5JRkVTVF9MT0FESU5HX186IHt9LFxuICAgICAgICAgICAgX19QUkVMT0FERURfTUFQX186IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydHlHbG9iYWxWYWwodGFyZ2V0LCAnX19WTU9LX18nLCB0YXJnZXQuX19GRURFUkFUSU9OX18pO1xuICAgIH1cbiAgICB2YXIgX19fR0xPQkFMX1BMVUdJTl9fO1xuICAgIChfX19HTE9CQUxfUExVR0lOX18gPSAoX3RhcmdldF9fX0ZFREVSQVRJT05fXyA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykuX19HTE9CQUxfUExVR0lOX18pICE9IG51bGwgPyBfX19HTE9CQUxfUExVR0lOX18gOiBfdGFyZ2V0X19fRkVERVJBVElPTl9fLl9fR0xPQkFMX1BMVUdJTl9fID0gW107XG4gICAgdmFyIF9fX0lOU1RBTkNFU19fO1xuICAgIChfX19JTlNUQU5DRVNfXyA9IChfdGFyZ2V0X19fRkVERVJBVElPTl9fMSA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykuX19JTlNUQU5DRVNfXykgIT0gbnVsbCA/IF9fX0lOU1RBTkNFU19fIDogX3RhcmdldF9fX0ZFREVSQVRJT05fXzEuX19JTlNUQU5DRVNfXyA9IFtdO1xuICAgIHZhciBfbW9kdWxlSW5mbztcbiAgICAoX21vZHVsZUluZm8gPSAoX3RhcmdldF9fX0ZFREVSQVRJT05fXzIgPSB0YXJnZXQuX19GRURFUkFUSU9OX18pLm1vZHVsZUluZm8pICE9IG51bGwgPyBfbW9kdWxlSW5mbyA6IF90YXJnZXRfX19GRURFUkFUSU9OX18yLm1vZHVsZUluZm8gPSB7fTtcbiAgICB2YXIgX19fU0hBUkVfXztcbiAgICAoX19fU0hBUkVfXyA9IChfdGFyZ2V0X19fRkVERVJBVElPTl9fMyA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykuX19TSEFSRV9fKSAhPSBudWxsID8gX19fU0hBUkVfXyA6IF90YXJnZXRfX19GRURFUkFUSU9OX18zLl9fU0hBUkVfXyA9IHt9O1xuICAgIHZhciBfX19NQU5JRkVTVF9MT0FESU5HX187XG4gICAgKF9fX01BTklGRVNUX0xPQURJTkdfXyA9IChfdGFyZ2V0X19fRkVERVJBVElPTl9fNCA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykuX19NQU5JRkVTVF9MT0FESU5HX18pICE9IG51bGwgPyBfX19NQU5JRkVTVF9MT0FESU5HX18gOiBfdGFyZ2V0X19fRkVERVJBVElPTl9fNC5fX01BTklGRVNUX0xPQURJTkdfXyA9IHt9O1xuICAgIHZhciBfX19QUkVMT0FERURfTUFQX187XG4gICAgKF9fX1BSRUxPQURFRF9NQVBfXyA9IChfdGFyZ2V0X19fRkVERVJBVElPTl9fNSA9IHRhcmdldC5fX0ZFREVSQVRJT05fXykuX19QUkVMT0FERURfTUFQX18pICE9IG51bGwgPyBfX19QUkVMT0FERURfTUFQX18gOiBfdGFyZ2V0X19fRkVERVJBVElPTl9fNS5fX1BSRUxPQURFRF9NQVBfXyA9IG5ldyBNYXAoKTtcbn1cbnNldEdsb2JhbERlZmF1bHRWYWwoQ3VycmVudEdsb2JhbCk7XG5zZXRHbG9iYWxEZWZhdWx0VmFsKG5hdGl2ZUdsb2JhbCk7XG5mdW5jdGlvbiByZXNldEZlZGVyYXRpb25HbG9iYWxJbmZvKCkge1xuICAgIEN1cnJlbnRHbG9iYWwuX19GRURFUkFUSU9OX18uX19HTE9CQUxfUExVR0lOX18gPSBbXTtcbiAgICBDdXJyZW50R2xvYmFsLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX18gPSBbXTtcbiAgICBDdXJyZW50R2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8gPSB7fTtcbiAgICBDdXJyZW50R2xvYmFsLl9fRkVERVJBVElPTl9fLl9fU0hBUkVfXyA9IHt9O1xuICAgIEN1cnJlbnRHbG9iYWwuX19GRURFUkFUSU9OX18uX19NQU5JRkVTVF9MT0FESU5HX18gPSB7fTtcbiAgICBPYmplY3Qua2V5cyhnbG9iYWxMb2FkaW5nKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGRlbGV0ZSBnbG9iYWxMb2FkaW5nW2tleV07XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UoRmVkZXJhdGlvbkluc3RhbmNlKSB7XG4gICAgQ3VycmVudEdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX0lOU1RBTkNFU19fLnB1c2goRmVkZXJhdGlvbkluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvcigpIHtcbiAgICByZXR1cm4gQ3VycmVudEdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX0RFQlVHX0NPTlNUUlVDVE9SX187XG59XG5mdW5jdGlvbiBzZXRHbG9iYWxGZWRlcmF0aW9uQ29uc3RydWN0b3IoRmVkZXJhdGlvbkNvbnN0cnVjdG9yLCBpc0RlYnVnID0gaXNEZWJ1Z01vZGUoKSkge1xuICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICAgIEN1cnJlbnRHbG9iYWwuX19GRURFUkFUSU9OX18uX19ERUJVR19DT05TVFJVQ1RPUl9fID0gRmVkZXJhdGlvbkNvbnN0cnVjdG9yO1xuICAgICAgICBDdXJyZW50R2xvYmFsLl9fRkVERVJBVElPTl9fLl9fREVCVUdfQ09OU1RSVUNUT1JfVkVSU0lPTl9fID0gXCIwLjE4LjNcIjtcbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gZ2V0SW5mb1dpdGhvdXRUeXBlKHRhcmdldCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGtleVJlcyA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAoa2V5UmVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXRba2V5XSxcbiAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YXJnZXRLZXkgb2YgdGFyZ2V0S2V5cyl7XG4gICAgICAgICAgICAgICAgY29uc3QgW3RhcmdldFR5cGVPck5hbWUsIF9dID0gdGFyZ2V0S2V5LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbktleSA9IGAke3RhcmdldFR5cGVPck5hbWV9OiR7a2V5fWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZVdpdGhLZXlSZXMgPSB0YXJnZXRbbktleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVXaXRoS2V5UmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHlwZVdpdGhLZXlSZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG5LZXlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleSBtdXN0IGJlIHN0cmluZycpO1xuICAgIH1cbn1cbmNvbnN0IGdldEdsb2JhbFNuYXBzaG90ID0gKCk9Pm5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvO1xuY29uc3QgZ2V0VGFyZ2V0U25hcHNob3RJbmZvQnlNb2R1bGVJbmZvID0gKG1vZHVsZUluZm8sIHNuYXBzaG90KT0+e1xuICAgIC8vIENoZWNrIGlmIHRoZSByZW1vdGUgaXMgaW5jbHVkZWQgaW4gdGhlIGhvc3RTbmFwc2hvdFxuICAgIGNvbnN0IG1vZHVsZUtleSA9IGdldEZNSWQobW9kdWxlSW5mbyk7XG4gICAgY29uc3QgZ2V0TW9kdWxlSW5mbyA9IGdldEluZm9XaXRob3V0VHlwZShzbmFwc2hvdCwgbW9kdWxlS2V5KS52YWx1ZTtcbiAgICAvLyBUaGUgcmVtb3RlU25hcHNob3QgbWlnaHQgbm90IGluY2x1ZGUgYSB2ZXJzaW9uXG4gICAgaWYgKGdldE1vZHVsZUluZm8gJiYgIWdldE1vZHVsZUluZm8udmVyc2lvbiAmJiAndmVyc2lvbicgaW4gbW9kdWxlSW5mbyAmJiBtb2R1bGVJbmZvWyd2ZXJzaW9uJ10pIHtcbiAgICAgICAgZ2V0TW9kdWxlSW5mby52ZXJzaW9uID0gbW9kdWxlSW5mb1sndmVyc2lvbiddO1xuICAgIH1cbiAgICBpZiAoZ2V0TW9kdWxlSW5mbykge1xuICAgICAgICByZXR1cm4gZ2V0TW9kdWxlSW5mbztcbiAgICB9XG4gICAgLy8gSWYgdGhlIHJlbW90ZSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGhvc3RTbmFwc2hvdCwgZGVwbG95IGEgbWljcm8gYXBwIHNuYXBzaG90XG4gICAgaWYgKCd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvICYmIG1vZHVsZUluZm9bJ3ZlcnNpb24nXSkge1xuICAgICAgICBjb25zdCB7IHZlcnNpb24gfSA9IG1vZHVsZUluZm8sIHJlc01vZHVsZUluZm8gPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShtb2R1bGVJbmZvLCBbXG4gICAgICAgICAgICBcInZlcnNpb25cIlxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgbW9kdWxlS2V5V2l0aG91dFZlcnNpb24gPSBnZXRGTUlkKHJlc01vZHVsZUluZm8pO1xuICAgICAgICBjb25zdCBnZXRNb2R1bGVJbmZvV2l0aG91dFZlcnNpb24gPSBnZXRJbmZvV2l0aG91dFR5cGUobmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8sIG1vZHVsZUtleVdpdGhvdXRWZXJzaW9uKS52YWx1ZTtcbiAgICAgICAgaWYgKChnZXRNb2R1bGVJbmZvV2l0aG91dFZlcnNpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGdldE1vZHVsZUluZm9XaXRob3V0VmVyc2lvbi52ZXJzaW9uKSA9PT0gdmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1vZHVsZUluZm9XaXRob3V0VmVyc2lvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59O1xuY29uc3QgZ2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvID0gKG1vZHVsZUluZm8pPT5nZXRUYXJnZXRTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8obW9kdWxlSW5mbywgbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8pO1xuY29uc3Qgc2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvID0gKHJlbW90ZUluZm8sIG1vZHVsZURldGFpbEluZm8pPT57XG4gICAgY29uc3QgbW9kdWxlS2V5ID0gZ2V0Rk1JZChyZW1vdGVJbmZvKTtcbiAgICBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mb1ttb2R1bGVLZXldID0gbW9kdWxlRGV0YWlsSW5mbztcbiAgICByZXR1cm4gbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm87XG59O1xuY29uc3QgYWRkR2xvYmFsU25hcHNob3QgPSAobW9kdWxlSW5mb3MpPT57XG4gICAgbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8gPSBfZXh0ZW5kcyh7fSwgbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8sIG1vZHVsZUluZm9zKTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG1vZHVsZUluZm9zKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyl7XG4gICAgICAgICAgICBkZWxldGUgbmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm9ba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuY29uc3QgZ2V0UmVtb3RlRW50cnlFeHBvcnRzID0gKG5hbWUsIGdsb2JhbE5hbWUpPT57XG4gICAgY29uc3QgcmVtb3RlRW50cnlLZXkgPSBnbG9iYWxOYW1lIHx8IGBfX0ZFREVSQVRJT05fJHtuYW1lfTpjdXN0b21fX2A7XG4gICAgY29uc3QgZW50cnlFeHBvcnRzID0gQ3VycmVudEdsb2JhbFtyZW1vdGVFbnRyeUtleV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3RlRW50cnlLZXksXG4gICAgICAgIGVudHJ5RXhwb3J0c1xuICAgIH07XG59O1xuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlZ2lzdGVyIGdsb2JhbCBwbHVnaW5zLlxuLy8gSXQgaXRlcmF0ZXMgb3ZlciB0aGUgcHJvdmlkZWQgcGx1Z2lucyBhbmQgY2hlY2tzIGlmIHRoZXkgYXJlIGFscmVhZHkgcmVnaXN0ZXJlZC5cbi8vIElmIGEgcGx1Z2luIGlzIG5vdCByZWdpc3RlcmVkLCBpdCBpcyBhZGRlZCB0byB0aGUgZ2xvYmFsIHBsdWdpbnMuXG4vLyBJZiBhIHBsdWdpbiBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIGEgd2FybmluZyBtZXNzYWdlIGlzIGxvZ2dlZC5cbmNvbnN0IHJlZ2lzdGVyR2xvYmFsUGx1Z2lucyA9IChwbHVnaW5zKT0+e1xuICAgIGNvbnN0IHsgX19HTE9CQUxfUExVR0lOX18gfSA9IG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXztcbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbik9PntcbiAgICAgICAgaWYgKF9fR0xPQkFMX1BMVUdJTl9fLmZpbmRJbmRleCgocCk9PnAubmFtZSA9PT0gcGx1Z2luLm5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgX19HTE9CQUxfUExVR0lOX18ucHVzaChwbHVnaW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybihgVGhlIHBsdWdpbiAke3BsdWdpbi5uYW1lfSBoYXMgYmVlbiByZWdpc3RlcmVkLmApO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuY29uc3QgZ2V0R2xvYmFsSG9zdFBsdWdpbnMgPSAoKT0+bmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLl9fR0xPQkFMX1BMVUdJTl9fO1xuY29uc3QgZ2V0UHJlbG9hZGVkID0gKGlkKT0+Q3VycmVudEdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX1BSRUxPQURFRF9NQVBfXy5nZXQoaWQpO1xuY29uc3Qgc2V0UHJlbG9hZGVkID0gKGlkKT0+Q3VycmVudEdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX1BSRUxPQURFRF9NQVBfXy5zZXQoaWQsIHRydWUpO1xuXG5jb25zdCBERUZBVUxUX1NDT1BFID0gJ2RlZmF1bHQnO1xuY29uc3QgREVGQVVMVF9SRU1PVEVfVFlQRSA9ICdnbG9iYWwnO1xuXG4vLyBmb3JrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29yaWdpbmpzL3ZpdGUtcGx1Z2luLWZlZGVyYXRpb24vYmxvYi92MS4xLjEyL3BhY2thZ2VzL2xpYi9zcmMvdXRpbHMvc2VtdmVyL2luZGV4LnRzXG4vLyB0aG9zZSBjb25zdGFudHMgYXJlIGJhc2VkIG9uIGh0dHBzOi8vd3d3LnJ1Ynlkb2MuaW5mby9nZW1zL3NlbWFudGljX3JhbmdlLzMuMC4wL1NlbWFudGljUmFuZ2UjQlVJTERJREVOVElGSUVSLWNvbnN0YW50XG4vLyBDb3B5cmlnaHQgKGMpXG4vLyB2aXRlLXBsdWdpbi1mZWRlcmF0aW9uIGlzIGxpY2Vuc2VkIHVuZGVyIE11bGFuIFBTTCB2Mi5cbi8vIFlvdSBjYW4gdXNlIHRoaXMgc29mdHdhcmUgYWNjb3JkaW5nIHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGUgTXVsYW4gUFNMIHYyLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIE11bGFuIFBTTCB2MiBhdDpcbi8vICAgICAgaHR0cDovL2xpY2Vuc2UuY29zY2wub3JnLmNuL011bGFuUFNMMlxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBPTiBBTiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPRiBBTlkgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBOT04tSU5GUklOR0VNRU5ULCBNRVJDSEFOVEFCSUxJVFkgT1IgRklUIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS5cbi8vIFNlZSB0aGUgTXVsYW4gUFNMIHYyIGZvciBtb3JlIGRldGFpbHMuXG5jb25zdCBidWlsZElkZW50aWZpZXIgPSAnWzAtOUEtWmEtei1dKyc7XG5jb25zdCBidWlsZCA9IGAoPzpcXFxcKygke2J1aWxkSWRlbnRpZmllcn0oPzpcXFxcLiR7YnVpbGRJZGVudGlmaWVyfSkqKSlgO1xuY29uc3QgbnVtZXJpY0lkZW50aWZpZXIgPSAnMHxbMS05XVxcXFxkKic7XG5jb25zdCBudW1lcmljSWRlbnRpZmllckxvb3NlID0gJ1swLTldKyc7XG5jb25zdCBub25OdW1lcmljSWRlbnRpZmllciA9ICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJztcbmNvbnN0IHByZVJlbGVhc2VJZGVudGlmaWVyTG9vc2UgPSBgKD86JHtudW1lcmljSWRlbnRpZmllckxvb3NlfXwke25vbk51bWVyaWNJZGVudGlmaWVyfSlgO1xuY29uc3QgcHJlUmVsZWFzZUxvb3NlID0gYCg/Oi0/KCR7cHJlUmVsZWFzZUlkZW50aWZpZXJMb29zZX0oPzpcXFxcLiR7cHJlUmVsZWFzZUlkZW50aWZpZXJMb29zZX0pKikpYDtcbmNvbnN0IHByZVJlbGVhc2VJZGVudGlmaWVyID0gYCg/OiR7bnVtZXJpY0lkZW50aWZpZXJ9fCR7bm9uTnVtZXJpY0lkZW50aWZpZXJ9KWA7XG5jb25zdCBwcmVSZWxlYXNlID0gYCg/Oi0oJHtwcmVSZWxlYXNlSWRlbnRpZmllcn0oPzpcXFxcLiR7cHJlUmVsZWFzZUlkZW50aWZpZXJ9KSopKWA7XG5jb25zdCB4UmFuZ2VJZGVudGlmaWVyID0gYCR7bnVtZXJpY0lkZW50aWZpZXJ9fHh8WHxcXFxcKmA7XG5jb25zdCB4UmFuZ2VQbGFpbiA9IGBbdj1cXFxcc10qKCR7eFJhbmdlSWRlbnRpZmllcn0pKD86XFxcXC4oJHt4UmFuZ2VJZGVudGlmaWVyfSkoPzpcXFxcLigke3hSYW5nZUlkZW50aWZpZXJ9KSg/OiR7cHJlUmVsZWFzZX0pPyR7YnVpbGR9Pyk/KT9gO1xuY29uc3QgaHlwaGVuUmFuZ2UgPSBgXlxcXFxzKigke3hSYW5nZVBsYWlufSlcXFxccystXFxcXHMrKCR7eFJhbmdlUGxhaW59KVxcXFxzKiRgO1xuY29uc3QgbWFpblZlcnNpb25Mb29zZSA9IGAoJHtudW1lcmljSWRlbnRpZmllckxvb3NlfSlcXFxcLigke251bWVyaWNJZGVudGlmaWVyTG9vc2V9KVxcXFwuKCR7bnVtZXJpY0lkZW50aWZpZXJMb29zZX0pYDtcbmNvbnN0IGxvb3NlUGxhaW4gPSBgW3Y9XFxcXHNdKiR7bWFpblZlcnNpb25Mb29zZX0ke3ByZVJlbGVhc2VMb29zZX0/JHtidWlsZH0/YDtcbmNvbnN0IGd0bHQgPSAnKCg/Ojx8Pik/PT8pJztcbmNvbnN0IGNvbXBhcmF0b3JUcmltID0gYChcXFxccyopJHtndGx0fVxcXFxzKigke2xvb3NlUGxhaW59fCR7eFJhbmdlUGxhaW59KWA7XG5jb25zdCBsb25lVGlsZGUgPSAnKD86fj4/KSc7XG5jb25zdCB0aWxkZVRyaW0gPSBgKFxcXFxzKikke2xvbmVUaWxkZX1cXFxccytgO1xuY29uc3QgbG9uZUNhcmV0ID0gJyg/OlxcXFxeKSc7XG5jb25zdCBjYXJldFRyaW0gPSBgKFxcXFxzKikke2xvbmVDYXJldH1cXFxccytgO1xuY29uc3Qgc3RhciA9ICcoPHw+KT89P1xcXFxzKlxcXFwqJztcbmNvbnN0IGNhcmV0ID0gYF4ke2xvbmVDYXJldH0ke3hSYW5nZVBsYWlufSRgO1xuY29uc3QgbWFpblZlcnNpb24gPSBgKCR7bnVtZXJpY0lkZW50aWZpZXJ9KVxcXFwuKCR7bnVtZXJpY0lkZW50aWZpZXJ9KVxcXFwuKCR7bnVtZXJpY0lkZW50aWZpZXJ9KWA7XG5jb25zdCBmdWxsUGxhaW4gPSBgdj8ke21haW5WZXJzaW9ufSR7cHJlUmVsZWFzZX0/JHtidWlsZH0/YDtcbmNvbnN0IHRpbGRlID0gYF4ke2xvbmVUaWxkZX0ke3hSYW5nZVBsYWlufSRgO1xuY29uc3QgeFJhbmdlID0gYF4ke2d0bHR9XFxcXHMqJHt4UmFuZ2VQbGFpbn0kYDtcbmNvbnN0IGNvbXBhcmF0b3IgPSBgXiR7Z3RsdH1cXFxccyooJHtmdWxsUGxhaW59KSR8XiRgO1xuLy8gY29weSBmcm9tIHNlbXZlciBwYWNrYWdlXG5jb25zdCBndGUwID0gJ15cXFxccyo+PVxcXFxzKjAuMC4wXFxcXHMqJCc7XG5cbi8vIGZvcmsgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb3JpZ2luanMvdml0ZS1wbHVnaW4tZmVkZXJhdGlvbi9ibG9iL3YxLjEuMTIvcGFja2FnZXMvbGliL3NyYy91dGlscy9zZW12ZXIvaW5kZXgudHNcbi8vIENvcHlyaWdodCAoYylcbi8vIHZpdGUtcGx1Z2luLWZlZGVyYXRpb24gaXMgbGljZW5zZWQgdW5kZXIgTXVsYW4gUFNMIHYyLlxuLy8gWW91IGNhbiB1c2UgdGhpcyBzb2Z0d2FyZSBhY2NvcmRpbmcgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mIHRoZSBNdWxhbiBQU0wgdjIuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgTXVsYW4gUFNMIHYyIGF0OlxuLy8gICAgICBodHRwOi8vbGljZW5zZS5jb3NjbC5vcmcuY24vTXVsYW5QU0wyXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIE9OIEFOIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9GIEFOWSBLSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIE5PTi1JTkZSSU5HRU1FTlQsIE1FUkNIQU5UQUJJTElUWSBPUiBGSVQgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLlxuLy8gU2VlIHRoZSBNdWxhbiBQU0wgdjIgZm9yIG1vcmUgZGV0YWlscy5cbmZ1bmN0aW9uIHBhcnNlUmVnZXgoc291cmNlKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc291cmNlKTtcbn1cbmZ1bmN0aW9uIGlzWFZlcnNpb24odmVyc2lvbikge1xuICAgIHJldHVybiAhdmVyc2lvbiB8fCB2ZXJzaW9uLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCB2ZXJzaW9uID09PSAnKic7XG59XG5mdW5jdGlvbiBwaXBlKC4uLmZucykge1xuICAgIHJldHVybiAoeCk9PmZucy5yZWR1Y2UoKHYsIGYpPT5mKHYpLCB4KTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDb21wYXJhdG9yKGNvbXBhcmF0b3JTdHJpbmcpIHtcbiAgICByZXR1cm4gY29tcGFyYXRvclN0cmluZy5tYXRjaChwYXJzZVJlZ2V4KGNvbXBhcmF0b3IpKTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVWZXJzaW9uKG1ham9yLCBtaW5vciwgcGF0Y2gsIHByZVJlbGVhc2UpIHtcbiAgICBjb25zdCBtYWluVmVyc2lvbiA9IGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofWA7XG4gICAgaWYgKHByZVJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIGAke21haW5WZXJzaW9ufS0ke3ByZVJlbGVhc2V9YDtcbiAgICB9XG4gICAgcmV0dXJuIG1haW5WZXJzaW9uO1xufVxuXG4vLyBmb3JrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29yaWdpbmpzL3ZpdGUtcGx1Z2luLWZlZGVyYXRpb24vYmxvYi92MS4xLjEyL3BhY2thZ2VzL2xpYi9zcmMvdXRpbHMvc2VtdmVyL2luZGV4LnRzXG4vLyBDb3B5cmlnaHQgKGMpXG4vLyB2aXRlLXBsdWdpbi1mZWRlcmF0aW9uIGlzIGxpY2Vuc2VkIHVuZGVyIE11bGFuIFBTTCB2Mi5cbi8vIFlvdSBjYW4gdXNlIHRoaXMgc29mdHdhcmUgYWNjb3JkaW5nIHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGUgTXVsYW4gUFNMIHYyLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIE11bGFuIFBTTCB2MiBhdDpcbi8vICAgICAgaHR0cDovL2xpY2Vuc2UuY29zY2wub3JnLmNuL011bGFuUFNMMlxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBPTiBBTiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPRiBBTlkgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBOT04tSU5GUklOR0VNRU5ULCBNRVJDSEFOVEFCSUxJVFkgT1IgRklUIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS5cbi8vIFNlZSB0aGUgTXVsYW4gUFNMIHYyIGZvciBtb3JlIGRldGFpbHMuXG5mdW5jdGlvbiBwYXJzZUh5cGhlbihyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS5yZXBsYWNlKHBhcnNlUmVnZXgoaHlwaGVuUmFuZ2UpLCAoX3JhbmdlLCBmcm9tLCBmcm9tTWFqb3IsIGZyb21NaW5vciwgZnJvbVBhdGNoLCBfZnJvbVByZVJlbGVhc2UsIF9mcm9tQnVpbGQsIHRvLCB0b01ham9yLCB0b01pbm9yLCB0b1BhdGNoLCB0b1ByZVJlbGVhc2UpPT57XG4gICAgICAgIGlmIChpc1hWZXJzaW9uKGZyb21NYWpvcikpIHtcbiAgICAgICAgICAgIGZyb20gPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKGZyb21NaW5vcikpIHtcbiAgICAgICAgICAgIGZyb20gPSBgPj0ke2Zyb21NYWpvcn0uMC4wYDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKGZyb21QYXRjaCkpIHtcbiAgICAgICAgICAgIGZyb20gPSBgPj0ke2Zyb21NYWpvcn0uJHtmcm9tTWlub3J9LjBgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IGA+PSR7ZnJvbX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1hWZXJzaW9uKHRvTWFqb3IpKSB7XG4gICAgICAgICAgICB0byA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGlzWFZlcnNpb24odG9NaW5vcikpIHtcbiAgICAgICAgICAgIHRvID0gYDwke051bWJlcih0b01ham9yKSArIDF9LjAuMC0wYDtcbiAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKHRvUGF0Y2gpKSB7XG4gICAgICAgICAgICB0byA9IGA8JHt0b01ham9yfS4ke051bWJlcih0b01pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgIH0gZWxzZSBpZiAodG9QcmVSZWxlYXNlKSB7XG4gICAgICAgICAgICB0byA9IGA8PSR7dG9NYWpvcn0uJHt0b01pbm9yfS4ke3RvUGF0Y2h9LSR7dG9QcmVSZWxlYXNlfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0byA9IGA8PSR7dG99YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7ZnJvbX0gJHt0b31gLnRyaW0oKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvclRyaW0ocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UucmVwbGFjZShwYXJzZVJlZ2V4KGNvbXBhcmF0b3JUcmltKSwgJyQxJDIkMycpO1xufVxuZnVuY3Rpb24gcGFyc2VUaWxkZVRyaW0ocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UucmVwbGFjZShwYXJzZVJlZ2V4KHRpbGRlVHJpbSksICckMX4nKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FyZXRUcmltKHJhbmdlKSB7XG4gICAgcmV0dXJuIHJhbmdlLnJlcGxhY2UocGFyc2VSZWdleChjYXJldFRyaW0pLCAnJDFeJyk7XG59XG5mdW5jdGlvbiBwYXJzZUNhcmV0cyhyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKHJhbmdlVmVyc2lvbik9PnJhbmdlVmVyc2lvbi5yZXBsYWNlKHBhcnNlUmVnZXgoY2FyZXQpLCAoXywgbWFqb3IsIG1pbm9yLCBwYXRjaCwgcHJlUmVsZWFzZSk9PntcbiAgICAgICAgICAgIGlmIChpc1hWZXJzaW9uKG1ham9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNYVmVyc2lvbihtaW5vcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uMC4wIDwke051bWJlcihtYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWFZlcnNpb24ocGF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ham9yID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LjAgPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LjAgPCR7TnVtYmVyKG1ham9yKSArIDF9LjAuMC0wYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZVJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFqb3IgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWlub3IgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9LSR7cHJlUmVsZWFzZX0gPCR7bWFqb3J9LiR7bWlub3J9LiR7TnVtYmVyKHBhdGNoKSArIDF9LTBgO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9LSR7cHJlUmVsZWFzZX0gPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0tJHtwcmVSZWxlYXNlfSA8JHtOdW1iZXIobWFqb3IpICsgMX0uMC4wLTBgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ham9yID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbm9yID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSA8JHttYWpvcn0uJHttaW5vcn0uJHtOdW1iZXIocGF0Y2gpICsgMX0tMGA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0gPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9IDwke051bWJlcihtYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBwYXJzZVRpbGRlcyhyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoKHJhbmdlVmVyc2lvbik9PnJhbmdlVmVyc2lvbi5yZXBsYWNlKHBhcnNlUmVnZXgodGlsZGUpLCAoXywgbWFqb3IsIG1pbm9yLCBwYXRjaCwgcHJlUmVsZWFzZSk9PntcbiAgICAgICAgICAgIGlmIChpc1hWZXJzaW9uKG1ham9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNYVmVyc2lvbihtaW5vcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uMC4wIDwke051bWJlcihtYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWFZlcnNpb24ocGF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LjAgPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZVJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0tJHtwcmVSZWxlYXNlfSA8JHttYWpvcn0uJHtOdW1iZXIobWlub3IpICsgMX0uMC0wYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSA8JHttYWpvcn0uJHtOdW1iZXIobWlub3IpICsgMX0uMC0wYDtcbiAgICAgICAgfSkpLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlWFJhbmdlcyhyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS5zcGxpdCgvXFxzKy8pLm1hcCgocmFuZ2VWZXJzaW9uKT0+cmFuZ2VWZXJzaW9uLnRyaW0oKS5yZXBsYWNlKHBhcnNlUmVnZXgoeFJhbmdlKSwgKHJldCwgZ3RsdCwgbWFqb3IsIG1pbm9yLCBwYXRjaCwgcHJlUmVsZWFzZSk9PntcbiAgICAgICAgICAgIGNvbnN0IGlzWE1ham9yID0gaXNYVmVyc2lvbihtYWpvcik7XG4gICAgICAgICAgICBjb25zdCBpc1hNaW5vciA9IGlzWE1ham9yIHx8IGlzWFZlcnNpb24obWlub3IpO1xuICAgICAgICAgICAgY29uc3QgaXNYUGF0Y2ggPSBpc1hNaW5vciB8fCBpc1hWZXJzaW9uKHBhdGNoKTtcbiAgICAgICAgICAgIGlmIChndGx0ID09PSAnPScgJiYgaXNYUGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBndGx0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVSZWxlYXNlID0gJyc7XG4gICAgICAgICAgICBpZiAoaXNYTWFqb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8MC4wLjAtMCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcqJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGd0bHQgJiYgaXNYUGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICAgICAgICAgICAgaWYgKGlzWE1pbm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbm9yID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSAwO1xuICAgICAgICAgICAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAgICAgICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgICAgICAgICAgICAgZ3RsdCA9ICc+PSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1hNaW5vcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFqb3IgPSBOdW1iZXIobWFqb3IpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yID0gTnVtYmVyKG1pbm9yKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGQgcGFzc1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICAgICAgICAgICAgICBndGx0ID0gJzwnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNYTWlub3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ham9yID0gTnVtYmVyKG1ham9yKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5vciA9IE51bWJlcihtaW5vcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChndGx0ID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlUmVsZWFzZSA9ICctMCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtndGx0ICsgbWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9JHtwcmVSZWxlYXNlfWA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWE1pbm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LjAuMCR7cHJlUmVsZWFzZX0gPCR7TnVtYmVyKG1ham9yKSArIDF9LjAuMC0wYDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNYUGF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uMCR7cHJlUmVsZWFzZX0gPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KSkuam9pbignICcpO1xufVxuZnVuY3Rpb24gcGFyc2VTdGFyKHJhbmdlKSB7XG4gICAgcmV0dXJuIHJhbmdlLnRyaW0oKS5yZXBsYWNlKHBhcnNlUmVnZXgoc3RhciksICcnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlR1RFMChjb21wYXJhdG9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIGNvbXBhcmF0b3JTdHJpbmcudHJpbSgpLnJlcGxhY2UocGFyc2VSZWdleChndGUwKSwgJycpO1xufVxuXG4vLyBmb3JrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29yaWdpbmpzL3ZpdGUtcGx1Z2luLWZlZGVyYXRpb24vYmxvYi92MS4xLjEyL3BhY2thZ2VzL2xpYi9zcmMvdXRpbHMvc2VtdmVyL2luZGV4LnRzXG4vLyBDb3B5cmlnaHQgKGMpXG4vLyB2aXRlLXBsdWdpbi1mZWRlcmF0aW9uIGlzIGxpY2Vuc2VkIHVuZGVyIE11bGFuIFBTTCB2Mi5cbi8vIFlvdSBjYW4gdXNlIHRoaXMgc29mdHdhcmUgYWNjb3JkaW5nIHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB0aGUgTXVsYW4gUFNMIHYyLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIE11bGFuIFBTTCB2MiBhdDpcbi8vICAgICAgaHR0cDovL2xpY2Vuc2UuY29zY2wub3JnLmNuL011bGFuUFNMMlxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBPTiBBTiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPRiBBTlkgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBOT04tSU5GUklOR0VNRU5ULCBNRVJDSEFOVEFCSUxJVFkgT1IgRklUIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS5cbi8vIFNlZSB0aGUgTXVsYW4gUFNMIHYyIGZvciBtb3JlIGRldGFpbHMuXG5mdW5jdGlvbiBjb21wYXJlQXRvbShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSB7XG4gICAgcmFuZ2VBdG9tID0gTnVtYmVyKHJhbmdlQXRvbSkgfHwgcmFuZ2VBdG9tO1xuICAgIHZlcnNpb25BdG9tID0gTnVtYmVyKHZlcnNpb25BdG9tKSB8fCB2ZXJzaW9uQXRvbTtcbiAgICBpZiAocmFuZ2VBdG9tID4gdmVyc2lvbkF0b20pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChyYW5nZUF0b20gPT09IHZlcnNpb25BdG9tKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBjb21wYXJlUHJlUmVsZWFzZShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSB7XG4gICAgY29uc3QgeyBwcmVSZWxlYXNlOiByYW5nZVByZVJlbGVhc2UgfSA9IHJhbmdlQXRvbTtcbiAgICBjb25zdCB7IHByZVJlbGVhc2U6IHZlcnNpb25QcmVSZWxlYXNlIH0gPSB2ZXJzaW9uQXRvbTtcbiAgICBpZiAocmFuZ2VQcmVSZWxlYXNlID09PSB1bmRlZmluZWQgJiYgQm9vbGVhbih2ZXJzaW9uUHJlUmVsZWFzZSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChCb29sZWFuKHJhbmdlUHJlUmVsZWFzZSkgJiYgdmVyc2lvblByZVJlbGVhc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChyYW5nZVByZVJlbGVhc2UgPT09IHVuZGVmaW5lZCAmJiB2ZXJzaW9uUHJlUmVsZWFzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IobGV0IGkgPSAwLCBuID0gcmFuZ2VQcmVSZWxlYXNlLmxlbmd0aDsgaSA8PSBuOyBpKyspe1xuICAgICAgICBjb25zdCByYW5nZUVsZW1lbnQgPSByYW5nZVByZVJlbGVhc2VbaV07XG4gICAgICAgIGNvbnN0IHZlcnNpb25FbGVtZW50ID0gdmVyc2lvblByZVJlbGVhc2VbaV07XG4gICAgICAgIGlmIChyYW5nZUVsZW1lbnQgPT09IHZlcnNpb25FbGVtZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2VFbGVtZW50ID09PSB1bmRlZmluZWQgJiYgdmVyc2lvbkVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYW5nZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmVyc2lvbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGFyZUF0b20ocmFuZ2VFbGVtZW50LCB2ZXJzaW9uRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcGFyZVZlcnNpb24ocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkge1xuICAgIHJldHVybiBjb21wYXJlQXRvbShyYW5nZUF0b20ubWFqb3IsIHZlcnNpb25BdG9tLm1ham9yKSB8fCBjb21wYXJlQXRvbShyYW5nZUF0b20ubWlub3IsIHZlcnNpb25BdG9tLm1pbm9yKSB8fCBjb21wYXJlQXRvbShyYW5nZUF0b20ucGF0Y2gsIHZlcnNpb25BdG9tLnBhdGNoKSB8fCBjb21wYXJlUHJlUmVsZWFzZShyYW5nZUF0b20sIHZlcnNpb25BdG9tKTtcbn1cbmZ1bmN0aW9uIGVxKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIHtcbiAgICByZXR1cm4gcmFuZ2VBdG9tLnZlcnNpb24gPT09IHZlcnNpb25BdG9tLnZlcnNpb247XG59XG5mdW5jdGlvbiBjb21wYXJlKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIHtcbiAgICBzd2l0Y2gocmFuZ2VBdG9tLm9wZXJhdG9yKXtcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICByZXR1cm4gZXEocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSk7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVWZXJzaW9uKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIDwgMDtcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgcmV0dXJuIGVxKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIHx8IGNvbXBhcmVWZXJzaW9uKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIDwgMDtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVZlcnNpb24ocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkgPiAwO1xuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICByZXR1cm4gZXEocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkgfHwgY29tcGFyZVZlcnNpb24ocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkgPiAwO1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBtZWFuICogb3IgeCAtPiBhbGwgdmVyc2lvbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGZvcmsgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb3JpZ2luanMvdml0ZS1wbHVnaW4tZmVkZXJhdGlvbi9ibG9iL3YxLjEuMTIvcGFja2FnZXMvbGliL3NyYy91dGlscy9zZW12ZXIvaW5kZXgudHNcbi8vIENvcHlyaWdodCAoYylcbi8vIHZpdGUtcGx1Z2luLWZlZGVyYXRpb24gaXMgbGljZW5zZWQgdW5kZXIgTXVsYW4gUFNMIHYyLlxuLy8gWW91IGNhbiB1c2UgdGhpcyBzb2Z0d2FyZSBhY2NvcmRpbmcgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mIHRoZSBNdWxhbiBQU0wgdjIuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgTXVsYW4gUFNMIHYyIGF0OlxuLy8gICAgICBodHRwOi8vbGljZW5zZS5jb3NjbC5vcmcuY24vTXVsYW5QU0wyXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIE9OIEFOIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9GIEFOWSBLSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIE5PTi1JTkZSSU5HRU1FTlQsIE1FUkNIQU5UQUJJTElUWSBPUiBGSVQgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLlxuLy8gU2VlIHRoZSBNdWxhbiBQU0wgdjIgZm9yIG1vcmUgZGV0YWlscy5cbmZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvclN0cmluZyhyYW5nZSkge1xuICAgIHJldHVybiBwaXBlKC8vIGhhbmRsZSBjYXJldFxuICAgIC8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4gICAgLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuICAgIC8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuICAgIC8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuICAgIC8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjAtMFxuICAgIC8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuICAgIHBhcnNlQ2FyZXRzLCAvLyBoYW5kbGUgdGlsZGVcbiAgICAvLyB+LCB+PiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbiAgICAvLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbiAgICAvLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4gICAgLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuICAgIC8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuICAgIC8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuICAgIHBhcnNlVGlsZGVzLCBwYXJzZVhSYW5nZXMsIHBhcnNlU3RhcikocmFuZ2UpO1xufVxuZnVuY3Rpb24gcGFyc2VSYW5nZShyYW5nZSkge1xuICAgIHJldHVybiBwaXBlKC8vIGhhbmRsZSBoeXBoZW5SYW5nZVxuICAgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICAgIHBhcnNlSHlwaGVuLCAvLyBoYW5kbGUgdHJpbSBjb21wYXJhdG9yXG4gICAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gICAgcGFyc2VDb21wYXJhdG9yVHJpbSwgLy8gaGFuZGxlIHRyaW0gdGlsZGVcbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICBwYXJzZVRpbGRlVHJpbSwgLy8gaGFuZGxlIHRyaW0gY2FyZXRcbiAgICAvLyBgXiAxLjIuM2AgPT4gYF4xLjIuM2BcbiAgICBwYXJzZUNhcmV0VHJpbSkocmFuZ2UudHJpbSgpKS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIHNhdGlzZnkodmVyc2lvbiwgcmFuZ2UpIHtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBFeHRyYWN0IHZlcnNpb24gZGV0YWlscyBvbmNlXG4gICAgY29uc3QgZXh0cmFjdGVkVmVyc2lvbiA9IGV4dHJhY3RDb21wYXJhdG9yKHZlcnNpb24pO1xuICAgIGlmICghZXh0cmFjdGVkVmVyc2lvbikge1xuICAgICAgICAvLyBJZiB0aGUgdmVyc2lvbiBzdHJpbmcgaXMgaW52YWxpZCwgaXQgY2FuJ3Qgc2F0aXNmeSBhbnkgcmFuZ2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBbLCB2ZXJzaW9uT3BlcmF0b3IsICwgdmVyc2lvbk1ham9yLCB2ZXJzaW9uTWlub3IsIHZlcnNpb25QYXRjaCwgdmVyc2lvblByZVJlbGVhc2VdID0gZXh0cmFjdGVkVmVyc2lvbjtcbiAgICBjb25zdCB2ZXJzaW9uQXRvbSA9IHtcbiAgICAgICAgb3BlcmF0b3I6IHZlcnNpb25PcGVyYXRvcixcbiAgICAgICAgdmVyc2lvbjogY29tYmluZVZlcnNpb24odmVyc2lvbk1ham9yLCB2ZXJzaW9uTWlub3IsIHZlcnNpb25QYXRjaCwgdmVyc2lvblByZVJlbGVhc2UpLFxuICAgICAgICBtYWpvcjogdmVyc2lvbk1ham9yLFxuICAgICAgICBtaW5vcjogdmVyc2lvbk1pbm9yLFxuICAgICAgICBwYXRjaDogdmVyc2lvblBhdGNoLFxuICAgICAgICBwcmVSZWxlYXNlOiB2ZXJzaW9uUHJlUmVsZWFzZSA9PSBudWxsID8gdm9pZCAwIDogdmVyc2lvblByZVJlbGVhc2Uuc3BsaXQoJy4nKVxuICAgIH07XG4gICAgLy8gU3BsaXQgdGhlIHJhbmdlIGJ5IHx8IHRvIGhhbmRsZSBPUiBjb25kaXRpb25zXG4gICAgY29uc3Qgb3JSYW5nZXMgPSByYW5nZS5zcGxpdCgnfHwnKTtcbiAgICBmb3IgKGNvbnN0IG9yUmFuZ2Ugb2Ygb3JSYW5nZXMpe1xuICAgICAgICBjb25zdCB0cmltbWVkT3JSYW5nZSA9IG9yUmFuZ2UudHJpbSgpO1xuICAgICAgICBpZiAoIXRyaW1tZWRPclJhbmdlKSB7XG4gICAgICAgICAgICAvLyBBbiBlbXB0eSByYW5nZSBzdHJpbmcgc2lnbmlmaWVzIHdpbGRjYXJkICosIHNhdGlzZnkgYW55IHZhbGlkIHZlcnNpb25cbiAgICAgICAgICAgIC8vIChXZSBhbHJlYWR5IGNoZWNrZWQgaWYgdGhlIHZlcnNpb24gaXRzZWxmIGlzIHZhbGlkKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHNpbXBsZSB3aWxkY2FyZHMgZXhwbGljaXRseSBiZWZvcmUgY29tcGxleCBwYXJzaW5nXG4gICAgICAgIGlmICh0cmltbWVkT3JSYW5nZSA9PT0gJyonIHx8IHRyaW1tZWRPclJhbmdlID09PSAneCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBBcHBseSBleGlzdGluZyBwYXJzaW5nIGxvZ2ljIHRvIHRoZSBjdXJyZW50IE9SIHN1Yi1yYW5nZVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkU3ViUmFuZ2UgPSBwYXJzZVJhbmdlKHRyaW1tZWRPclJhbmdlKTsgLy8gSGFuZGxlcyBoeXBoZW5zLCB0cmltcyBldGMuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcmVzdWx0IG9mIGluaXRpYWwgcGFyc2luZyBpcyBlbXB0eSwgd2hpY2ggY2FuIGhhcHBlblxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgd2lsZGNhcmQgY2FzZXMgaGFuZGxlZCBieSBwYXJzZVJhbmdlL3BhcnNlQ29tcGFyYXRvclN0cmluZy5cbiAgICAgICAgICAgIC8vIEUuZy4gYHBhcnNlU3RhcmAgdXNlZCBpbiBgcGFyc2VDb21wYXJhdG9yU3RyaW5nYCByZXR1cm5zICcnLlxuICAgICAgICAgICAgaWYgKCFwYXJzZWRTdWJSYW5nZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXJzaW5nIHJlc3VsdHMgaW4gZW1wdHkgc3RyaW5nLCB0cmVhdCBhcyB3aWxkY2FyZCBtYXRjaFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkQ29tcGFyYXRvclN0cmluZyA9IHBhcnNlZFN1YlJhbmdlLnNwbGl0KCcgJykubWFwKChyYW5nZVZlcnNpb24pPT5wYXJzZUNvbXBhcmF0b3JTdHJpbmcocmFuZ2VWZXJzaW9uKSkgLy8gRXhwYW5kcyBeLCB+XG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gaWYgdGhlIGNvbXBhcmF0b3Igc3RyaW5nIGJlY2FtZSBlbXB0eSBhZnRlciBzcGVjaWZpYyBwYXJzaW5nIGxpa2UgXiBvciB+XG4gICAgICAgICAgICBpZiAoIXBhcnNlZENvbXBhcmF0b3JTdHJpbmcudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgc3ViLXJhbmdlIGJ5IHNwYWNlIGZvciBpbXBsaWNpdCBBTkQgY29uZGl0aW9uc1xuICAgICAgICAgICAgY29uc3QgY29tcGFyYXRvcnMgPSBwYXJzZWRDb21wYXJhdG9yU3RyaW5nLnNwbGl0KC9cXHMrLykubWFwKChjb21wYXJhdG9yKT0+cGFyc2VHVEUwKGNvbXBhcmF0b3IpKS8vIEZpbHRlciBvdXQgZW1wdHkgc3RyaW5ncyB0aGF0IG1pZ2h0IHJlc3VsdCBmcm9tIG11bHRpcGxlIHNwYWNlc1xuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgIC8vIElmIGEgc3ViLXJhbmdlIGJlY29tZXMgZW1wdHkgYWZ0ZXIgcGFyc2luZyAoZS5nLiwgaW52YWxpZCBjaGFyYWN0ZXJzKSxcbiAgICAgICAgICAgIC8vIGl0IGNhbm5vdCBiZSBzYXRpc2ZpZWQuIFRoaXMgY2hlY2sgbWlnaHQgYmUgcmVkdW5kYW50IG5vdyBidXQga2VwdCBmb3Igc2FmZXR5LlxuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN1YlJhbmdlU2F0aXNmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29tcGFyYXRvciBvZiBjb21wYXJhdG9ycyl7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFjdGVkQ29tcGFyYXRvciA9IGV4dHJhY3RDb21wYXJhdG9yKGNvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIC8vIElmIGFueSBwYXJ0IG9mIHRoZSBBTkQgc3ViLXJhbmdlIGlzIGludmFsaWQsIHRoZSBzdWItcmFuZ2UgaXMgbm90IHNhdGlzZmllZFxuICAgICAgICAgICAgICAgIGlmICghZXh0cmFjdGVkQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBzdWJSYW5nZVNhdGlzZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgWywgcmFuZ2VPcGVyYXRvciwgLCByYW5nZU1ham9yLCByYW5nZU1pbm9yLCByYW5nZVBhdGNoLCByYW5nZVByZVJlbGVhc2VdID0gZXh0cmFjdGVkQ29tcGFyYXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZUF0b20gPSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiByYW5nZU9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBjb21iaW5lVmVyc2lvbihyYW5nZU1ham9yLCByYW5nZU1pbm9yLCByYW5nZVBhdGNoLCByYW5nZVByZVJlbGVhc2UpLFxuICAgICAgICAgICAgICAgICAgICBtYWpvcjogcmFuZ2VNYWpvcixcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IHJhbmdlTWlub3IsXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoOiByYW5nZVBhdGNoLFxuICAgICAgICAgICAgICAgICAgICBwcmVSZWxlYXNlOiByYW5nZVByZVJlbGVhc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJhbmdlUHJlUmVsZWFzZS5zcGxpdCgnLicpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdmVyc2lvbiBzYXRpc2ZpZXMgdGhpcyBzcGVjaWZpYyBjb21wYXJhdG9yIGluIHRoZSBBTkQgY2hhaW5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmUocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViUmFuZ2VTYXRpc2ZpZWQgPSBmYWxzZTsgLy8gVGhpcyBwYXJ0IG9mIHRoZSBBTkQgY29uZGl0aW9uIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gTm8gbmVlZCB0byBjaGVjayBmdXJ0aGVyIGNvbXBhcmF0b3JzIGluIHRoaXMgc3ViLXJhbmdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYWxsIEFORCBjb25kaXRpb25zIHdpdGhpbiB0aGlzIE9SIHN1Yi1yYW5nZSB3ZXJlIG1ldCwgdGhlIG92ZXJhbGwgcmFuZ2UgaXMgc2F0aXNmaWVkXG4gICAgICAgICAgICBpZiAoc3ViUmFuZ2VTYXRpc2ZpZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTG9nIGVycm9yIGFuZCB0cmVhdCB0aGlzIHN1Yi1yYW5nZSBhcyB1bnNhdGlzZmllZFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW3NlbXZlcl0gRXJyb3IgcHJvY2Vzc2luZyByYW5nZSBwYXJ0IFwiJHt0cmltbWVkT3JSYW5nZX1cIjpgLCBlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIG5vbmUgb2YgdGhlIE9SIHN1Yi1yYW5nZXMgd2VyZSBzYXRpc2ZpZWRcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFNoYXJlKHNoYXJlQXJncywgZnJvbSwgbmFtZSwgc2hhcmVTdHJhdGVneSkge1xuICAgIGxldCBnZXQ7XG4gICAgaWYgKCdnZXQnIGluIHNoYXJlQXJncykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgZ2V0ID0gc2hhcmVBcmdzLmdldDtcbiAgICB9IGVsc2UgaWYgKCdsaWInIGluIHNoYXJlQXJncykge1xuICAgICAgICBnZXQgPSAoKT0+UHJvbWlzZS5yZXNvbHZlKHNoYXJlQXJncy5saWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldCA9ICgpPT5Qcm9taXNlLnJlc29sdmUoKCk9PntcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgZ2V0IHNoYXJlZCAnJHtuYW1lfSchYCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIF9zaGFyZUFyZ3NfdmVyc2lvbiwgX3NoYXJlQXJnc19zY29wZSwgX3NoYXJlQXJnc19zdHJhdGVneTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBkZXBzOiBbXSxcbiAgICAgICAgdXNlSW46IFtdLFxuICAgICAgICBmcm9tLFxuICAgICAgICBsb2FkaW5nOiBudWxsXG4gICAgfSwgc2hhcmVBcmdzLCB7XG4gICAgICAgIHNoYXJlQ29uZmlnOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICByZXF1aXJlZFZlcnNpb246IGBeJHtzaGFyZUFyZ3MudmVyc2lvbn1gLFxuICAgICAgICAgICAgc2luZ2xldG9uOiBmYWxzZSxcbiAgICAgICAgICAgIGVhZ2VyOiBmYWxzZSxcbiAgICAgICAgICAgIHN0cmljdFZlcnNpb246IGZhbHNlXG4gICAgICAgIH0sIHNoYXJlQXJncy5zaGFyZUNvbmZpZyksXG4gICAgICAgIGdldCxcbiAgICAgICAgbG9hZGVkOiAoc2hhcmVBcmdzID09IG51bGwgPyB2b2lkIDAgOiBzaGFyZUFyZ3MubG9hZGVkKSB8fCAnbGliJyBpbiBzaGFyZUFyZ3MgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICB2ZXJzaW9uOiAoX3NoYXJlQXJnc192ZXJzaW9uID0gc2hhcmVBcmdzLnZlcnNpb24pICE9IG51bGwgPyBfc2hhcmVBcmdzX3ZlcnNpb24gOiAnMCcsXG4gICAgICAgIHNjb3BlOiBBcnJheS5pc0FycmF5KHNoYXJlQXJncy5zY29wZSkgPyBzaGFyZUFyZ3Muc2NvcGUgOiBbXG4gICAgICAgICAgICAoX3NoYXJlQXJnc19zY29wZSA9IHNoYXJlQXJncy5zY29wZSkgIT0gbnVsbCA/IF9zaGFyZUFyZ3Nfc2NvcGUgOiAnZGVmYXVsdCdcbiAgICAgICAgXSxcbiAgICAgICAgc3RyYXRlZ3k6ICgoX3NoYXJlQXJnc19zdHJhdGVneSA9IHNoYXJlQXJncy5zdHJhdGVneSkgIT0gbnVsbCA/IF9zaGFyZUFyZ3Nfc3RyYXRlZ3kgOiBzaGFyZVN0cmF0ZWd5KSB8fCAndmVyc2lvbi1maXJzdCdcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNoYXJlQ29uZmlncyhnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucykge1xuICAgIGNvbnN0IHNoYXJlQXJncyA9IHVzZXJPcHRpb25zLnNoYXJlZCB8fCB7fTtcbiAgICBjb25zdCBmcm9tID0gdXNlck9wdGlvbnMubmFtZTtcbiAgICBjb25zdCBzaGFyZUluZm9zID0gT2JqZWN0LmtleXMoc2hhcmVBcmdzKS5yZWR1Y2UoKHJlcywgcGtnTmFtZSk9PntcbiAgICAgICAgY29uc3QgYXJyYXlTaGFyZUFyZ3MgPSBhcnJheU9wdGlvbnMoc2hhcmVBcmdzW3BrZ05hbWVdKTtcbiAgICAgICAgcmVzW3BrZ05hbWVdID0gcmVzW3BrZ05hbWVdIHx8IFtdO1xuICAgICAgICBhcnJheVNoYXJlQXJncy5mb3JFYWNoKChzaGFyZUNvbmZpZyk9PntcbiAgICAgICAgICAgIHJlc1twa2dOYW1lXS5wdXNoKGZvcm1hdFNoYXJlKHNoYXJlQ29uZmlnLCBmcm9tLCBwa2dOYW1lLCB1c2VyT3B0aW9ucy5zaGFyZVN0cmF0ZWd5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBzaGFyZWQgPSBfZXh0ZW5kcyh7fSwgZ2xvYmFsT3B0aW9ucy5zaGFyZWQpO1xuICAgIE9iamVjdC5rZXlzKHNoYXJlSW5mb3MpLmZvckVhY2goKHNoYXJlS2V5KT0+e1xuICAgICAgICBpZiAoIXNoYXJlZFtzaGFyZUtleV0pIHtcbiAgICAgICAgICAgIHNoYXJlZFtzaGFyZUtleV0gPSBzaGFyZUluZm9zW3NoYXJlS2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXJlSW5mb3Nbc2hhcmVLZXldLmZvckVhY2goKG5ld1VzZXJTaGFyZWRPcHRpb25zKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2FtZVZlcnNpb24gPSBzaGFyZWRbc2hhcmVLZXldLmZpbmQoKHNoYXJlZFZhbCk9PnNoYXJlZFZhbC52ZXJzaW9uID09PSBuZXdVc2VyU2hhcmVkT3B0aW9ucy52ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU2FtZVZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVkW3NoYXJlS2V5XS5wdXNoKG5ld1VzZXJTaGFyZWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNoYXJlZCxcbiAgICAgICAgc2hhcmVJbmZvc1xuICAgIH07XG59XG5mdW5jdGlvbiB2ZXJzaW9uTHQoYSwgYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybUludmFsaWRWZXJzaW9uID0gKHZlcnNpb24pPT57XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyVmVyc2lvbiA9ICFOdW1iZXIuaXNOYU4oTnVtYmVyKHZlcnNpb24pKTtcbiAgICAgICAgaWYgKGlzTnVtYmVyVmVyc2lvbikge1xuICAgICAgICAgICAgY29uc3Qgc3BsaXRBcnIgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBsZXQgdmFsaWRWZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAzIC0gc3BsaXRBcnIubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhbGlkVmVyc2lvbiArPSAnLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9O1xuICAgIGlmIChzYXRpc2Z5KHRyYW5zZm9ybUludmFsaWRWZXJzaW9uKGEpLCBgPD0ke3RyYW5zZm9ybUludmFsaWRWZXJzaW9uKGIpfWApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBmaW5kVmVyc2lvbiA9IChzaGFyZVZlcnNpb25NYXAsIGNiKT0+e1xuICAgIGNvbnN0IGNhbGxiYWNrID0gY2IgfHwgZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uTHQocHJldiwgY3VyKTtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzaGFyZVZlcnNpb25NYXApLnJlZHVjZSgocHJldiwgY3VyKT0+e1xuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKHByZXYsIGN1cikpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmYXVsdCB2ZXJzaW9uIGlzICcwJyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2IvbWFpbi9saWIvc2hhcmluZy9Qcm92aWRlU2hhcmVkTW9kdWxlLmpzI0wxMzZcbiAgICAgICAgaWYgKHByZXYgPT09ICcwJykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9LCAwKTtcbn07XG5jb25zdCBpc0xvYWRlZCA9IChzaGFyZWQpPT57XG4gICAgcmV0dXJuIEJvb2xlYW4oc2hhcmVkLmxvYWRlZCkgfHwgdHlwZW9mIHNoYXJlZC5saWIgPT09ICdmdW5jdGlvbic7XG59O1xuY29uc3QgaXNMb2FkaW5nID0gKHNoYXJlZCk9PntcbiAgICByZXR1cm4gQm9vbGVhbihzaGFyZWQubG9hZGluZyk7XG59O1xuZnVuY3Rpb24gZmluZFNpbmdsZXRvblZlcnNpb25PcmRlckJ5VmVyc2lvbihzaGFyZVNjb3BlTWFwLCBzY29wZSwgcGtnTmFtZSkge1xuICAgIGNvbnN0IHZlcnNpb25zID0gc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgICAgcmV0dXJuICFpc0xvYWRlZCh2ZXJzaW9uc1twcmV2XSkgJiYgdmVyc2lvbkx0KHByZXYsIGN1cik7XG4gICAgfTtcbiAgICByZXR1cm4gZmluZFZlcnNpb24oc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV0sIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGZpbmRTaW5nbGV0b25WZXJzaW9uT3JkZXJCeUxvYWRlZChzaGFyZVNjb3BlTWFwLCBzY29wZSwgcGtnTmFtZSkge1xuICAgIGNvbnN0IHZlcnNpb25zID0gc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgICAgY29uc3QgaXNMb2FkaW5nT3JMb2FkZWQgPSAoc2hhcmVkKT0+e1xuICAgICAgICAgICAgcmV0dXJuIGlzTG9hZGVkKHNoYXJlZCkgfHwgaXNMb2FkaW5nKHNoYXJlZCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc0xvYWRpbmdPckxvYWRlZCh2ZXJzaW9uc1tjdXJdKSkge1xuICAgICAgICAgICAgaWYgKGlzTG9hZGluZ09yTG9hZGVkKHZlcnNpb25zW3ByZXZdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHZlcnNpb25MdChwcmV2LCBjdXIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTG9hZGluZ09yTG9hZGVkKHZlcnNpb25zW3ByZXZdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZXJzaW9uTHQocHJldiwgY3VyKTtcbiAgICB9O1xuICAgIHJldHVybiBmaW5kVmVyc2lvbihzaGFyZVNjb3BlTWFwW3Njb3BlXVtwa2dOYW1lXSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZ2V0RmluZFNoYXJlRnVuY3Rpb24oc3RyYXRlZ3kpIHtcbiAgICBpZiAoc3RyYXRlZ3kgPT09ICdsb2FkZWQtZmlyc3QnKSB7XG4gICAgICAgIHJldHVybiBmaW5kU2luZ2xldG9uVmVyc2lvbk9yZGVyQnlMb2FkZWQ7XG4gICAgfVxuICAgIHJldHVybiBmaW5kU2luZ2xldG9uVmVyc2lvbk9yZGVyQnlWZXJzaW9uO1xufVxuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFNoYXJlKGxvY2FsU2hhcmVTY29wZU1hcCwgcGtnTmFtZSwgc2hhcmVJbmZvLCByZXNvbHZlU2hhcmUpIHtcbiAgICBpZiAoIWxvY2FsU2hhcmVTY29wZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc2hhcmVDb25maWcsIHNjb3BlID0gREVGQVVMVF9TQ09QRSwgc3RyYXRlZ3kgfSA9IHNoYXJlSW5mbztcbiAgICBjb25zdCBzY29wZXMgPSBBcnJheS5pc0FycmF5KHNjb3BlKSA/IHNjb3BlIDogW1xuICAgICAgICBzY29wZVxuICAgIF07XG4gICAgZm9yIChjb25zdCBzYyBvZiBzY29wZXMpe1xuICAgICAgICBpZiAoc2hhcmVDb25maWcgJiYgbG9jYWxTaGFyZVNjb3BlTWFwW3NjXSAmJiBsb2NhbFNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVpcmVkVmVyc2lvbiB9ID0gc2hhcmVDb25maWc7XG4gICAgICAgICAgICBjb25zdCBmaW5kU2hhcmVGdW5jdGlvbiA9IGdldEZpbmRTaGFyZUZ1bmN0aW9uKHN0cmF0ZWd5KTtcbiAgICAgICAgICAgIGNvbnN0IG1heE9yU2luZ2xldG9uVmVyc2lvbiA9IGZpbmRTaGFyZUZ1bmN0aW9uKGxvY2FsU2hhcmVTY29wZU1hcCwgc2MsIHBrZ05hbWUpO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0UmVzb2x2ZXIgPSAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaGFyZUNvbmZpZy5zaW5nbGV0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZFZlcnNpb24gPT09ICdzdHJpbmcnICYmICFzYXRpc2Z5KG1heE9yU2luZ2xldG9uVmVyc2lvbiwgcmVxdWlyZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYFZlcnNpb24gJHttYXhPclNpbmdsZXRvblZlcnNpb259IGZyb20gJHttYXhPclNpbmdsZXRvblZlcnNpb24gJiYgbG9jYWxTaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVttYXhPclNpbmdsZXRvblZlcnNpb25dLmZyb219IG9mIHNoYXJlZCBzaW5nbGV0b24gbW9kdWxlICR7cGtnTmFtZX0gZG9lcyBub3Qgc2F0aXNmeSB0aGUgcmVxdWlyZW1lbnQgb2YgJHtzaGFyZUluZm8uZnJvbX0gd2hpY2ggbmVlZHMgJHtyZXF1aXJlZFZlcnNpb259KWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVDb25maWcuc3RyaWN0VmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVttYXhPclNpbmdsZXRvblZlcnNpb25dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZFZlcnNpb24gPT09IGZhbHNlIHx8IHJlcXVpcmVkVmVyc2lvbiA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVttYXhPclNpbmdsZXRvblZlcnNpb25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5KG1heE9yU2luZ2xldG9uVmVyc2lvbiwgcmVxdWlyZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV1bbWF4T3JTaW5nbGV0b25WZXJzaW9uXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFt2ZXJzaW9uS2V5LCB2ZXJzaW9uVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGxvY2FsU2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV0pKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5KHZlcnNpb25LZXksIHJlcXVpcmVkVmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBzaGFyZVNjb3BlTWFwOiBsb2NhbFNoYXJlU2NvcGVNYXAsXG4gICAgICAgICAgICAgICAgc2NvcGU6IHNjLFxuICAgICAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogbWF4T3JTaW5nbGV0b25WZXJzaW9uLFxuICAgICAgICAgICAgICAgIEdsb2JhbEZlZGVyYXRpb246IEdsb2JhbC5fX0ZFREVSQVRJT05fXyxcbiAgICAgICAgICAgICAgICByZXNvbHZlcjogZGVmYXVsdFJlc29sdmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZVNoYXJlZCA9IHJlc29sdmVTaGFyZS5lbWl0KHBhcmFtcykgfHwgcGFyYW1zO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVTaGFyZWQucmVzb2x2ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEdsb2JhbFNoYXJlU2NvcGUoKSB7XG4gICAgcmV0dXJuIEdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX1NIQVJFX187XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHBrZ05hbWUsIGV4dHJhT3B0aW9ucywgc2hhcmVJbmZvcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkZWZhdWx0UmVzb2x2ZXIgPSAoc2hhcmVkT3B0aW9ucyk9PntcbiAgICAgICAgaWYgKCFzaGFyZWRPcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNoYXJlVmVyc2lvbk1hcCA9IHt9O1xuICAgICAgICBzaGFyZWRPcHRpb25zLmZvckVhY2goKHNoYXJlZCk9PntcbiAgICAgICAgICAgIHNoYXJlVmVyc2lvbk1hcFtzaGFyZWQudmVyc2lvbl0gPSBzaGFyZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgICAgICAgICAgcmV0dXJuICFpc0xvYWRlZChzaGFyZVZlcnNpb25NYXBbcHJldl0pICYmIHZlcnNpb25MdChwcmV2LCBjdXIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXhWZXJzaW9uID0gZmluZFZlcnNpb24oc2hhcmVWZXJzaW9uTWFwLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBzaGFyZVZlcnNpb25NYXBbbWF4VmVyc2lvbl07XG4gICAgfTtcbiAgICB2YXIgX2V4dHJhT3B0aW9uc19yZXNvbHZlcjtcbiAgICBjb25zdCByZXNvbHZlciA9IChfZXh0cmFPcHRpb25zX3Jlc29sdmVyID0gZXh0cmFPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBleHRyYU9wdGlvbnMucmVzb2x2ZXIpICE9IG51bGwgPyBfZXh0cmFPcHRpb25zX3Jlc29sdmVyIDogZGVmYXVsdFJlc29sdmVyO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZXNvbHZlcihzaGFyZUluZm9zW3BrZ05hbWVdKSwgZXh0cmFPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBleHRyYU9wdGlvbnMuY3VzdG9tU2hhcmVJbmZvKTtcbn1cblxuZnVuY3Rpb24gZ2V0QnVpbGRlcklkKCkge1xuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJldHVybiB0eXBlb2YgRkVERVJBVElPTl9CVUlMRF9JREVOVElGSUVSICE9PSAndW5kZWZpbmVkJyA/IEZFREVSQVRJT05fQlVJTERfSURFTlRJRklFUiA6ICcnO1xufVxuXG4vLyBGdW5jdGlvbiB0byBtYXRjaCBhIHJlbW90ZSB3aXRoIGl0cyBuYW1lIGFuZCBleHBvc2Vcbi8vIGlkOiBwa2dOYW1lKEBmZWRlcmF0aW9uL2FwcDEpICsgZXhwb3NlKGJ1dHRvbikgPSBAZmVkZXJhdGlvbi9hcHAxL2J1dHRvblxuLy8gaWQ6IGFsaWFzKGFwcDEpICsgZXhwb3NlKGJ1dHRvbikgPSBhcHAxL2J1dHRvblxuLy8gaWQ6IGFsaWFzKGFwcDEvdXRpbHMpICsgZXhwb3NlKGxvYWRhc2gvc29ydCkgPSBhcHAxL3V0aWxzL2xvYWRhc2gvc29ydFxuZnVuY3Rpb24gbWF0Y2hSZW1vdGVXaXRoTmFtZUFuZEV4cG9zZShyZW1vdGVzLCBpZCkge1xuICAgIGZvciAoY29uc3QgcmVtb3RlIG9mIHJlbW90ZXMpe1xuICAgICAgICAvLyBtYXRjaCBwa2dOYW1lXG4gICAgICAgIGNvbnN0IGlzTmFtZU1hdGNoZWQgPSBpZC5zdGFydHNXaXRoKHJlbW90ZS5uYW1lKTtcbiAgICAgICAgbGV0IGV4cG9zZSA9IGlkLnJlcGxhY2UocmVtb3RlLm5hbWUsICcnKTtcbiAgICAgICAgaWYgKGlzTmFtZU1hdGNoZWQpIHtcbiAgICAgICAgICAgIGlmIChleHBvc2Uuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGtnTmFtZU9yQWxpYXMgPSByZW1vdGUubmFtZTtcbiAgICAgICAgICAgICAgICBleHBvc2UgPSBgLiR7ZXhwb3NlfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGtnTmFtZU9yQWxpYXMsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwb3NlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBrZ05hbWVPckFsaWFzOiByZW1vdGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlOiAnLicsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWF0Y2ggYWxpYXNcbiAgICAgICAgY29uc3QgaXNBbGlhc01hdGNoZWQgPSByZW1vdGUuYWxpYXMgJiYgaWQuc3RhcnRzV2l0aChyZW1vdGUuYWxpYXMpO1xuICAgICAgICBsZXQgZXhwb3NlV2l0aEFsaWFzID0gcmVtb3RlLmFsaWFzICYmIGlkLnJlcGxhY2UocmVtb3RlLmFsaWFzLCAnJyk7XG4gICAgICAgIGlmIChyZW1vdGUuYWxpYXMgJiYgaXNBbGlhc01hdGNoZWQpIHtcbiAgICAgICAgICAgIGlmIChleHBvc2VXaXRoQWxpYXMgJiYgZXhwb3NlV2l0aEFsaWFzLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBrZ05hbWVPckFsaWFzID0gcmVtb3RlLmFsaWFzO1xuICAgICAgICAgICAgICAgIGV4cG9zZVdpdGhBbGlhcyA9IGAuJHtleHBvc2VXaXRoQWxpYXN9YDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhcyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlOiBleHBvc2VXaXRoQWxpYXMsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cG9zZVdpdGhBbGlhcyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhczogcmVtb3RlLmFsaWFzLFxuICAgICAgICAgICAgICAgICAgICBleHBvc2U6ICcuJyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG4vLyBGdW5jdGlvbiB0byBtYXRjaCBhIHJlbW90ZSB3aXRoIGl0cyBuYW1lIG9yIGFsaWFzXG5mdW5jdGlvbiBtYXRjaFJlbW90ZShyZW1vdGVzLCBuYW1lT3JBbGlhcykge1xuICAgIGZvciAoY29uc3QgcmVtb3RlIG9mIHJlbW90ZXMpe1xuICAgICAgICBjb25zdCBpc05hbWVNYXRjaGVkID0gbmFtZU9yQWxpYXMgPT09IHJlbW90ZS5uYW1lO1xuICAgICAgICBpZiAoaXNOYW1lTWF0Y2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0FsaWFzTWF0Y2hlZCA9IHJlbW90ZS5hbGlhcyAmJiBuYW1lT3JBbGlhcyA9PT0gcmVtb3RlLmFsaWFzO1xuICAgICAgICBpZiAoaXNBbGlhc01hdGNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZW1vdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclBsdWdpbnMocGx1Z2lucywgaW5zdGFuY2UpIHtcbiAgICBjb25zdCBnbG9iYWxQbHVnaW5zID0gZ2V0R2xvYmFsSG9zdFBsdWdpbnMoKTtcbiAgICBjb25zdCBob29rSW5zdGFuY2VzID0gW1xuICAgICAgICBpbnN0YW5jZS5ob29rcyxcbiAgICAgICAgaW5zdGFuY2UucmVtb3RlSGFuZGxlci5ob29rcyxcbiAgICAgICAgaW5zdGFuY2Uuc2hhcmVkSGFuZGxlci5ob29rcyxcbiAgICAgICAgaW5zdGFuY2Uuc25hcHNob3RIYW5kbGVyLmhvb2tzLFxuICAgICAgICBpbnN0YW5jZS5sb2FkZXJIb29rLFxuICAgICAgICBpbnN0YW5jZS5icmlkZ2VIb29rXG4gICAgXTtcbiAgICAvLyBJbmNvcnBvcmF0ZSBnbG9iYWwgcGx1Z2luc1xuICAgIGlmIChnbG9iYWxQbHVnaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZ2xvYmFsUGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pPT57XG4gICAgICAgICAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5maW5kKChpdGVtKT0+aXRlbS5uYW1lICE9PSBwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwbHVnaW5zICYmIHBsdWdpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbik9PntcbiAgICAgICAgICAgIGhvb2tJbnN0YW5jZXMuZm9yRWFjaCgoaG9va0luc3RhbmNlKT0+e1xuICAgICAgICAgICAgICAgIGhvb2tJbnN0YW5jZS5hcHBseVBsdWdpbihwbHVnaW4sIGluc3RhbmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBsdWdpbnM7XG59XG5cbmNvbnN0IGltcG9ydENhbGxiYWNrID0gJy50aGVuKGNhbGxiYWNrc1swXSkuY2F0Y2goY2FsbGJhY2tzWzFdKSc7XG5hc3luYyBmdW5jdGlvbiBsb2FkRXNtRW50cnkoeyBlbnRyeSwgcmVtb3RlRW50cnlFeHBvcnRzIH0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghcmVtb3RlRW50cnlFeHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBGRURFUkFUSU9OX0FMTE9XX05FV19GVU5DVElPTiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKCdjYWxsYmFja3MnLCBgaW1wb3J0KFwiJHtlbnRyeX1cIikke2ltcG9ydENhbGxiYWNrfWApKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gLyogQHZpdGUtaWdub3JlICovIGVudHJ5KS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlbW90ZUVudHJ5RXhwb3J0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFN5c3RlbUpzRW50cnkoeyBlbnRyeSwgcmVtb3RlRW50cnlFeHBvcnRzIH0pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghcmVtb3RlRW50cnlFeHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfX3N5c3RlbV9jb250ZXh0X18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBTeXN0ZW0uaW1wb3J0KGVudHJ5KS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKCdjYWxsYmFja3MnLCBgU3lzdGVtLmltcG9ydChcIiR7ZW50cnl9XCIpJHtpbXBvcnRDYWxsYmFja31gKShbXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZW1vdGVFbnRyeUV4cG9ydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVJlbW90ZUVudHJ5TG9hZGVkKG5hbWUsIGdsb2JhbE5hbWUsIGVudHJ5KSB7XG4gICAgY29uc3QgeyByZW1vdGVFbnRyeUtleSwgZW50cnlFeHBvcnRzIH0gPSBnZXRSZW1vdGVFbnRyeUV4cG9ydHMobmFtZSwgZ2xvYmFsTmFtZSk7XG4gICAgYXNzZXJ0KGVudHJ5RXhwb3J0cywgZ2V0U2hvcnRFcnJvck1zZyhSVU5USU1FXzAwMSwgcnVudGltZURlc2NNYXAsIHtcbiAgICAgICAgcmVtb3RlTmFtZTogbmFtZSxcbiAgICAgICAgcmVtb3RlRW50cnlVcmw6IGVudHJ5LFxuICAgICAgICByZW1vdGVFbnRyeUtleVxuICAgIH0pKTtcbiAgICByZXR1cm4gZW50cnlFeHBvcnRzO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEVudHJ5U2NyaXB0KHsgbmFtZSwgZ2xvYmFsTmFtZSwgZW50cnksIGxvYWRlckhvb2sgfSkge1xuICAgIGNvbnN0IHsgZW50cnlFeHBvcnRzOiByZW1vdGVFbnRyeUV4cG9ydHMgfSA9IGdldFJlbW90ZUVudHJ5RXhwb3J0cyhuYW1lLCBnbG9iYWxOYW1lKTtcbiAgICBpZiAocmVtb3RlRW50cnlFeHBvcnRzKSB7XG4gICAgICAgIHJldHVybiByZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgfVxuICAgIHJldHVybiBsb2FkU2NyaXB0KGVudHJ5LCB7XG4gICAgICAgIGF0dHJzOiB7fSxcbiAgICAgICAgY3JlYXRlU2NyaXB0SG9vazogKHVybCwgYXR0cnMpPT57XG4gICAgICAgICAgICBjb25zdCByZXMgPSBsb2FkZXJIb29rLmxpZmVjeWNsZS5jcmVhdGVTY3JpcHQuZW1pdCh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGF0dHJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzKSByZXR1cm47XG4gICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgSFRNTFNjcmlwdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdzY3JpcHQnIGluIHJlcyB8fCAndGltZW91dCcgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pLnRoZW4oKCk9PntcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlbW90ZUVudHJ5TG9hZGVkKG5hbWUsIGdsb2JhbE5hbWUsIGVudHJ5KTtcbiAgICB9KS5jYXRjaCgoZSk9PntcbiAgICAgICAgYXNzZXJ0KHVuZGVmaW5lZCwgZ2V0U2hvcnRFcnJvck1zZyhSVU5USU1FXzAwOCwgcnVudGltZURlc2NNYXAsIHtcbiAgICAgICAgICAgIHJlbW90ZU5hbWU6IG5hbWUsXG4gICAgICAgICAgICByZXNvdXJjZVVybDogZW50cnlcbiAgICAgICAgfSkpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEVudHJ5RG9tKHsgcmVtb3RlSW5mbywgcmVtb3RlRW50cnlFeHBvcnRzLCBsb2FkZXJIb29rIH0pIHtcbiAgICBjb25zdCB7IGVudHJ5LCBlbnRyeUdsb2JhbE5hbWU6IGdsb2JhbE5hbWUsIG5hbWUsIHR5cGUgfSA9IHJlbW90ZUluZm87XG4gICAgc3dpdGNoKHR5cGUpe1xuICAgICAgICBjYXNlICdlc20nOlxuICAgICAgICBjYXNlICdtb2R1bGUnOlxuICAgICAgICAgICAgcmV0dXJuIGxvYWRFc21FbnRyeSh7XG4gICAgICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAnc3lzdGVtJzpcbiAgICAgICAgICAgIHJldHVybiBsb2FkU3lzdGVtSnNFbnRyeSh7XG4gICAgICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBsb2FkRW50cnlTY3JpcHQoe1xuICAgICAgICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgICAgICAgIGdsb2JhbE5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBsb2FkZXJIb29rXG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkRW50cnlOb2RlKHsgcmVtb3RlSW5mbywgbG9hZGVySG9vayB9KSB7XG4gICAgY29uc3QgeyBlbnRyeSwgZW50cnlHbG9iYWxOYW1lOiBnbG9iYWxOYW1lLCBuYW1lLCB0eXBlIH0gPSByZW1vdGVJbmZvO1xuICAgIGNvbnN0IHsgZW50cnlFeHBvcnRzOiByZW1vdGVFbnRyeUV4cG9ydHMgfSA9IGdldFJlbW90ZUVudHJ5RXhwb3J0cyhuYW1lLCBnbG9iYWxOYW1lKTtcbiAgICBpZiAocmVtb3RlRW50cnlFeHBvcnRzKSB7XG4gICAgICAgIHJldHVybiByZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgfVxuICAgIHJldHVybiBsb2FkU2NyaXB0Tm9kZShlbnRyeSwge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGdsb2JhbE5hbWUsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgIH0sXG4gICAgICAgIGxvYWRlckhvb2s6IHtcbiAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2s6ICh1cmwsIGF0dHJzID0ge30pPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gbG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlU2NyaXB0LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoJ3VybCcgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLnRoZW4oKCk9PntcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlbW90ZUVudHJ5TG9hZGVkKG5hbWUsIGdsb2JhbE5hbWUsIGVudHJ5KTtcbiAgICB9KS5jYXRjaCgoZSk9PntcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KHJlbW90ZUluZm8pIHtcbiAgICBjb25zdCB7IGVudHJ5LCBuYW1lIH0gPSByZW1vdGVJbmZvO1xuICAgIHJldHVybiBjb21wb3NlS2V5V2l0aFNlcGFyYXRvcihuYW1lLCBlbnRyeSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZW1vdGVFbnRyeSh7IG9yaWdpbiwgcmVtb3RlRW50cnlFeHBvcnRzLCByZW1vdGVJbmZvIH0pIHtcbiAgICBjb25zdCB1bmlxdWVLZXkgPSBnZXRSZW1vdGVFbnRyeVVuaXF1ZUtleShyZW1vdGVJbmZvKTtcbiAgICBpZiAocmVtb3RlRW50cnlFeHBvcnRzKSB7XG4gICAgICAgIHJldHVybiByZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgfVxuICAgIGlmICghZ2xvYmFsTG9hZGluZ1t1bmlxdWVLZXldKSB7XG4gICAgICAgIGNvbnN0IGxvYWRFbnRyeUhvb2sgPSBvcmlnaW4ucmVtb3RlSGFuZGxlci5ob29rcy5saWZlY3ljbGUubG9hZEVudHJ5O1xuICAgICAgICBjb25zdCBsb2FkZXJIb29rID0gb3JpZ2luLmxvYWRlckhvb2s7XG4gICAgICAgIGdsb2JhbExvYWRpbmdbdW5pcXVlS2V5XSA9IGxvYWRFbnRyeUhvb2suZW1pdCh7XG4gICAgICAgICAgICBsb2FkZXJIb29rLFxuICAgICAgICAgICAgcmVtb3RlSW5mbyxcbiAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0c1xuICAgICAgICB9KS50aGVuKChyZXMpPT57XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVzZSBFTlZfVEFSR0VUIGlmIGRlZmluZWQsIG90aGVyd2lzZSBmYWxsYmFjayB0byBpc0Jyb3dzZXJFbnYsIG11c3Qga2VlcCB0aGlzXG4gICAgICAgICAgICBjb25zdCBpc1dlYkVudmlyb25tZW50ID0gdHlwZW9mIEVOVl9UQVJHRVQgIT09ICd1bmRlZmluZWQnID8gRU5WX1RBUkdFVCA9PT0gJ3dlYicgOiBpc0Jyb3dzZXJFbnYoKTtcbiAgICAgICAgICAgIHJldHVybiBpc1dlYkVudmlyb25tZW50ID8gbG9hZEVudHJ5RG9tKHtcbiAgICAgICAgICAgICAgICByZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0cyxcbiAgICAgICAgICAgICAgICBsb2FkZXJIb29rXG4gICAgICAgICAgICB9KSA6IGxvYWRFbnRyeU5vZGUoe1xuICAgICAgICAgICAgICAgIHJlbW90ZUluZm8sXG4gICAgICAgICAgICAgICAgbG9hZGVySG9va1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsTG9hZGluZ1t1bmlxdWVLZXldO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3RlSW5mbyhyZW1vdGUpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJlbW90ZSwge1xuICAgICAgICBlbnRyeTogJ2VudHJ5JyBpbiByZW1vdGUgPyByZW1vdGUuZW50cnkgOiAnJyxcbiAgICAgICAgdHlwZTogcmVtb3RlLnR5cGUgfHwgREVGQVVMVF9SRU1PVEVfVFlQRSxcbiAgICAgICAgZW50cnlHbG9iYWxOYW1lOiByZW1vdGUuZW50cnlHbG9iYWxOYW1lIHx8IHJlbW90ZS5uYW1lLFxuICAgICAgICBzaGFyZVNjb3BlOiByZW1vdGUuc2hhcmVTY29wZSB8fCBERUZBVUxUX1NDT1BFXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVsb2FkQXJncyhwcmVsb2FkQ29uZmlnKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgcmVzb3VyY2VDYXRlZ29yeTogJ3N5bmMnLFxuICAgICAgICBzaGFyZTogdHJ1ZSxcbiAgICAgICAgZGVwc1JlbW90ZTogdHJ1ZSxcbiAgICAgICAgcHJlZmV0Y2hJbnRlcmZhY2U6IGZhbHNlXG4gICAgfSwgcHJlbG9hZENvbmZpZyk7XG59XG5mdW5jdGlvbiBmb3JtYXRQcmVsb2FkQXJncyhyZW1vdGVzLCBwcmVsb2FkQXJncykge1xuICAgIHJldHVybiBwcmVsb2FkQXJncy5tYXAoKGFyZ3MpPT57XG4gICAgICAgIGNvbnN0IHJlbW90ZUluZm8gPSBtYXRjaFJlbW90ZShyZW1vdGVzLCBhcmdzLm5hbWVPckFsaWFzKTtcbiAgICAgICAgYXNzZXJ0KHJlbW90ZUluZm8sIGBVbmFibGUgdG8gcHJlbG9hZCAke2FyZ3MubmFtZU9yQWxpYXN9IGFzIGl0IGlzIG5vdCBpbmNsdWRlZCBpbiAkeyFyZW1vdGVJbmZvICYmIHNhZmVUb1N0cmluZyh7XG4gICAgICAgICAgICByZW1vdGVJbmZvLFxuICAgICAgICAgICAgcmVtb3Rlc1xuICAgICAgICB9KX1gKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbW90ZTogcmVtb3RlSW5mbyxcbiAgICAgICAgICAgIHByZWxvYWRDb25maWc6IGRlZmF1bHRQcmVsb2FkQXJncyhhcmdzKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJlbG9hZEV4cG9zZXMoZXhwb3Nlcykge1xuICAgIGlmICghZXhwb3Nlcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBleHBvc2VzLm1hcCgoZXhwb3NlKT0+e1xuICAgICAgICBpZiAoZXhwb3NlID09PSAnLicpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9zZS5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3NlLnJlcGxhY2UoJy4vJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBvc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcmVsb2FkQXNzZXRzKHJlbW90ZUluZm8sIGhvc3QsIGFzc2V0cywgLy8gSXQgaXMgdXNlZCB0byBkaXN0aW5ndWlzaCBwcmVsb2FkIGZyb20gbG9hZCByZW1vdGUgcGFyYWxsZWwgbG9hZGluZ1xudXNlTGlua1ByZWxvYWQgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBjc3NBc3NldHMsIGpzQXNzZXRzV2l0aG91dEVudHJ5LCBlbnRyeUFzc2V0cyB9ID0gYXNzZXRzO1xuICAgIGlmIChob3N0Lm9wdGlvbnMuaW5Ccm93c2VyKSB7XG4gICAgICAgIGVudHJ5QXNzZXRzLmZvckVhY2goKGFzc2V0KT0+e1xuICAgICAgICAgICAgY29uc3QgeyBtb2R1bGVJbmZvIH0gPSBhc3NldDtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IGhvc3QubW9kdWxlQ2FjaGUuZ2V0KHJlbW90ZUluZm8ubmFtZSk7XG4gICAgICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgZ2V0UmVtb3RlRW50cnkoe1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3QsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUluZm86IG1vZHVsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0czogbW9kdWxlLnJlbW90ZUVudHJ5RXhwb3J0c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRSZW1vdGVFbnRyeSh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSW5mbzogbW9kdWxlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VMaW5rUHJlbG9hZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdEF0dHJzID0ge1xuICAgICAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgICAgIGFzOiAnc3R5bGUnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3NzQXNzZXRzLmZvckVhY2goKGNzc1VybCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxpbms6IGNzc0VsLCBuZWVkQXR0YWNoIH0gPSBjcmVhdGVMaW5rKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjc3NVcmwsXG4gICAgICAgICAgICAgICAgICAgIGNiOiAoKT0+e1xuICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBkZWZhdWx0QXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUxpbmtIb29rOiAodXJsLCBhdHRycyk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGhvc3QubG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlTGluay5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIEhUTUxMaW5rRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoY3NzRWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0QXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgcmVsOiAnc3R5bGVzaGVldCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQvY3NzJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNzc0Fzc2V0cy5mb3JFYWNoKChjc3NVcmwpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsaW5rOiBjc3NFbCwgbmVlZEF0dGFjaCB9ID0gY3JlYXRlTGluayh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogY3NzVXJsLFxuICAgICAgICAgICAgICAgICAgICBjYjogKCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogZGVmYXVsdEF0dHJzLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVMaW5rSG9vazogKHVybCwgYXR0cnMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBob3N0LmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZUxpbmsuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBuZWVkRGVsZXRlTGluazogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoY3NzRWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZUxpbmtQcmVsb2FkKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0QXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgcmVsOiAncHJlbG9hZCcsXG4gICAgICAgICAgICAgICAgYXM6ICdzY3JpcHQnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAganNBc3NldHNXaXRob3V0RW50cnkuZm9yRWFjaCgoanNVcmwpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsaW5rOiBsaW5rRWwsIG5lZWRBdHRhY2ggfSA9IGNyZWF0ZUxpbmsoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGpzVXJsLFxuICAgICAgICAgICAgICAgICAgICBjYjogKCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogZGVmYXVsdEF0dHJzLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVMaW5rSG9vazogKHVybCwgYXR0cnMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBob3N0LmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZUxpbmsuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmtFbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRBdHRycyA9IHtcbiAgICAgICAgICAgICAgICBmZXRjaHByaW9yaXR5OiAnaGlnaCcsXG4gICAgICAgICAgICAgICAgdHlwZTogKHJlbW90ZUluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IHJlbW90ZUluZm8udHlwZSkgPT09ICdtb2R1bGUnID8gJ21vZHVsZScgOiAndGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGpzQXNzZXRzV2l0aG91dEVudHJ5LmZvckVhY2goKGpzVXJsKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NyaXB0OiBzY3JpcHRFbCwgbmVlZEF0dGFjaCB9ID0gY3JlYXRlU2NyaXB0KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBqc1VybCxcbiAgICAgICAgICAgICAgICAgICAgY2I6ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IGRlZmF1bHRBdHRycyxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2NyaXB0SG9vazogKHVybCwgYXR0cnMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBob3N0LmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZVNjcmlwdC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIEhUTUxTY3JpcHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbmVlZERlbGV0ZVNjcmlwdDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5lZWRBdHRhY2ggJiYgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgU2hhcmVVdGlscyA9IHtcbiAgICBnZXRSZWdpc3RlcmVkU2hhcmUsXG4gICAgZ2V0R2xvYmFsU2hhcmVTY29wZVxufTtcbmNvbnN0IEdsb2JhbFV0aWxzID0ge1xuICAgIEdsb2JhbCxcbiAgICBuYXRpdmVHbG9iYWwsXG4gICAgcmVzZXRGZWRlcmF0aW9uR2xvYmFsSW5mbyxcbiAgICBzZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UsXG4gICAgZ2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yLFxuICAgIHNldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvcixcbiAgICBnZXRJbmZvV2l0aG91dFR5cGUsXG4gICAgZ2V0R2xvYmFsU25hcHNob3QsXG4gICAgZ2V0VGFyZ2V0U25hcHNob3RJbmZvQnlNb2R1bGVJbmZvLFxuICAgIGdldEdsb2JhbFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyxcbiAgICBzZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8sXG4gICAgYWRkR2xvYmFsU25hcHNob3QsXG4gICAgZ2V0UmVtb3RlRW50cnlFeHBvcnRzLFxuICAgIHJlZ2lzdGVyR2xvYmFsUGx1Z2lucyxcbiAgICBnZXRHbG9iYWxIb3N0UGx1Z2lucyxcbiAgICBnZXRQcmVsb2FkZWQsXG4gICAgc2V0UHJlbG9hZGVkXG59O1xudmFyIGhlbHBlcnMgPSB7XG4gICAgZ2xvYmFsOiBHbG9iYWxVdGlscyxcbiAgICBzaGFyZTogU2hhcmVVdGlscyxcbiAgICB1dGlsczoge1xuICAgICAgICBtYXRjaFJlbW90ZVdpdGhOYW1lQW5kRXhwb3NlLFxuICAgICAgICBwcmVsb2FkQXNzZXRzLFxuICAgICAgICBnZXRSZW1vdGVJbmZvXG4gICAgfVxufTtcblxubGV0IE1vZHVsZSA9IGNsYXNzIE1vZHVsZSB7XG4gICAgYXN5bmMgZ2V0RW50cnkoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRW50cnlFeHBvcnRzO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHMgPSBhd2FpdCBnZXRSZW1vdGVFbnRyeSh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiB0aGlzLmhvc3QsXG4gICAgICAgICAgICAgICAgcmVtb3RlSW5mbzogdGhpcy5yZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0czogdGhpcy5yZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KHRoaXMucmVtb3RlSW5mbyk7XG4gICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHMgPSBhd2FpdCB0aGlzLmhvc3QubG9hZGVySG9vay5saWZlY3ljbGUubG9hZEVudHJ5RXJyb3IuZW1pdCh7XG4gICAgICAgICAgICAgICAgZ2V0UmVtb3RlRW50cnksXG4gICAgICAgICAgICAgICAgb3JpZ2luOiB0aGlzLmhvc3QsXG4gICAgICAgICAgICAgICAgcmVtb3RlSW5mbzogdGhpcy5yZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0czogdGhpcy5yZW1vdGVFbnRyeUV4cG9ydHMsXG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9hZGluZyxcbiAgICAgICAgICAgICAgICB1bmlxdWVLZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChyZW1vdGVFbnRyeUV4cG9ydHMsIGByZW1vdGVFbnRyeUV4cG9ydHMgaXMgdW5kZWZpbmVkIFxcbiAke3NhZmVUb1N0cmluZyh0aGlzLnJlbW90ZUluZm8pfWApO1xuICAgICAgICB0aGlzLnJlbW90ZUVudHJ5RXhwb3J0cyA9IHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRW50cnlFeHBvcnRzO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuICAgIGFzeW5jIGdldChpZCwgZXhwb3NlLCBvcHRpb25zLCByZW1vdGVTbmFwc2hvdCkge1xuICAgICAgICBjb25zdCB7IGxvYWRGYWN0b3J5ID0gdHJ1ZSB9ID0gb3B0aW9ucyB8fCB7XG4gICAgICAgICAgICBsb2FkRmFjdG9yeTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICAvLyBHZXQgcmVtb3RlRW50cnkuanNcbiAgICAgICAgY29uc3QgcmVtb3RlRW50cnlFeHBvcnRzID0gYXdhaXQgdGhpcy5nZXRFbnRyeSgpO1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGVkKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNoYXJlU2NvcGVNYXAgPSB0aGlzLmhvc3Quc2hhcmVTY29wZU1hcDtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlU2NvcGVLZXlzID0gQXJyYXkuaXNBcnJheSh0aGlzLnJlbW90ZUluZm8uc2hhcmVTY29wZSkgPyB0aGlzLnJlbW90ZUluZm8uc2hhcmVTY29wZSA6IFtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW90ZUluZm8uc2hhcmVTY29wZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICghc2hhcmVTY29wZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVTY29wZUtleXMucHVzaCgnZGVmYXVsdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcmVTY29wZUtleXMuZm9yRWFjaCgoc2hhcmVTY29wZUtleSk9PntcbiAgICAgICAgICAgICAgICBpZiAoIWxvY2FsU2hhcmVTY29wZU1hcFtzaGFyZVNjb3BlS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNoYXJlU2NvcGVNYXBbc2hhcmVTY29wZUtleV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRPRE86IGNvbXBhdGUgbGVnYWN5IGluaXQgcGFyYW1zLCBzaG91bGQgdXNlIHNoYXJlU2NvcGVNYXAgaWYgZXhpc3RcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlU2NvcGUgPSBsb2NhbFNoYXJlU2NvcGVNYXBbc2hhcmVTY29wZUtleXNbMF1dO1xuICAgICAgICAgICAgY29uc3QgaW5pdFNjb3BlID0gW107XG4gICAgICAgICAgICBjb25zdCByZW1vdGVFbnRyeUluaXRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IHRoaXMucmVtb3RlSW5mby52ZXJzaW9uIHx8ICcnLFxuICAgICAgICAgICAgICAgIHNoYXJlU2NvcGVLZXlzOiBBcnJheS5pc0FycmF5KHRoaXMucmVtb3RlSW5mby5zaGFyZVNjb3BlKSA/IHNoYXJlU2NvcGVLZXlzIDogdGhpcy5yZW1vdGVJbmZvLnNoYXJlU2NvcGUgfHwgJ2RlZmF1bHQnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gSGVscCB0byBmaW5kIGhvc3QgaW5zdGFuY2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW1vdGVFbnRyeUluaXRPcHRpb25zLCAnc2hhcmVTY29wZU1hcCcsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbG9jYWxTaGFyZVNjb3BlTWFwLFxuICAgICAgICAgICAgICAgIC8vIHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMgd2lsbCBiZSB0cmF2ZXJzZWQgYW5kIGFzc2lnbmVkIGR1cmluZyBjb250YWluZXIgaW5pdCwgLHNvIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBhbGxvd2VkIHRvIGJlIHRyYXZlcnNlZFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRDb250YWluZXJPcHRpb25zID0gYXdhaXQgdGhpcy5ob3N0Lmhvb2tzLmxpZmVjeWNsZS5iZWZvcmVJbml0Q29udGFpbmVyLmVtaXQoe1xuICAgICAgICAgICAgICAgIHNoYXJlU2NvcGUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzaGFyZVNjb3BlTWFwIHdpbGwgYmUgc2V0IGJ5IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaW5pdFNjb3BlLFxuICAgICAgICAgICAgICAgIHJlbW90ZUluZm86IHRoaXMucmVtb3RlSW5mbyxcbiAgICAgICAgICAgICAgICBvcmlnaW46IHRoaXMuaG9zdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChyZW1vdGVFbnRyeUV4cG9ydHMgPT0gbnVsbCA/IHZvaWQgMCA6IHJlbW90ZUVudHJ5RXhwb3J0cy5pbml0KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihnZXRTaG9ydEVycm9yTXNnKFJVTlRJTUVfMDAyLCBydW50aW1lRGVzY01hcCwge1xuICAgICAgICAgICAgICAgICAgICBob3N0TmFtZTogdGhpcy5ob3N0Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZU5hbWU6IHRoaXMucmVtb3RlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVFbnRyeVVybDogdGhpcy5yZW1vdGVJbmZvLmVudHJ5LFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUtleTogdGhpcy5yZW1vdGVJbmZvLmVudHJ5R2xvYmFsTmFtZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHJlbW90ZUVudHJ5RXhwb3J0cy5pbml0KGluaXRDb250YWluZXJPcHRpb25zLnNoYXJlU2NvcGUsIGluaXRDb250YWluZXJPcHRpb25zLmluaXRTY29wZSwgaW5pdENvbnRhaW5lck9wdGlvbnMucmVtb3RlRW50cnlJbml0T3B0aW9ucyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmhvc3QuaG9va3MubGlmZWN5Y2xlLmluaXRDb250YWluZXIuZW1pdChfZXh0ZW5kcyh7fSwgaW5pdENvbnRhaW5lck9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpYiA9IHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICAgICAgdGhpcy5pbml0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbW9kdWxlRmFjdG9yeTtcbiAgICAgICAgbW9kdWxlRmFjdG9yeSA9IGF3YWl0IHRoaXMuaG9zdC5sb2FkZXJIb29rLmxpZmVjeWNsZS5nZXRNb2R1bGVGYWN0b3J5LmVtaXQoe1xuICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzLFxuICAgICAgICAgICAgZXhwb3NlLFxuICAgICAgICAgICAgbW9kdWxlSW5mbzogdGhpcy5yZW1vdGVJbmZvXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBnZXQgZXhwb3NlR2V0dGVyXG4gICAgICAgIGlmICghbW9kdWxlRmFjdG9yeSkge1xuICAgICAgICAgICAgbW9kdWxlRmFjdG9yeSA9IGF3YWl0IHJlbW90ZUVudHJ5RXhwb3J0cy5nZXQoZXhwb3NlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQobW9kdWxlRmFjdG9yeSwgYCR7Z2V0Rk1JZCh0aGlzLnJlbW90ZUluZm8pfSByZW1vdGUgZG9uJ3QgZXhwb3J0ICR7ZXhwb3NlfS5gKTtcbiAgICAgICAgLy8ga2VlcCBzeW1ib2wgZm9yIG1vZHVsZSBuYW1lIGFsd2F5cyBvbmUgZm9ybWF0XG4gICAgICAgIGNvbnN0IHN5bWJvbE5hbWUgPSBwcm9jZXNzTW9kdWxlQWxpYXModGhpcy5yZW1vdGVJbmZvLm5hbWUsIGV4cG9zZSk7XG4gICAgICAgIGNvbnN0IHdyYXBNb2R1bGVGYWN0b3J5ID0gdGhpcy53cmFwZXJGYWN0b3J5KG1vZHVsZUZhY3RvcnksIHN5bWJvbE5hbWUpO1xuICAgICAgICBpZiAoIWxvYWRGYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcE1vZHVsZUZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwb3NlQ29udGVudCA9IGF3YWl0IHdyYXBNb2R1bGVGYWN0b3J5KCk7XG4gICAgICAgIHJldHVybiBleHBvc2VDb250ZW50O1xuICAgIH1cbiAgICB3cmFwZXJGYWN0b3J5KG1vZHVsZUZhY3RvcnksIGlkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGRlZmluZU1vZHVsZUlkKHJlcywgaWQpIHtcbiAgICAgICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShyZXMpICYmICFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHJlcywgU3ltYm9sLmZvcignbWZfbW9kdWxlX2lkJykpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcywgU3ltYm9sLmZvcignbWZfbW9kdWxlX2lkJyksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb2R1bGVGYWN0b3J5IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgbW9kdWxlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcGFyYW1ldGVyIGlzIHVzZWQgZm9yIGJyaWRnZSBkZWJ1Z2dpbmdcbiAgICAgICAgICAgICAgICBkZWZpbmVNb2R1bGVJZChyZXMsIGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IG1vZHVsZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIGZvciBicmlkZ2UgZGVidWdnaW5nXG4gICAgICAgICAgICAgICAgZGVmaW5lTW9kdWxlSWQocmVzLCBpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyByZW1vdGVJbmZvLCBob3N0IH0pe1xuICAgICAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpYiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZW1vdGVJbmZvID0gcmVtb3RlSW5mbztcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB9XG59O1xuXG5jbGFzcyBTeW5jSG9vayB7XG4gICAgb24oZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuYWRkKGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbmNlKGZuKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5vbihmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlKHdyYXBwZXIpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtaXQoLi4uZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChmbik9PntcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbiguLi5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlbW92ZShmbikge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUoZm4pO1xuICAgIH1cbiAgICByZW1vdmVBbGwoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHR5cGUpe1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBc3luY0hvb2sgZXh0ZW5kcyBTeW5jSG9vayB7XG4gICAgZW1pdCguLi5kYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGxzID0gQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVycyk7XG4gICAgICAgIGlmIChscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBjb25zdCBjYWxsID0gKHByZXYpPT57XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gQWJvcnQgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxzW2krK10uYXBwbHkobnVsbCwgZGF0YSkpLnRoZW4oY2FsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gY2hlY2tSZXR1cm5EYXRhKG9yaWdpbmFsRGF0YSwgcmV0dXJuZWREYXRhKSB7XG4gICAgaWYgKCFpc09iamVjdChyZXR1cm5lZERhdGEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbmFsRGF0YSAhPT0gcmV0dXJuZWREYXRhKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBmb3IoY29uc3Qga2V5IGluIG9yaWdpbmFsRGF0YSl7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gcmV0dXJuZWREYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFN5bmNXYXRlcmZhbGxIb29rIGV4dGVuZHMgU3luY0hvb2sge1xuICAgIGVtaXQoZGF0YSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICBlcnJvcihgVGhlIGRhdGEgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIGhvb2sgc2hvdWxkIGJlIGFuIG9iamVjdC5gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMubGlzdGVuZXJzKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcERhdGEgPSBmbihkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tSZXR1cm5EYXRhKGRhdGEsIHRlbXBEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGVtcERhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGBBIHBsdWdpbiByZXR1cm5lZCBhbiB1bmFjY2VwdGFibGUgdmFsdWUgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIHR5cGUuYCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMub25lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodHlwZSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub25lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbn1cblxuY2xhc3MgQXN5bmNXYXRlcmZhbGxIb29rIGV4dGVuZHMgU3luY0hvb2sge1xuICAgIGVtaXQoZGF0YSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICBlcnJvcihgVGhlIHJlc3BvbnNlIGRhdGEgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIGhvb2sgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbHMgPSBBcnJheS5mcm9tKHRoaXMubGlzdGVuZXJzKTtcbiAgICAgICAgaWYgKGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlKT0+e1xuICAgICAgICAgICAgICAgIHdhcm4oZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSAocHJldkRhdGEpPT57XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUmV0dXJuRGF0YShkYXRhLCBwcmV2RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHByZXZEYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxzW2krK10oZGF0YSkpLnRoZW4oY2FsbCwgcHJvY2Vzc0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0Vycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGBBIHBsdWdpbiByZXR1cm5lZCBhbiBpbmNvcnJlY3QgdmFsdWUgZm9yIHRoZSBcIiR7dGhpcy50eXBlfVwiIHR5cGUuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FsbChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodHlwZSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub25lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbn1cblxuY2xhc3MgUGx1Z2luU3lzdGVtIHtcbiAgICBhcHBseVBsdWdpbihwbHVnaW4sIGluc3RhbmNlKSB7XG4gICAgICAgIGFzc2VydChpc1BsYWluT2JqZWN0KHBsdWdpbiksICdQbHVnaW4gY29uZmlndXJhdGlvbiBpcyBpbnZhbGlkLicpO1xuICAgICAgICAvLyBUaGUgcGx1Z2luJ3MgbmFtZSBpcyBtYW5kYXRvcnkgYW5kIG11c3QgYmUgdW5pcXVlXG4gICAgICAgIGNvbnN0IHBsdWdpbk5hbWUgPSBwbHVnaW4ubmFtZTtcbiAgICAgICAgYXNzZXJ0KHBsdWdpbk5hbWUsICdBIG5hbWUgbXVzdCBiZSBwcm92aWRlZCBieSB0aGUgcGx1Z2luLicpO1xuICAgICAgICBpZiAoIXRoaXMucmVnaXN0ZXJQbHVnaW5zW3BsdWdpbk5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbjtcbiAgICAgICAgICAgIHBsdWdpbi5hcHBseSA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2luLmFwcGx5LmNhbGwocGx1Z2luLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmxpZmVjeWNsZSkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsdWdpbkxpZmUgPSBwbHVnaW5ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luTGlmZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpZmVjeWNsZVtrZXldLm9uKHBsdWdpbkxpZmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVBsdWdpbihwbHVnaW5OYW1lKSB7XG4gICAgICAgIGFzc2VydChwbHVnaW5OYW1lLCAnQSBuYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnJlZ2lzdGVyUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgICAgYXNzZXJ0KHBsdWdpbiwgYFRoZSBwbHVnaW4gXCIke3BsdWdpbk5hbWV9XCIgaXMgbm90IHJlZ2lzdGVyZWQuYCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHBsdWdpbikuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ25hbWUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saWZlY3ljbGVba2V5XS5yZW1vdmUocGx1Z2luW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGlmZWN5Y2xlKXtcbiAgICAgICAgdGhpcy5yZWdpc3RlclBsdWdpbnMgPSB7fTtcbiAgICAgICAgdGhpcy5saWZlY3ljbGUgPSBsaWZlY3ljbGU7XG4gICAgICAgIHRoaXMubGlmZWN5Y2xlS2V5cyA9IE9iamVjdC5rZXlzKGxpZmVjeWNsZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25SZW1vdGVJbmZvKHJlbW90ZUluZm8sIHJlbW90ZVNuYXBzaG90KSB7XG4gICAgY29uc3QgcmVtb3RlRW50cnlJbmZvID0gZ2V0UmVtb3RlRW50cnlJbmZvRnJvbVNuYXBzaG90KHJlbW90ZVNuYXBzaG90KTtcbiAgICBpZiAoIXJlbW90ZUVudHJ5SW5mby51cmwpIHtcbiAgICAgICAgZXJyb3IoYFRoZSBhdHRyaWJ1dGUgcmVtb3RlRW50cnkgb2YgJHtyZW1vdGVJbmZvLm5hbWV9IG11c3Qgbm90IGJlIHVuZGVmaW5lZC5gKTtcbiAgICB9XG4gICAgbGV0IGVudHJ5VXJsID0gZ2V0UmVzb3VyY2VVcmwocmVtb3RlU25hcHNob3QsIHJlbW90ZUVudHJ5SW5mby51cmwpO1xuICAgIGlmICghaXNCcm93c2VyRW52KCkgJiYgIWVudHJ5VXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICBlbnRyeVVybCA9IGBodHRwczoke2VudHJ5VXJsfWA7XG4gICAgfVxuICAgIHJlbW90ZUluZm8udHlwZSA9IHJlbW90ZUVudHJ5SW5mby50eXBlO1xuICAgIHJlbW90ZUluZm8uZW50cnlHbG9iYWxOYW1lID0gcmVtb3RlRW50cnlJbmZvLmdsb2JhbE5hbWU7XG4gICAgcmVtb3RlSW5mby5lbnRyeSA9IGVudHJ5VXJsO1xuICAgIHJlbW90ZUluZm8udmVyc2lvbiA9IHJlbW90ZVNuYXBzaG90LnZlcnNpb247XG4gICAgcmVtb3RlSW5mby5idWlsZFZlcnNpb24gPSByZW1vdGVTbmFwc2hvdC5idWlsZFZlcnNpb247XG59XG5mdW5jdGlvbiBzbmFwc2hvdFBsdWdpbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnc25hcHNob3QtcGx1Z2luJyxcbiAgICAgICAgYXN5bmMgYWZ0ZXJSZXNvbHZlIChhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlbW90ZSwgcGtnTmFtZU9yQWxpYXMsIGV4cG9zZSwgb3JpZ2luLCByZW1vdGVJbmZvLCBpZCB9ID0gYXJncztcbiAgICAgICAgICAgIGlmICghaXNSZW1vdGVJbmZvV2l0aEVudHJ5KHJlbW90ZSkgfHwgIWlzUHVyZVJlbW90ZUVudHJ5KHJlbW90ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdCB9ID0gYXdhaXQgb3JpZ2luLnNuYXBzaG90SGFuZGxlci5sb2FkUmVtb3RlU25hcHNob3RJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlSW5mbzogcmVtb3RlLFxuICAgICAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzc2lnblJlbW90ZUluZm8ocmVtb3RlSW5mbywgcmVtb3RlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIC8vIHByZWxvYWRpbmcgYXNzZXRzXG4gICAgICAgICAgICAgICAgY29uc3QgcHJlbG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZENvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZU9yQWxpYXM6IHBrZ05hbWVPckFsaWFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlQ2F0ZWdvcnk6ICdzeW5jJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHNSZW1vdGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzc2V0cyA9IGF3YWl0IG9yaWdpbi5yZW1vdGVIYW5kbGVyLmhvb2tzLmxpZmVjeWNsZS5nZW5lcmF0ZVByZWxvYWRBc3NldHMuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGFzc2V0cykge1xuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkQXNzZXRzKHJlbW90ZUluZm8sIG9yaWdpbiwgYXNzZXRzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYXJncywge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBuYW1lXG4vLyBuYW1lOnZlcnNpb25cbmZ1bmN0aW9uIHNwbGl0SWQoaWQpIHtcbiAgICBjb25zdCBzcGxpdEluZm8gPSBpZC5zcGxpdCgnOicpO1xuICAgIGlmIChzcGxpdEluZm8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzcGxpdEluZm9bMF0sXG4gICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0SW5mby5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHNwbGl0SW5mb1swXSxcbiAgICAgICAgICAgIHZlcnNpb246IHNwbGl0SW5mb1sxXVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzcGxpdEluZm9bMV0sXG4gICAgICAgICAgICB2ZXJzaW9uOiBzcGxpdEluZm9bMl1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyBUcmF2ZXJzZSBhbGwgbm9kZXMgaW4gbW9kdWxlSW5mbyBhbmQgdHJhdmVyc2UgdGhlIGVudGlyZSBzbmFwc2hvdFxuZnVuY3Rpb24gdHJhdmVyc2VNb2R1bGVJbmZvKGdsb2JhbFNuYXBzaG90LCByZW1vdGVJbmZvLCB0cmF2ZXJzZSwgaXNSb290LCBtZW1vID0ge30sIHJlbW90ZVNuYXBzaG90KSB7XG4gICAgY29uc3QgaWQgPSBnZXRGTUlkKHJlbW90ZUluZm8pO1xuICAgIGNvbnN0IHsgdmFsdWU6IHNuYXBzaG90VmFsdWUgfSA9IGdldEluZm9XaXRob3V0VHlwZShnbG9iYWxTbmFwc2hvdCwgaWQpO1xuICAgIGNvbnN0IGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90ID0gcmVtb3RlU25hcHNob3QgfHwgc25hcHNob3RWYWx1ZTtcbiAgICBpZiAoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QgJiYgIWlzTWFuaWZlc3RQcm92aWRlcihlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdCkpIHtcbiAgICAgICAgdHJhdmVyc2UoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QsIHJlbW90ZUluZm8sIGlzUm9vdCk7XG4gICAgICAgIGlmIChlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdC5yZW1vdGVzSW5mbykge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlS2V5cyA9IE9iamVjdC5rZXlzKGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90LnJlbW90ZXNJbmZvKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJlbW90ZUtleXMpe1xuICAgICAgICAgICAgICAgIGlmIChtZW1vW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViUmVtb3RlSW5mbyA9IHNwbGl0SWQoa2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVWYWx1ZSA9IGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90LnJlbW90ZXNJbmZvW2tleV07XG4gICAgICAgICAgICAgICAgdHJhdmVyc2VNb2R1bGVJbmZvKGdsb2JhbFNuYXBzaG90LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN1YlJlbW90ZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogcmVtb3RlVmFsdWUubWF0Y2hlZFZlcnNpb25cbiAgICAgICAgICAgICAgICB9LCB0cmF2ZXJzZSwgZmFsc2UsIG1lbW8sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBpc0V4aXN0ZWQgPSAodHlwZSwgdXJsKT0+e1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAke3R5cGV9WyR7dHlwZSA9PT0gJ2xpbmsnID8gJ2hyZWYnIDogJ3NyYyd9PVwiJHt1cmx9XCJdYCk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbmZ1bmN0aW9uIGdlbmVyYXRlUHJlbG9hZEFzc2V0cyhvcmlnaW4sIHByZWxvYWRPcHRpb25zLCByZW1vdGUsIGdsb2JhbFNuYXBzaG90LCByZW1vdGVTbmFwc2hvdCkge1xuICAgIGNvbnN0IGNzc0Fzc2V0cyA9IFtdO1xuICAgIGNvbnN0IGpzQXNzZXRzID0gW107XG4gICAgY29uc3QgZW50cnlBc3NldHMgPSBbXTtcbiAgICBjb25zdCBsb2FkZWRTaGFyZWRKc0Fzc2V0cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBsb2FkZWRTaGFyZWRDc3NBc3NldHMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSBvcmlnaW47XG4gICAgY29uc3QgeyBwcmVsb2FkQ29uZmlnOiByb290UHJlbG9hZENvbmZpZyB9ID0gcHJlbG9hZE9wdGlvbnM7XG4gICAgY29uc3QgeyBkZXBzUmVtb3RlIH0gPSByb290UHJlbG9hZENvbmZpZztcbiAgICBjb25zdCBtZW1vID0ge307XG4gICAgdHJhdmVyc2VNb2R1bGVJbmZvKGdsb2JhbFNuYXBzaG90LCByZW1vdGUsIChtb2R1bGVJbmZvU25hcHNob3QsIHJlbW90ZUluZm8sIGlzUm9vdCk9PntcbiAgICAgICAgbGV0IHByZWxvYWRDb25maWc7XG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgIHByZWxvYWRDb25maWcgPSByb290UHJlbG9hZENvbmZpZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlcHNSZW1vdGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmRQcmVsb2FkQ29uZmlnID0gZGVwc1JlbW90ZS5maW5kKChyZW1vdGVDb25maWcpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdGVDb25maWcubmFtZU9yQWxpYXMgPT09IHJlbW90ZUluZm8ubmFtZSB8fCByZW1vdGVDb25maWcubmFtZU9yQWxpYXMgPT09IHJlbW90ZUluZm8uYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbmRQcmVsb2FkQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJlbG9hZENvbmZpZyA9IGRlZmF1bHRQcmVsb2FkQXJncyhmaW5kUHJlbG9hZENvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlcHNSZW1vdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBwcmVsb2FkQ29uZmlnID0gcm9vdFByZWxvYWRDb25maWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdGVFbnRyeVVybCA9IGdldFJlc291cmNlVXJsKG1vZHVsZUluZm9TbmFwc2hvdCwgZ2V0UmVtb3RlRW50cnlJbmZvRnJvbVNuYXBzaG90KG1vZHVsZUluZm9TbmFwc2hvdCkudXJsKTtcbiAgICAgICAgaWYgKHJlbW90ZUVudHJ5VXJsKSB7XG4gICAgICAgICAgICBlbnRyeUFzc2V0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiByZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgbW9kdWxlSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiByZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5OiByZW1vdGVFbnRyeVVybCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3JlbW90ZUVudHJ5VHlwZScgaW4gbW9kdWxlSW5mb1NuYXBzaG90ID8gbW9kdWxlSW5mb1NuYXBzaG90LnJlbW90ZUVudHJ5VHlwZSA6ICdnbG9iYWwnLFxuICAgICAgICAgICAgICAgICAgICBlbnRyeUdsb2JhbE5hbWU6ICdnbG9iYWxOYW1lJyBpbiBtb2R1bGVJbmZvU25hcHNob3QgPyBtb2R1bGVJbmZvU25hcHNob3QuZ2xvYmFsTmFtZSA6IHJlbW90ZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVTY29wZTogJycsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvU25hcHNob3QgPyBtb2R1bGVJbmZvU25hcHNob3QudmVyc2lvbiA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXJsOiByZW1vdGVFbnRyeVVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1vZHVsZUFzc2V0c0luZm8gPSAnbW9kdWxlcycgaW4gbW9kdWxlSW5mb1NuYXBzaG90ID8gbW9kdWxlSW5mb1NuYXBzaG90Lm1vZHVsZXMgOiBbXTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFByZWxvYWRFeHBvc2VzID0gbm9ybWFsaXplUHJlbG9hZEV4cG9zZXMocHJlbG9hZENvbmZpZy5leHBvc2VzKTtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcmVsb2FkRXhwb3Nlcy5sZW5ndGggJiYgJ21vZHVsZXMnIGluIG1vZHVsZUluZm9TbmFwc2hvdCkge1xuICAgICAgICAgICAgdmFyIF9tb2R1bGVJbmZvU25hcHNob3RfbW9kdWxlcztcbiAgICAgICAgICAgIG1vZHVsZUFzc2V0c0luZm8gPSBtb2R1bGVJbmZvU25hcHNob3QgPT0gbnVsbCA/IHZvaWQgMCA6IChfbW9kdWxlSW5mb1NuYXBzaG90X21vZHVsZXMgPSBtb2R1bGVJbmZvU25hcHNob3QubW9kdWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tb2R1bGVJbmZvU25hcHNob3RfbW9kdWxlcy5yZWR1Y2UoKGFzc2V0cywgbW9kdWxlQXNzZXRJbmZvKT0+e1xuICAgICAgICAgICAgICAgIGlmICgobm9ybWFsaXplZFByZWxvYWRFeHBvc2VzID09IG51bGwgPyB2b2lkIDAgOiBub3JtYWxpemVkUHJlbG9hZEV4cG9zZXMuaW5kZXhPZihtb2R1bGVBc3NldEluZm8ubW9kdWxlTmFtZSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NldHMucHVzaChtb2R1bGVBc3NldEluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXRzO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUFzc2V0cyhhc3NldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0c1JlcyA9IGFzc2V0cy5tYXAoKGFzc2V0KT0+Z2V0UmVzb3VyY2VVcmwobW9kdWxlSW5mb1NuYXBzaG90LCBhc3NldCkpO1xuICAgICAgICAgICAgaWYgKHByZWxvYWRDb25maWcuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2V0c1Jlcy5maWx0ZXIocHJlbG9hZENvbmZpZy5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzc2V0c1JlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kdWxlQXNzZXRzSW5mbykge1xuICAgICAgICAgICAgY29uc3QgYXNzZXRzTGVuZ3RoID0gbW9kdWxlQXNzZXRzSW5mby5sZW5ndGg7XG4gICAgICAgICAgICBmb3IobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhc3NldHNMZW5ndGg7IGluZGV4Kyspe1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzc2V0c0luZm8gPSBtb2R1bGVBc3NldHNJbmZvW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBvc2VGdWxsUGF0aCA9IGAke3JlbW90ZUluZm8ubmFtZX0vJHthc3NldHNJbmZvLm1vZHVsZU5hbWV9YDtcbiAgICAgICAgICAgICAgICBvcmlnaW4ucmVtb3RlSGFuZGxlci5ob29rcy5saWZlY3ljbGUuaGFuZGxlUHJlbG9hZE1vZHVsZS5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGFzc2V0c0luZm8ubW9kdWxlTmFtZSA9PT0gJy4nID8gcmVtb3RlSW5mby5uYW1lIDogZXhwb3NlRnVsbFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlbW90ZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IG1vZHVsZUluZm9TbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlOiByZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVsb2FkZWQgPSBnZXRQcmVsb2FkZWQoZXhwb3NlRnVsbFBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmVsb2FkQ29uZmlnLnJlc291cmNlQ2F0ZWdvcnkgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzc0Fzc2V0cy5wdXNoKC4uLmhhbmRsZUFzc2V0cyhhc3NldHNJbmZvLmFzc2V0cy5jc3MuYXN5bmMpKTtcbiAgICAgICAgICAgICAgICAgICAgY3NzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmNzcy5zeW5jKSk7XG4gICAgICAgICAgICAgICAgICAgIGpzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmpzLmFzeW5jKSk7XG4gICAgICAgICAgICAgICAgICAgIGpzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmpzLnN5bmMpKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVsb2FkQ29uZmlnLnJlc291cmNlQ2F0ZWdvcnkgPSAnc3luYycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmNzcy5zeW5jKSk7XG4gICAgICAgICAgICAgICAgICAgIGpzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmpzLnN5bmMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0UHJlbG9hZGVkKGV4cG9zZUZ1bGxQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHRydWUsIG1lbW8sIHJlbW90ZVNuYXBzaG90KTtcbiAgICBpZiAocmVtb3RlU25hcHNob3Quc2hhcmVkICYmIHJlbW90ZVNuYXBzaG90LnNoYXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RTaGFyZWRBc3NldHMgPSAoc2hhcmVJbmZvLCBzbmFwc2hvdFNoYXJlZCk9PntcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRTaGFyZWQgPSBnZXRSZWdpc3RlcmVkU2hhcmUob3JpZ2luLnNoYXJlU2NvcGVNYXAsIHNuYXBzaG90U2hhcmVkLnNoYXJlZE5hbWUsIHNoYXJlSW5mbywgb3JpZ2luLnNoYXJlZEhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZ2xvYmFsIHNoYXJlIGRvZXMgbm90IGV4aXN0LCBvciB0aGUgbGliIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBpdCBtZWFucyB0aGF0IHRoZSBzaGFyZWQgaGFzIG5vdCBiZWVuIGxvYWRlZCB5ZXQgYW5kIGNhbiBiZSBwcmVsb2FkZWQuXG4gICAgICAgICAgICBpZiAocmVnaXN0ZXJlZFNoYXJlZCAmJiB0eXBlb2YgcmVnaXN0ZXJlZFNoYXJlZC5saWIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdFNoYXJlZC5hc3NldHMuanMuc3luYy5mb3JFYWNoKChhc3NldCk9PntcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkU2hhcmVkSnNBc3NldHMuYWRkKGFzc2V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdFNoYXJlZC5hc3NldHMuY3NzLnN5bmMuZm9yRWFjaCgoYXNzZXQpPT57XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZFNoYXJlZENzc0Fzc2V0cy5hZGQoYXNzZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZW1vdGVTbmFwc2hvdC5zaGFyZWQuZm9yRWFjaCgoc2hhcmVkKT0+e1xuICAgICAgICAgICAgdmFyIF9vcHRpb25zX3NoYXJlZDtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlSW5mb3MgPSAoX29wdGlvbnNfc2hhcmVkID0gb3B0aW9ucy5zaGFyZWQpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0aW9uc19zaGFyZWRbc2hhcmVkLnNoYXJlZE5hbWVdO1xuICAgICAgICAgICAgaWYgKCFzaGFyZUluZm9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgbm8gdmVyc2lvbiwgcHJlbG9hZCBhbGwgc2hhcmVkXG4gICAgICAgICAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gc2hhcmVkLnZlcnNpb24gPyBzaGFyZUluZm9zLmZpbmQoKHMpPT5zLnZlcnNpb24gPT09IHNoYXJlZC52ZXJzaW9uKSA6IHNoYXJlSW5mb3M7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcnJheVNoYXJlSW5mbyA9IGFycmF5T3B0aW9ucyhzaGFyZWRPcHRpb25zKTtcbiAgICAgICAgICAgIGFycmF5U2hhcmVJbmZvLmZvckVhY2goKHMpPT57XG4gICAgICAgICAgICAgICAgY29sbGVjdFNoYXJlZEFzc2V0cyhzLCBzaGFyZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBuZWVkUHJlbG9hZEpzQXNzZXRzID0ganNBc3NldHMuZmlsdGVyKChhc3NldCk9PiFsb2FkZWRTaGFyZWRKc0Fzc2V0cy5oYXMoYXNzZXQpICYmICFpc0V4aXN0ZWQoJ3NjcmlwdCcsIGFzc2V0KSk7XG4gICAgY29uc3QgbmVlZFByZWxvYWRDc3NBc3NldHMgPSBjc3NBc3NldHMuZmlsdGVyKChhc3NldCk9PiFsb2FkZWRTaGFyZWRDc3NBc3NldHMuaGFzKGFzc2V0KSAmJiAhaXNFeGlzdGVkKCdsaW5rJywgYXNzZXQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjc3NBc3NldHM6IG5lZWRQcmVsb2FkQ3NzQXNzZXRzLFxuICAgICAgICBqc0Fzc2V0c1dpdGhvdXRFbnRyeTogbmVlZFByZWxvYWRKc0Fzc2V0cyxcbiAgICAgICAgZW50cnlBc3NldHM6IGVudHJ5QXNzZXRzLmZpbHRlcigoZW50cnkpPT4haXNFeGlzdGVkKCdzY3JpcHQnLCBlbnRyeS51cmwpKVxuICAgIH07XG59XG5jb25zdCBnZW5lcmF0ZVByZWxvYWRBc3NldHNQbHVnaW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnZ2VuZXJhdGUtcHJlbG9hZC1hc3NldHMtcGx1Z2luJyxcbiAgICAgICAgYXN5bmMgZ2VuZXJhdGVQcmVsb2FkQXNzZXRzIChhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9yaWdpbiwgcHJlbG9hZE9wdGlvbnMsIHJlbW90ZUluZm8sIHJlbW90ZSwgZ2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90IH0gPSBhcmdzO1xuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXJFbnYoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNzc0Fzc2V0czogW10sXG4gICAgICAgICAgICAgICAgICAgIGpzQXNzZXRzV2l0aG91dEVudHJ5OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZW50cnlBc3NldHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1JlbW90ZUluZm9XaXRoRW50cnkocmVtb3RlKSAmJiBpc1B1cmVSZW1vdGVFbnRyeShyZW1vdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzQXNzZXRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAganNBc3NldHNXaXRob3V0RW50cnk6IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbnRyeUFzc2V0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlbW90ZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcmVtb3RlLmVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeTogcmVtb3RlLmVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiByZW1vdGVJbmZvLnR5cGUgfHwgJ2dsb2JhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5R2xvYmFsTmFtZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGU6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnblJlbW90ZUluZm8ocmVtb3RlSW5mbywgcmVtb3RlU25hcHNob3QpO1xuICAgICAgICAgICAgY29uc3QgYXNzZXRzID0gZ2VuZXJhdGVQcmVsb2FkQXNzZXRzKG9yaWdpbiwgcHJlbG9hZE9wdGlvbnMsIHJlbW90ZUluZm8sIGdsb2JhbFNuYXBzaG90LCByZW1vdGVTbmFwc2hvdCk7XG4gICAgICAgICAgICByZXR1cm4gYXNzZXRzO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldEdsb2JhbFJlbW90ZUluZm8obW9kdWxlSW5mbywgb3JpZ2luKSB7XG4gICAgY29uc3QgaG9zdEdsb2JhbFNuYXBzaG90ID0gZ2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKHtcbiAgICAgICAgbmFtZTogb3JpZ2luLm5hbWUsXG4gICAgICAgIHZlcnNpb246IG9yaWdpbi5vcHRpb25zLnZlcnNpb25cbiAgICB9KTtcbiAgICAvLyBnZXQgcmVtb3RlIGRldGFpbCBpbmZvIGZyb20gZ2xvYmFsXG4gICAgY29uc3QgZ2xvYmFsUmVtb3RlSW5mbyA9IGhvc3RHbG9iYWxTbmFwc2hvdCAmJiAncmVtb3Rlc0luZm8nIGluIGhvc3RHbG9iYWxTbmFwc2hvdCAmJiBob3N0R2xvYmFsU25hcHNob3QucmVtb3Rlc0luZm8gJiYgZ2V0SW5mb1dpdGhvdXRUeXBlKGhvc3RHbG9iYWxTbmFwc2hvdC5yZW1vdGVzSW5mbywgbW9kdWxlSW5mby5uYW1lKS52YWx1ZTtcbiAgICBpZiAoZ2xvYmFsUmVtb3RlSW5mbyAmJiBnbG9iYWxSZW1vdGVJbmZvLm1hdGNoZWRWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob3N0R2xvYmFsU25hcHNob3QsXG4gICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogZ2V0R2xvYmFsU25hcHNob3QoKSxcbiAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICAgICAgICAgIG5hbWU6IG1vZHVsZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBnbG9iYWxSZW1vdGVJbmZvLm1hdGNoZWRWZXJzaW9uXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBob3N0R2xvYmFsU25hcHNob3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2xvYmFsU25hcHNob3Q6IGdldEdsb2JhbFNuYXBzaG90KCksXG4gICAgICAgIHJlbW90ZVNuYXBzaG90OiBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICAgICAgbmFtZTogbW9kdWxlSW5mby5uYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogJ3ZlcnNpb24nIGluIG1vZHVsZUluZm8gPyBtb2R1bGVJbmZvLnZlcnNpb24gOiB1bmRlZmluZWRcbiAgICAgICAgfSlcbiAgICB9O1xufVxuY2xhc3MgU25hcHNob3RIYW5kbGVyIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxuICAgIGFzeW5jIGxvYWRSZW1vdGVTbmFwc2hvdEluZm8oeyBtb2R1bGVJbmZvLCBpZCwgZXhwb3NlIH0pIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLkhvc3RJbnN0YW5jZTtcbiAgICAgICAgYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuYmVmb3JlTG9hZFJlbW90ZVNuYXBzaG90LmVtaXQoe1xuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1vZHVsZUluZm9cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBob3N0U25hcHNob3QgPSBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICAgICAgbmFtZTogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy52ZXJzaW9uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWhvc3RTbmFwc2hvdCkge1xuICAgICAgICAgICAgaG9zdFNuYXBzaG90ID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMudmVyc2lvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeTogJycsXG4gICAgICAgICAgICAgICAgcmVtb3Rlc0luZm86IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWRkR2xvYmFsU25hcHNob3Qoe1xuICAgICAgICAgICAgICAgIFt0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLm5hbWVdOiBob3N0U25hcHNob3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIGR5bmFtaWMgbG9hZFJlbW90ZSBzY2VuYXJpb3MsIGluY29tcGxldGUgcmVtb3Rlc0luZm8gZGVsaXZlcnkgbWF5IG9jY3VyLiBJbiBzdWNoIGNhc2VzLCB0aGUgcmVtb3Rlc0luZm8gaW4gdGhlIGhvc3QgbmVlZHMgdG8gYmUgY29tcGxldGVkIGluIHRoZSBzbmFwc2hvdCBhdCBydW50aW1lLlxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIHNuYXBzaG90J3MgaW50ZWdyaXR5IGFuZCBoZWxwcyB0aGUgY2hyb21lIHBsdWdpbiBjb3JyZWN0bHkgaWRlbnRpZnkgYWxsIHByb2R1Y2VyIG1vZHVsZXMsIGVuc3VyaW5nIHRoYXQgcHJveHlhYmxlIHByb2R1Y2VyIG1vZHVsZXMgd2lsbCBub3QgYmUgbWlzc2luZy5cbiAgICAgICAgaWYgKGhvc3RTbmFwc2hvdCAmJiAncmVtb3Rlc0luZm8nIGluIGhvc3RTbmFwc2hvdCAmJiAhZ2V0SW5mb1dpdGhvdXRUeXBlKGhvc3RTbmFwc2hvdC5yZW1vdGVzSW5mbywgbW9kdWxlSW5mby5uYW1lKS52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvIHx8ICdlbnRyeScgaW4gbW9kdWxlSW5mbykge1xuICAgICAgICAgICAgICAgIGhvc3RTbmFwc2hvdC5yZW1vdGVzSW5mbyA9IF9leHRlbmRzKHt9LCBob3N0U25hcHNob3QgPT0gbnVsbCA/IHZvaWQgMCA6IGhvc3RTbmFwc2hvdC5yZW1vdGVzSW5mbywge1xuICAgICAgICAgICAgICAgICAgICBbbW9kdWxlSW5mby5uYW1lXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb246ICd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvID8gbW9kdWxlSW5mby52ZXJzaW9uIDogbW9kdWxlSW5mby5lbnRyeVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBob3N0R2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdCB9ID0gdGhpcy5nZXRHbG9iYWxSZW1vdGVJbmZvKG1vZHVsZUluZm8pO1xuICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiBnbG9iYWxSZW1vdGVTbmFwc2hvdCwgZ2xvYmFsU25hcHNob3Q6IGdsb2JhbFNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbW9kdWxlSW5mbyxcbiAgICAgICAgICAgIGhvc3RHbG9iYWxTbmFwc2hvdCxcbiAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90LFxuICAgICAgICAgICAgZ2xvYmFsU25hcHNob3RcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBtU25hcHNob3Q7XG4gICAgICAgIGxldCBnU25hcHNob3Q7XG4gICAgICAgIC8vIGdsb2JhbCBzbmFwc2hvdCBpbmNsdWRlcyBtYW5pZmVzdCBvciBtb2R1bGUgaW5mbyBpbmNsdWRlcyBtYW5pZmVzdFxuICAgICAgICBpZiAoZ2xvYmFsUmVtb3RlU25hcHNob3QpIHtcbiAgICAgICAgICAgIGlmIChpc01hbmlmZXN0UHJvdmlkZXIoZ2xvYmFsUmVtb3RlU25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlRW50cnkgPSBpc0Jyb3dzZXJFbnYoKSA/IGdsb2JhbFJlbW90ZVNuYXBzaG90LnJlbW90ZUVudHJ5IDogZ2xvYmFsUmVtb3RlU25hcHNob3Quc3NyUmVtb3RlRW50cnkgfHwgZ2xvYmFsUmVtb3RlU25hcHNob3QucmVtb3RlRW50cnkgfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlU25hcHNob3QgPSBhd2FpdCB0aGlzLmdldE1hbmlmZXN0SnNvbihyZW1vdGVFbnRyeSwgbW9kdWxlSW5mbywge30pO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsU25hcHNob3RSZXMgPSBzZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oX2V4dGVuZHMoe30sIG1vZHVsZUluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGdsb2JhbCByZW1vdGUgbWF5IGJlIG92ZXJyaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCBzZXQgdGhlIHNuYXBzaG90IGtleSB0byB0aGUgZ2xvYmFsIGFkZHJlc3Mgb2YgdGhlIGFjdHVhbCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5OiByZW1vdGVFbnRyeVxuICAgICAgICAgICAgICAgIH0pLCBtb2R1bGVTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgbVNuYXBzaG90ID0gbW9kdWxlU25hcHNob3Q7XG4gICAgICAgICAgICAgICAgZ1NuYXBzaG90ID0gZ2xvYmFsU25hcHNob3RSZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3Q6IHJlbW90ZVNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkUmVtb3RlU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBnbG9iYWxSZW1vdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogJ2dsb2JhbCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtU25hcHNob3QgPSByZW1vdGVTbmFwc2hvdFJlcztcbiAgICAgICAgICAgICAgICBnU25hcHNob3QgPSBnbG9iYWxTbmFwc2hvdFJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1JlbW90ZUluZm9XaXRoRW50cnkobW9kdWxlSW5mbykpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgZnJvbSBtYW5pZmVzdC5qc29uIGFuZCBtZXJnZSByZW1vdGUgaW5mbyBmcm9tIHJlbW90ZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGVTbmFwc2hvdCA9IGF3YWl0IHRoaXMuZ2V0TWFuaWZlc3RKc29uKG1vZHVsZUluZm8uZW50cnksIG1vZHVsZUluZm8sIHt9KTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgICAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNuYXBzaG90UmVzID0gc2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKG1vZHVsZUluZm8sIG1vZHVsZVNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiByZW1vdGVTbmFwc2hvdFJlcyB9ID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUubG9hZFJlbW90ZVNuYXBzaG90LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogbW9kdWxlU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgIGZyb206ICdnbG9iYWwnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbVNuYXBzaG90ID0gcmVtb3RlU25hcHNob3RSZXM7XG4gICAgICAgICAgICAgICAgZ1NuYXBzaG90ID0gZ2xvYmFsU25hcHNob3RSZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yKGdldFNob3J0RXJyb3JNc2coUlVOVElNRV8wMDcsIHJ1bnRpbWVEZXNjTWFwLCB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3ROYW1lOiBtb2R1bGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RWZXJzaW9uOiBtb2R1bGVJbmZvLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90OiBKU09OLnN0cmluZ2lmeShnbG9iYWxTbmFwc2hvdFJlcylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuYWZ0ZXJMb2FkU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMuSG9zdEluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1vZHVsZUluZm8sXG4gICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogbVNuYXBzaG90XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IG1TbmFwc2hvdCxcbiAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90OiBnU25hcHNob3RcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0R2xvYmFsUmVtb3RlSW5mbyhtb2R1bGVJbmZvKSB7XG4gICAgICAgIHJldHVybiBnZXRHbG9iYWxSZW1vdGVJbmZvKG1vZHVsZUluZm8sIHRoaXMuSG9zdEluc3RhbmNlKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWFuaWZlc3RKc29uKG1hbmlmZXN0VXJsLCBtb2R1bGVJbmZvLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZ2V0TWFuaWZlc3QgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgbGV0IG1hbmlmZXN0SnNvbiA9IHRoaXMubWFuaWZlc3RDYWNoZS5nZXQobWFuaWZlc3RVcmwpO1xuICAgICAgICAgICAgaWYgKG1hbmlmZXN0SnNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdEpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLmxvYWRlckhvb2subGlmZWN5Y2xlLmZldGNoLmVtaXQobWFuaWZlc3RVcmwsIHt9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaChtYW5pZmVzdFVybCwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYW5pZmVzdEpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbWFuaWZlc3RKc29uID0gYXdhaXQgdGhpcy5Ib3N0SW5zdGFuY2UucmVtb3RlSGFuZGxlci5ob29rcy5saWZlY3ljbGUuZXJyb3JMb2FkUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBpZDogbWFuaWZlc3RVcmwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgIGZyb206ICdydW50aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgbGlmZWN5Y2xlOiAnYWZ0ZXJSZXNvbHZlJyxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiB0aGlzLkhvc3RJbnN0YW5jZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghbWFuaWZlc3RKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1hbmlmZXN0TG9hZGluZ1ttYW5pZmVzdFVybF07XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGdldFNob3J0RXJyb3JNc2coUlVOVElNRV8wMDMsIHJ1bnRpbWVEZXNjTWFwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IG1vZHVsZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3ROYW1lOiB0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSwgYCR7ZXJyfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQobWFuaWZlc3RKc29uLm1ldGFEYXRhICYmIG1hbmlmZXN0SnNvbi5leHBvc2VzICYmIG1hbmlmZXN0SnNvbi5zaGFyZWQsIGAke21hbmlmZXN0VXJsfSBpcyBub3QgYSBmZWRlcmF0aW9uIG1hbmlmZXN0YCk7XG4gICAgICAgICAgICB0aGlzLm1hbmlmZXN0Q2FjaGUuc2V0KG1hbmlmZXN0VXJsLCBtYW5pZmVzdEpzb24pO1xuICAgICAgICAgICAgcmV0dXJuIG1hbmlmZXN0SnNvbjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXN5bmNMb2FkUHJvY2VzcyA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdEpzb24gPSBhd2FpdCBnZXRNYW5pZmVzdCgpO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlU25hcHNob3QgPSBnZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0KG1hbmlmZXN0SnNvbiwge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IG1hbmlmZXN0VXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3Q6IHJlbW90ZVNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkUmVtb3RlU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgICAgIG1hbmlmZXN0SnNvbixcbiAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICBtYW5pZmVzdFVybCxcbiAgICAgICAgICAgICAgICBmcm9tOiAnbWFuaWZlc3QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZW1vdGVTbmFwc2hvdFJlcztcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLm1hbmlmZXN0TG9hZGluZ1ttYW5pZmVzdFVybF0pIHtcbiAgICAgICAgICAgIHRoaXMubWFuaWZlc3RMb2FkaW5nW21hbmlmZXN0VXJsXSA9IGFzeW5jTG9hZFByb2Nlc3MoKS50aGVuKChyZXMpPT5yZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmlmZXN0TG9hZGluZ1ttYW5pZmVzdFVybF07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKEhvc3RJbnN0YW5jZSl7XG4gICAgICAgIHRoaXMubG9hZGluZ0hvc3RTbmFwc2hvdCA9IG51bGw7XG4gICAgICAgIHRoaXMubWFuaWZlc3RDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ob29rcyA9IG5ldyBQbHVnaW5TeXN0ZW0oe1xuICAgICAgICAgICAgYmVmb3JlTG9hZFJlbW90ZVNuYXBzaG90OiBuZXcgQXN5bmNIb29rKCdiZWZvcmVMb2FkUmVtb3RlU25hcHNob3QnKSxcbiAgICAgICAgICAgIGxvYWRTbmFwc2hvdDogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnbG9hZEdsb2JhbFNuYXBzaG90JyksXG4gICAgICAgICAgICBsb2FkUmVtb3RlU25hcHNob3Q6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2xvYWRSZW1vdGVTbmFwc2hvdCcpLFxuICAgICAgICAgICAgYWZ0ZXJMb2FkU25hcHNob3Q6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2FmdGVyTG9hZFNuYXBzaG90JylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFuaWZlc3RMb2FkaW5nID0gR2xvYmFsLl9fRkVERVJBVElPTl9fLl9fTUFOSUZFU1RfTE9BRElOR19fO1xuICAgICAgICB0aGlzLkhvc3RJbnN0YW5jZSA9IEhvc3RJbnN0YW5jZTtcbiAgICAgICAgdGhpcy5sb2FkZXJIb29rID0gSG9zdEluc3RhbmNlLmxvYWRlckhvb2s7XG4gICAgfVxufVxuXG5jbGFzcyBTaGFyZWRIYW5kbGVyIHtcbiAgICAvLyByZWdpc3RlciBzaGFyZWQgaW4gc2hhcmVTY29wZU1hcFxuICAgIHJlZ2lzdGVyU2hhcmVkKGdsb2JhbE9wdGlvbnMsIHVzZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVJbmZvcywgc2hhcmVkIH0gPSBmb3JtYXRTaGFyZUNvbmZpZ3MoZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzaGFyZWRLZXlzID0gT2JqZWN0LmtleXMoc2hhcmVJbmZvcyk7XG4gICAgICAgIHNoYXJlZEtleXMuZm9yRWFjaCgoc2hhcmVkS2V5KT0+e1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFscyA9IHNoYXJlSW5mb3Nbc2hhcmVkS2V5XTtcbiAgICAgICAgICAgIHNoYXJlZFZhbHMuZm9yRWFjaCgoc2hhcmVkVmFsKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRTaGFyZWQgPSBnZXRSZWdpc3RlcmVkU2hhcmUodGhpcy5zaGFyZVNjb3BlTWFwLCBzaGFyZWRLZXksIHNoYXJlZFZhbCwgdGhpcy5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lzdGVyZWRTaGFyZWQgJiYgc2hhcmVkVmFsICYmIHNoYXJlZFZhbC5saWIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGtnTmFtZTogc2hhcmVkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGliOiBzaGFyZWRWYWwubGliLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBzaGFyZWRWYWwuZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkOiBzaGFyZWRWYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB1c2VyT3B0aW9ucy5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNoYXJlSW5mb3MsXG4gICAgICAgICAgICBzaGFyZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZFNoYXJlKHBrZ05hbWUsIGV4dHJhT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgdGhlIGZvbGxvd2luZyBzdGVwczpcbiAgICAgICAgLy8gMS4gQ2hlY2tzIGlmIHRoZSBjdXJyZW50bHkgbG9hZGVkIHNoYXJlIGFscmVhZHkgZXhpc3RzLCBpZiBub3QsIGl0IHRocm93cyBhbiBlcnJvclxuICAgICAgICAvLyAyLiBTZWFyY2hlcyBnbG9iYWxseSBmb3IgYSBtYXRjaGluZyBzaGFyZSwgaWYgZm91bmQsIGl0IHVzZXMgaXQgZGlyZWN0bHlcbiAgICAgICAgLy8gMy4gSWYgbm90IGZvdW5kLCBpdCByZXRyaWV2ZXMgaXQgZnJvbSB0aGUgY3VycmVudCBzaGFyZSBhbmQgc3RvcmVzIHRoZSBvYnRhaW5lZCBzaGFyZSBnbG9iYWxseS5cbiAgICAgICAgY29uc3Qgc2hhcmVPcHRpb25zID0gZ2V0VGFyZ2V0U2hhcmVkT3B0aW9ucyh7XG4gICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgZXh0cmFPcHRpb25zLFxuICAgICAgICAgICAgc2hhcmVJbmZvczogaG9zdC5vcHRpb25zLnNoYXJlZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNoYXJlT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogc2hhcmVPcHRpb25zLnNjb3BlKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzaGFyZU9wdGlvbnMuc2NvcGUubWFwKGFzeW5jIChzaGFyZVNjb3BlKT0+e1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZSwge1xuICAgICAgICAgICAgICAgICAgICBzdHJhdGVneTogc2hhcmVPcHRpb25zLnN0cmF0ZWd5XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2FkU2hhcmVSZXMgPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5iZWZvcmVMb2FkU2hhcmUuZW1pdCh7XG4gICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgc2hhcmVJbmZvOiBzaGFyZU9wdGlvbnMsXG4gICAgICAgICAgICBzaGFyZWQ6IGhvc3Qub3B0aW9ucy5zaGFyZWQsXG4gICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVJbmZvOiBzaGFyZU9wdGlvbnNSZXMgfSA9IGxvYWRTaGFyZVJlcztcbiAgICAgICAgLy8gQXNzZXJ0IHRoYXQgc2hhcmVJbmZvUmVzIGV4aXN0cywgaWYgbm90LCB0aHJvdyBhbiBlcnJvclxuICAgICAgICBhc3NlcnQoc2hhcmVPcHRpb25zUmVzLCBgQ2Fubm90IGZpbmQgJHtwa2dOYW1lfSBTaGFyZSBpbiB0aGUgJHtob3N0Lm9wdGlvbnMubmFtZX0uIFBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgJHtwa2dOYW1lfSBTaGFyZSBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBpbmplY3RlZGApO1xuICAgICAgICAvLyBSZXRyaWV2ZSBmcm9tIGNhY2hlXG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRTaGFyZWQgPSBnZXRSZWdpc3RlcmVkU2hhcmUodGhpcy5zaGFyZVNjb3BlTWFwLCBwa2dOYW1lLCBzaGFyZU9wdGlvbnNSZXMsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgIGNvbnN0IGFkZFVzZUluID0gKHNoYXJlZCk9PntcbiAgICAgICAgICAgIGlmICghc2hhcmVkLnVzZUluKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkLnVzZUluID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRVbmlxdWVJdGVtKHNoYXJlZC51c2VJbiwgaG9zdC5vcHRpb25zLm5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmVnaXN0ZXJlZFNoYXJlZCAmJiByZWdpc3RlcmVkU2hhcmVkLmxpYikge1xuICAgICAgICAgICAgYWRkVXNlSW4ocmVnaXN0ZXJlZFNoYXJlZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNoYXJlZC5saWI7XG4gICAgICAgIH0gZWxzZSBpZiAocmVnaXN0ZXJlZFNoYXJlZCAmJiByZWdpc3RlcmVkU2hhcmVkLmxvYWRpbmcgJiYgIXJlZ2lzdGVyZWRTaGFyZWQubG9hZGVkKSB7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gYXdhaXQgcmVnaXN0ZXJlZFNoYXJlZC5sb2FkaW5nO1xuICAgICAgICAgICAgcmVnaXN0ZXJlZFNoYXJlZC5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkU2hhcmVkLmxpYikge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRTaGFyZWQubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFVzZUluKHJlZ2lzdGVyZWRTaGFyZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVnaXN0ZXJlZFNoYXJlZCkge1xuICAgICAgICAgICAgY29uc3QgYXN5bmNMb2FkUHJvY2VzcyA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IHJlZ2lzdGVyZWRTaGFyZWQuZ2V0KCk7XG4gICAgICAgICAgICAgICAgYWRkVXNlSW4ocmVnaXN0ZXJlZFNoYXJlZCk7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZFNoYXJlZC5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRTaGFyZWQubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBsb2FkaW5nID0gYXN5bmNMb2FkUHJvY2VzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaGFyZWQ6IHJlZ2lzdGVyZWRTaGFyZWQsXG4gICAgICAgICAgICAgICAgZnJvbTogaG9zdC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgbGliOiBudWxsLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBleHRyYU9wdGlvbnMuY3VzdG9tU2hhcmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXN5bmNMb2FkUHJvY2VzcyA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IHNoYXJlT3B0aW9uc1Jlcy5nZXQoKTtcbiAgICAgICAgICAgICAgICBzaGFyZU9wdGlvbnNSZXMubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgICAgICBzaGFyZU9wdGlvbnNSZXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZGRVc2VJbihzaGFyZU9wdGlvbnNSZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdTaGFyZWQgPSBnZXRSZWdpc3RlcmVkU2hhcmUodGhpcy5zaGFyZVNjb3BlTWFwLCBwa2dOYW1lLCBzaGFyZU9wdGlvbnNSZXMsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdTaGFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ1NoYXJlZC5saWIgPSBmYWN0b3J5O1xuICAgICAgICAgICAgICAgICAgICBnU2hhcmVkLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGdTaGFyZWQuZnJvbSA9IHNoYXJlT3B0aW9uc1Jlcy5mcm9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBsb2FkaW5nID0gYXN5bmNMb2FkUHJvY2VzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaGFyZWQ6IHNoYXJlT3B0aW9uc1JlcyxcbiAgICAgICAgICAgICAgICBmcm9tOiBob3N0Lm9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICBsaWI6IG51bGwsXG4gICAgICAgICAgICAgICAgbG9hZGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIHRoZSBzaGFyaW5nIHNlcXVlbmNlIChleGVjdXRlZCBvbmx5IG9uY2UgcGVyIHNoYXJlIHNjb3BlKS5cbiAgICAgKiBJdCBhY2NlcHRzIG9uZSBhcmd1bWVudCwgdGhlIG5hbWUgb2YgdGhlIHNoYXJlIHNjb3BlLlxuICAgICAqIElmIHRoZSBzaGFyZSBzY29wZSBkb2VzIG5vdCBleGlzdCwgaXQgY3JlYXRlcyBvbmUuXG4gICAgICovIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZU5hbWUgPSBERUZBVUxUX1NDT1BFLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBmcm9tID0gZXh0cmFPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBleHRyYU9wdGlvbnMuZnJvbTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBleHRyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9ucy5zdHJhdGVneTtcbiAgICAgICAgbGV0IGluaXRTY29wZSA9IGV4dHJhT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogZXh0cmFPcHRpb25zLmluaXRTY29wZTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaWYgKGZyb20gIT09ICdidWlsZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5pdFRva2VucyB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICghaW5pdFNjb3BlKSBpbml0U2NvcGUgPSBbXTtcbiAgICAgICAgICAgIGxldCBpbml0VG9rZW4gPSBpbml0VG9rZW5zW3NoYXJlU2NvcGVOYW1lXTtcbiAgICAgICAgICAgIGlmICghaW5pdFRva2VuKSBpbml0VG9rZW4gPSBpbml0VG9rZW5zW3NoYXJlU2NvcGVOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLmhvc3QubmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbml0U2NvcGUuaW5kZXhPZihpbml0VG9rZW4pID49IDApIHJldHVybiBwcm9taXNlcztcbiAgICAgICAgICAgIGluaXRTY29wZS5wdXNoKGluaXRUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhcmVTY29wZSA9IHRoaXMuc2hhcmVTY29wZU1hcDtcbiAgICAgICAgY29uc3QgaG9zdE5hbWUgPSBob3N0Lm9wdGlvbnMubmFtZTtcbiAgICAgICAgLy8gQ3JlYXRlcyBhIG5ldyBzaGFyZSBzY29wZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCFzaGFyZVNjb3BlW3NoYXJlU2NvcGVOYW1lXSkge1xuICAgICAgICAgICAgc2hhcmVTY29wZVtzaGFyZVNjb3BlTmFtZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGVjdXRlcyBhbGwgaW5pdGlhbGl6YXRpb24gc25pcHBldHMgZnJvbSBhbGwgYWNjZXNzaWJsZSBtb2R1bGVzXG4gICAgICAgIGNvbnN0IHNjb3BlID0gc2hhcmVTY29wZVtzaGFyZVNjb3BlTmFtZV07XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyID0gKG5hbWUsIHNoYXJlZCk9PntcbiAgICAgICAgICAgIHZhciBfYWN0aXZlVmVyc2lvbl9zaGFyZUNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHsgdmVyc2lvbiwgZWFnZXIgfSA9IHNoYXJlZDtcbiAgICAgICAgICAgIHNjb3BlW25hbWVdID0gc2NvcGVbbmFtZV0gfHwge307XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IHNjb3BlW25hbWVdO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlVmVyc2lvbiA9IHZlcnNpb25zW3ZlcnNpb25dO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlVmVyc2lvbkVhZ2VyID0gQm9vbGVhbihhY3RpdmVWZXJzaW9uICYmIChhY3RpdmVWZXJzaW9uLmVhZ2VyIHx8ICgoX2FjdGl2ZVZlcnNpb25fc2hhcmVDb25maWcgPSBhY3RpdmVWZXJzaW9uLnNoYXJlQ29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2FjdGl2ZVZlcnNpb25fc2hhcmVDb25maWcuZWFnZXIpKSk7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVZlcnNpb24gfHwgYWN0aXZlVmVyc2lvbi5zdHJhdGVneSAhPT0gJ2xvYWRlZC1maXJzdCcgJiYgIWFjdGl2ZVZlcnNpb24ubG9hZGVkICYmIChCb29sZWFuKCFlYWdlcikgIT09ICFhY3RpdmVWZXJzaW9uRWFnZXIgPyBlYWdlciA6IGhvc3ROYW1lID4gYWN0aXZlVmVyc2lvbi5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHZlcnNpb25zW3ZlcnNpb25dID0gc2hhcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbml0Rm4gPSAobW9kKT0+bW9kICYmIG1vZC5pbml0ICYmIG1vZC5pbml0KHNoYXJlU2NvcGVbc2hhcmVTY29wZU5hbWVdLCBpbml0U2NvcGUpO1xuICAgICAgICBjb25zdCBpbml0UmVtb3RlTW9kdWxlID0gYXN5bmMgKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kdWxlIH0gPSBhd2FpdCBob3N0LnJlbW90ZUhhbmRsZXIuZ2V0UmVtb3RlTW9kdWxlQW5kT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgaWQ6IGtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobW9kdWxlLmdldEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHMgPSBhd2FpdCBtb2R1bGUuZ2V0RW50cnkoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHMgPSBhd2FpdCBob3N0LnJlbW90ZUhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLmVycm9yTG9hZFJlbW90ZS5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206ICdydW50aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZmVjeWNsZTogJ2JlZm9yZUxvYWRTaGFyZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbW9kdWxlLmluaXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBpbml0Rm4ocmVtb3RlRW50cnlFeHBvcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmluaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3Qua2V5cyhob3N0Lm9wdGlvbnMuc2hhcmVkKS5mb3JFYWNoKChzaGFyZU5hbWUpPT57XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRBcnIgPSBob3N0Lm9wdGlvbnMuc2hhcmVkW3NoYXJlTmFtZV07XG4gICAgICAgICAgICBzaGFyZWRBcnIuZm9yRWFjaCgoc2hhcmVkKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaGFyZWQuc2NvcGUuaW5jbHVkZXMoc2hhcmVTY29wZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyKHNoYXJlTmFtZSwgc2hhcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IHN0cmF0ZWd5PT09J3ZlcnNpb24tZmlyc3QnIG5lZWQgdG8gYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXG4gICAgICAgIGlmIChob3N0Lm9wdGlvbnMuc2hhcmVTdHJhdGVneSA9PT0gJ3ZlcnNpb24tZmlyc3QnIHx8IHN0cmF0ZWd5ID09PSAndmVyc2lvbi1maXJzdCcpIHtcbiAgICAgICAgICAgIGhvc3Qub3B0aW9ucy5yZW1vdGVzLmZvckVhY2goKHJlbW90ZSk9PntcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlLnNoYXJlU2NvcGUgPT09IHNoYXJlU2NvcGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goaW5pdFJlbW90ZU1vZHVsZShyZW1vdGUubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICB9XG4gICAgLy8gVGhlIGxpYiBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgYXZhaWxhYmxlIGlmIHRoZSBzaGFyZWQgc2V0IGJ5IGVhZ2VyIG9yIHJ1bnRpbWUgaW5pdCBpcyBzZXQgb3IgdGhlIHNoYXJlZCBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgIC8vIDEuIElmIHRoZSBsb2FkZWQgc2hhcmVkIGFscmVhZHkgZXhpc3RzIGdsb2JhbGx5LCB0aGVuIGl0IHdpbGwgYmUgcmV1c2VkXG4gICAgLy8gMi4gSWYgbGliIGV4aXN0cyBpbiBsb2NhbCBzaGFyZWQsIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIC8vIDMuIElmIHRoZSBsb2NhbCBnZXQgcmV0dXJucyBzb21ldGhpbmcgb3RoZXIgdGhhbiBQcm9taXNlLCB0aGVuIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIGxvYWRTaGFyZVN5bmMocGtnTmFtZSwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2hhcmVPcHRpb25zID0gZ2V0VGFyZ2V0U2hhcmVkT3B0aW9ucyh7XG4gICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgZXh0cmFPcHRpb25zLFxuICAgICAgICAgICAgc2hhcmVJbmZvczogaG9zdC5vcHRpb25zLnNoYXJlZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNoYXJlT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogc2hhcmVPcHRpb25zLnNjb3BlKSB7XG4gICAgICAgICAgICBzaGFyZU9wdGlvbnMuc2NvcGUuZm9yRWFjaCgoc2hhcmVTY29wZSk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVTaGFyaW5nKHNoYXJlU2NvcGUsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3k6IHNoYXJlT3B0aW9ucy5zdHJhdGVneVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFNoYXJlZCA9IGdldFJlZ2lzdGVyZWRTaGFyZSh0aGlzLnNoYXJlU2NvcGVNYXAsIHBrZ05hbWUsIHNoYXJlT3B0aW9ucywgdGhpcy5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKTtcbiAgICAgICAgY29uc3QgYWRkVXNlSW4gPSAoc2hhcmVkKT0+e1xuICAgICAgICAgICAgaWYgKCFzaGFyZWQudXNlSW4pIHtcbiAgICAgICAgICAgICAgICBzaGFyZWQudXNlSW4gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFVuaXF1ZUl0ZW0oc2hhcmVkLnVzZUluLCBob3N0Lm9wdGlvbnMubmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZWdpc3RlcmVkU2hhcmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZ2lzdGVyZWRTaGFyZWQubGliID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYWRkVXNlSW4ocmVnaXN0ZXJlZFNoYXJlZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkU2hhcmVkLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcmVkU2hhcmVkLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkU2hhcmVkLmZyb20gPT09IGhvc3Qub3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZU9wdGlvbnMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNoYXJlZC5saWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZ2lzdGVyZWRTaGFyZWQuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gcmVnaXN0ZXJlZFNoYXJlZC5nZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIShtb2R1bGUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRVc2VJbihyZWdpc3RlcmVkU2hhcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGhvc3Qub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGliOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWQ6IHJlZ2lzdGVyZWRTaGFyZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFyZU9wdGlvbnMubGliKSB7XG4gICAgICAgICAgICBpZiAoIXNoYXJlT3B0aW9ucy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICBzaGFyZU9wdGlvbnMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaGFyZU9wdGlvbnMubGliO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFyZU9wdGlvbnMuZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGUgPSBzaGFyZU9wdGlvbnMuZ2V0KCk7XG4gICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IChleHRyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9ucy5mcm9tKSA9PT0gJ2J1aWxkJyA/IFJVTlRJTUVfMDA1IDogUlVOVElNRV8wMDY7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldFNob3J0RXJyb3JNc2coZXJyb3JDb2RlLCBydW50aW1lRGVzY01hcCwge1xuICAgICAgICAgICAgICAgICAgICBob3N0TmFtZTogaG9zdC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlZFBrZ05hbWU6IHBrZ05hbWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGFyZU9wdGlvbnMubGliID0gbW9kdWxlO1xuICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICAgICAgbG9hZGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZyb206IGhvc3Qub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgIGxpYjogc2hhcmVPcHRpb25zLmxpYixcbiAgICAgICAgICAgICAgICBzaGFyZWQ6IHNoYXJlT3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2hhcmVPcHRpb25zLmxpYjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0U2hvcnRFcnJvck1zZyhSVU5USU1FXzAwNiwgcnVudGltZURlc2NNYXAsIHtcbiAgICAgICAgICAgIGhvc3ROYW1lOiBob3N0Lm9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgIHNoYXJlZFBrZ05hbWU6IHBrZ05hbWVcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpbml0U2hhcmVTY29wZU1hcChzY29wZU5hbWUsIHNoYXJlU2NvcGUsIGV4dHJhT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3Njb3BlTmFtZV0gPSBzaGFyZVNjb3BlO1xuICAgICAgICB0aGlzLmhvb2tzLmxpZmVjeWNsZS5pbml0Q29udGFpbmVyU2hhcmVTY29wZU1hcC5lbWl0KHtcbiAgICAgICAgICAgIHNoYXJlU2NvcGUsXG4gICAgICAgICAgICBvcHRpb25zOiBob3N0Lm9wdGlvbnMsXG4gICAgICAgICAgICBvcmlnaW46IGhvc3QsXG4gICAgICAgICAgICBzY29wZU5hbWUsXG4gICAgICAgICAgICBob3N0U2hhcmVTY29wZU1hcDogZXh0cmFPcHRpb25zLmhvc3RTaGFyZVNjb3BlTWFwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRTaGFyZWQoeyBwa2dOYW1lLCBzaGFyZWQsIGZyb20sIGxpYiwgbG9hZGluZywgbG9hZGVkLCBnZXQgfSkge1xuICAgICAgICBjb25zdCB7IHZlcnNpb24sIHNjb3BlID0gJ2RlZmF1bHQnIH0gPSBzaGFyZWQsIHNoYXJlSW5mbyA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKHNoYXJlZCwgW1xuICAgICAgICAgICAgXCJ2ZXJzaW9uXCIsXG4gICAgICAgICAgICBcInNjb3BlXCJcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IEFycmF5LmlzQXJyYXkoc2NvcGUpID8gc2NvcGUgOiBbXG4gICAgICAgICAgICBzY29wZVxuICAgICAgICBdO1xuICAgICAgICBzY29wZXMuZm9yRWFjaCgoc2MpPT57XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhcmVTY29wZU1hcFtzY10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXJlU2NvcGVNYXBbc2NdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV1bdmVyc2lvbl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW3ZlcnNpb25dID0gX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBzY29wZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LCBzaGFyZUluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV1bdmVyc2lvbl0uZ2V0ID0gZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWdpc3RlcmVkU2hhcmVkID0gdGhpcy5zaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVt2ZXJzaW9uXTtcbiAgICAgICAgICAgIGlmIChsb2FkaW5nICYmICFyZWdpc3RlcmVkU2hhcmVkLmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkU2hhcmVkLmxvYWRpbmcgPSBsb2FkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvYWRlZCAmJiAhcmVnaXN0ZXJlZFNoYXJlZC5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkU2hhcmVkLmxvYWRlZCA9IGxvYWRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tICYmIHJlZ2lzdGVyZWRTaGFyZWQuZnJvbSAhPT0gZnJvbSkge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRTaGFyZWQuZnJvbSA9IGZyb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2V0R2xvYmFsU2hhcmVTY29wZU1hcChob3N0T3B0aW9ucykge1xuICAgICAgICBjb25zdCBnbG9iYWxTaGFyZVNjb3BlTWFwID0gZ2V0R2xvYmFsU2hhcmVTY29wZSgpO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaG9zdE9wdGlvbnMuaWQgfHwgaG9zdE9wdGlvbnMubmFtZTtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIgJiYgIWdsb2JhbFNoYXJlU2NvcGVNYXBbaWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIGdsb2JhbFNoYXJlU2NvcGVNYXBbaWRlbnRpZmllcl0gPSB0aGlzLnNoYXJlU2NvcGVNYXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoaG9zdCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSBuZXcgUGx1Z2luU3lzdGVtKHtcbiAgICAgICAgICAgIGFmdGVyUmVzb2x2ZTogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnYWZ0ZXJSZXNvbHZlJyksXG4gICAgICAgICAgICBiZWZvcmVMb2FkU2hhcmU6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2JlZm9yZUxvYWRTaGFyZScpLFxuICAgICAgICAgICAgLy8gbm90IHVzZWQgeWV0XG4gICAgICAgICAgICBsb2FkU2hhcmU6IG5ldyBBc3luY0hvb2soKSxcbiAgICAgICAgICAgIHJlc29sdmVTaGFyZTogbmV3IFN5bmNXYXRlcmZhbGxIb29rKCdyZXNvbHZlU2hhcmUnKSxcbiAgICAgICAgICAgIC8vIG1heWJlIHdpbGwgY2hhbmdlLCB0ZW1wb3JhcmlseSBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgICAgIGluaXRDb250YWluZXJTaGFyZVNjb3BlTWFwOiBuZXcgU3luY1dhdGVyZmFsbEhvb2soJ2luaXRDb250YWluZXJTaGFyZVNjb3BlTWFwJylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc2hhcmVTY29wZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLmluaXRUb2tlbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2V0R2xvYmFsU2hhcmVTY29wZU1hcChob3N0Lm9wdGlvbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgUmVtb3RlSGFuZGxlciB7XG4gICAgZm9ybWF0QW5kUmVnaXN0ZXJSZW1vdGUoZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXNlclJlbW90ZXMgPSB1c2VyT3B0aW9ucy5yZW1vdGVzIHx8IFtdO1xuICAgICAgICByZXR1cm4gdXNlclJlbW90ZXMucmVkdWNlKChyZXMsIHJlbW90ZSk9PntcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJSZW1vdGUocmVtb3RlLCByZXMsIHtcbiAgICAgICAgICAgICAgICBmb3JjZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwgZ2xvYmFsT3B0aW9ucy5yZW1vdGVzKTtcbiAgICB9XG4gICAgc2V0SWRUb1JlbW90ZU1hcChpZCwgcmVtb3RlTWF0Y2hJbmZvKSB7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlLCBleHBvc2UgfSA9IHJlbW90ZU1hdGNoSW5mbztcbiAgICAgICAgY29uc3QgeyBuYW1lLCBhbGlhcyB9ID0gcmVtb3RlO1xuICAgICAgICB0aGlzLmlkVG9SZW1vdGVNYXBbaWRdID0ge1xuICAgICAgICAgICAgbmFtZTogcmVtb3RlLm5hbWUsXG4gICAgICAgICAgICBleHBvc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFsaWFzICYmIGlkLnN0YXJ0c1dpdGgobmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkV2l0aEFsaWFzID0gaWQucmVwbGFjZShuYW1lLCBhbGlhcyk7XG4gICAgICAgICAgICB0aGlzLmlkVG9SZW1vdGVNYXBbaWRXaXRoQWxpYXNdID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHJlbW90ZS5uYW1lLFxuICAgICAgICAgICAgICAgIGV4cG9zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpYXMgJiYgaWQuc3RhcnRzV2l0aChhbGlhcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkV2l0aE5hbWUgPSBpZC5yZXBsYWNlKGFsaWFzLCBuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuaWRUb1JlbW90ZU1hcFtpZFdpdGhOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiByZW1vdGUubmFtZSxcbiAgICAgICAgICAgICAgICBleHBvc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIGFzeW5jIGxvYWRSZW1vdGUoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBsb2FkRmFjdG9yeSA9IHRydWUgfSA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIGxvYWRGYWN0b3J5OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gMS4gVmFsaWRhdGUgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIHJldHJpZXZlZCBtb2R1bGUuIFRoZXJlIGFyZSB0d28gbW9kdWxlIHJlcXVlc3QgbWV0aG9kczogcGtnTmFtZSArIGV4cG9zZSBhbmQgYWxpYXMgKyBleHBvc2UuXG4gICAgICAgICAgICAvLyAyLiBSZXF1ZXN0IHRoZSBzbmFwc2hvdCBpbmZvcm1hdGlvbiBvZiB0aGUgY3VycmVudCBob3N0IGFuZCBnbG9iYWxseSBzdG9yZSB0aGUgb2J0YWluZWQgc25hcHNob3QgaW5mb3JtYXRpb24uIFRoZSByZXRyaWV2ZWQgbW9kdWxlIGluZm9ybWF0aW9uIGlzIHBhcnRpYWxseSBvZmZsaW5lIGFuZCBwYXJ0aWFsbHkgb25saW5lLiBUaGUgb25saW5lIG1vZHVsZSBpbmZvcm1hdGlvbiB3aWxsIHJldHJpZXZlIHRoZSBtb2R1bGVzIHVzZWQgb25saW5lLlxuICAgICAgICAgICAgLy8gMy4gUmV0cmlldmUgdGhlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9mIHRoZSBjdXJyZW50IG1vZHVsZSBmcm9tIGdsb2JhbCAocmVtb3RlRW50cnkgYWRkcmVzcywgZXhwb3NlIHJlc291cmNlIGFkZHJlc3MpXG4gICAgICAgICAgICAvLyA0LiBBZnRlciByZXRyaWV2aW5nIHJlbW90ZUVudHJ5LCBjYWxsIHRoZSBpbml0IG9mIHRoZSBtb2R1bGUsIGFuZCB0aGVuIHJldHJpZXZlIHRoZSBleHBvcnRlZCBjb250ZW50IG9mIHRoZSBtb2R1bGUgdGhyb3VnaCBnZXRcbiAgICAgICAgICAgIC8vIGlkOiBwa2dOYW1lKEBmZWRlcmF0aW9uL2FwcDEpICsgZXhwb3NlKGJ1dHRvbikgPSBAZmVkZXJhdGlvbi9hcHAxL2J1dHRvblxuICAgICAgICAgICAgLy8gaWQ6IGFsaWFzKGFwcDEpICsgZXhwb3NlKGJ1dHRvbikgPSBhcHAxL2J1dHRvblxuICAgICAgICAgICAgLy8gaWQ6IGFsaWFzKGFwcDEvdXRpbHMpICsgZXhwb3NlKGxvYWRhc2gvc29ydCkgPSBhcHAxL3V0aWxzL2xvYWRhc2gvc29ydFxuICAgICAgICAgICAgY29uc3QgeyBtb2R1bGUsIG1vZHVsZU9wdGlvbnMsIHJlbW90ZU1hdGNoSW5mbyB9ID0gYXdhaXQgdGhpcy5nZXRSZW1vdGVNb2R1bGVBbmRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHBrZ05hbWVPckFsaWFzLCByZW1vdGUsIGV4cG9zZSwgaWQ6IGlkUmVzLCByZW1vdGVTbmFwc2hvdCB9ID0gcmVtb3RlTWF0Y2hJbmZvO1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlT3JGYWN0b3J5ID0gYXdhaXQgbW9kdWxlLmdldChpZFJlcywgZXhwb3NlLCBvcHRpb25zLCByZW1vdGVTbmFwc2hvdCk7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVXcmFwcGVyID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUub25Mb2FkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZFJlcyxcbiAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhcyxcbiAgICAgICAgICAgICAgICBleHBvc2UsXG4gICAgICAgICAgICAgICAgZXhwb3NlTW9kdWxlOiBsb2FkRmFjdG9yeSA/IG1vZHVsZU9yRmFjdG9yeSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBleHBvc2VNb2R1bGVGYWN0b3J5OiBsb2FkRmFjdG9yeSA/IHVuZGVmaW5lZCA6IG1vZHVsZU9yRmFjdG9yeSxcbiAgICAgICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbW9kdWxlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJbnN0YW5jZTogbW9kdWxlLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNldElkVG9SZW1vdGVNYXAoaWQsIHJlbW90ZU1hdGNoSW5mbyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZVdyYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlV3JhcHBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVPckZhY3Rvcnk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZyb20gPSAncnVudGltZScgfSA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIGZyb206ICdydW50aW1lJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxPdmVyID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuZXJyb3JMb2FkUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlOiAnb25Mb2FkJyxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFmYWlsT3Zlcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhaWxPdmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgYXN5bmMgcHJlbG9hZFJlbW90ZShwcmVsb2FkT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZVByZWxvYWRSZW1vdGUuZW1pdCh7XG4gICAgICAgICAgICBwcmVsb2FkT3BzOiBwcmVsb2FkT3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnM6IGhvc3Qub3B0aW9ucyxcbiAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJlbG9hZE9wcyA9IGZvcm1hdFByZWxvYWRBcmdzKGhvc3Qub3B0aW9ucy5yZW1vdGVzLCBwcmVsb2FkT3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByZWxvYWRPcHMubWFwKGFzeW5jIChvcHMpPT57XG4gICAgICAgICAgICBjb25zdCB7IHJlbW90ZSB9ID0gb3BzO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlSW5mbyA9IGdldFJlbW90ZUluZm8ocmVtb3RlKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90IH0gPSBhd2FpdCBob3N0LnNuYXBzaG90SGFuZGxlci5sb2FkUmVtb3RlU25hcHNob3RJbmZvKHtcbiAgICAgICAgICAgICAgICBtb2R1bGVJbmZvOiByZW1vdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYXNzZXRzID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuZ2VuZXJhdGVQcmVsb2FkQXNzZXRzLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdCxcbiAgICAgICAgICAgICAgICBwcmVsb2FkT3B0aW9uczogb3BzLFxuICAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgICAgICByZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYXNzZXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlbG9hZEFzc2V0cyhyZW1vdGVJbmZvLCBob3N0LCBhc3NldHMpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVtb3RlcyhyZW1vdGVzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgcmVtb3Rlcy5mb3JFYWNoKChyZW1vdGUpPT57XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyUmVtb3RlKHJlbW90ZSwgaG9zdC5vcHRpb25zLnJlbW90ZXMsIHtcbiAgICAgICAgICAgICAgICBmb3JjZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZW1vdGVNb2R1bGVBbmRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGlkIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgbG9hZFJlbW90ZUFyZ3M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2FkUmVtb3RlQXJncyA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZVJlcXVlc3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogaG9zdC5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2FkUmVtb3RlQXJncyA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmVycm9yTG9hZFJlbW90ZS5lbWl0KHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBob3N0Lm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0LFxuICAgICAgICAgICAgICAgIGZyb206ICdydW50aW1lJyxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGU6ICdiZWZvcmVSZXF1ZXN0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWxvYWRSZW1vdGVBcmdzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZDogaWRSZXMgfSA9IGxvYWRSZW1vdGVBcmdzO1xuICAgICAgICBjb25zdCByZW1vdGVTcGxpdEluZm8gPSBtYXRjaFJlbW90ZVdpdGhOYW1lQW5kRXhwb3NlKGhvc3Qub3B0aW9ucy5yZW1vdGVzLCBpZFJlcyk7XG4gICAgICAgIGFzc2VydChyZW1vdGVTcGxpdEluZm8sIGdldFNob3J0RXJyb3JNc2coUlVOVElNRV8wMDQsIHJ1bnRpbWVEZXNjTWFwLCB7XG4gICAgICAgICAgICBob3N0TmFtZTogaG9zdC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IGlkUmVzXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgeyByZW1vdGU6IHJhd1JlbW90ZSB9ID0gcmVtb3RlU3BsaXRJbmZvO1xuICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gZ2V0UmVtb3RlSW5mbyhyYXdSZW1vdGUpO1xuICAgICAgICBjb25zdCBtYXRjaEluZm8gPSBhd2FpdCBob3N0LnNoYXJlZEhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLmFmdGVyUmVzb2x2ZS5lbWl0KF9leHRlbmRzKHtcbiAgICAgICAgICAgIGlkOiBpZFJlc1xuICAgICAgICB9LCByZW1vdGVTcGxpdEluZm8sIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IGhvc3Qub3B0aW9ucyxcbiAgICAgICAgICAgIG9yaWdpbjogaG9zdCxcbiAgICAgICAgICAgIHJlbW90ZUluZm9cbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB7IHJlbW90ZSwgZXhwb3NlIH0gPSBtYXRjaEluZm87XG4gICAgICAgIGFzc2VydChyZW1vdGUgJiYgZXhwb3NlLCBgVGhlICdiZWZvcmVSZXF1ZXN0JyBob29rIHdhcyBleGVjdXRlZCwgYnV0IGl0IGZhaWxlZCB0byByZXR1cm4gdGhlIGNvcnJlY3QgJ3JlbW90ZScgYW5kICdleHBvc2UnIHZhbHVlcyB3aGlsZSBsb2FkaW5nICR7aWRSZXN9LmApO1xuICAgICAgICBsZXQgbW9kdWxlID0gaG9zdC5tb2R1bGVDYWNoZS5nZXQocmVtb3RlLm5hbWUpO1xuICAgICAgICBjb25zdCBtb2R1bGVPcHRpb25zID0ge1xuICAgICAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgICAgIHJlbW90ZUluZm9cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICAgIG1vZHVsZSA9IG5ldyBNb2R1bGUobW9kdWxlT3B0aW9ucyk7XG4gICAgICAgICAgICBob3N0Lm1vZHVsZUNhY2hlLnNldChyZW1vdGUubmFtZSwgbW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kdWxlLFxuICAgICAgICAgICAgbW9kdWxlT3B0aW9ucyxcbiAgICAgICAgICAgIHJlbW90ZU1hdGNoSW5mbzogbWF0Y2hJbmZvXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVtb3RlKHJlbW90ZSwgdGFyZ2V0UmVtb3Rlcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZVJlbW90ZSA9ICgpPT57XG4gICAgICAgICAgICBpZiAocmVtb3RlLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgaWYgYWxpYXMgZXF1YWxzIHRoZSBwcmVmaXggb2YgcmVtb3RlLm5hbWUgYW5kIHJlbW90ZS5hbGlhcywgaWYgc28sIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gQXMgbXVsdGktbGV2ZWwgcGF0aCByZWZlcmVuY2VzIGNhbm5vdCBndWFyYW50ZWUgdW5pcXVlIG5hbWVzLCBhbGlhcyBiZWluZyBhIHByZWZpeCBvZiByZW1vdGUubmFtZSBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgY29uc3QgZmluZEVxdWFsID0gdGFyZ2V0UmVtb3Rlcy5maW5kKChpdGVtKT0+e1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZW1fYWxpYXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdGUuYWxpYXMgJiYgKGl0ZW0ubmFtZS5zdGFydHNXaXRoKHJlbW90ZS5hbGlhcykgfHwgKChfaXRlbV9hbGlhcyA9IGl0ZW0uYWxpYXMpID09IG51bGwgPyB2b2lkIDAgOiBfaXRlbV9hbGlhcy5zdGFydHNXaXRoKHJlbW90ZS5hbGlhcykpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoIWZpbmRFcXVhbCwgYFRoZSBhbGlhcyAke3JlbW90ZS5hbGlhc30gb2YgcmVtb3RlICR7cmVtb3RlLm5hbWV9IGlzIG5vdCBhbGxvd2VkIHRvIGJlIHRoZSBwcmVmaXggb2YgJHtmaW5kRXF1YWwgJiYgZmluZEVxdWFsLm5hbWV9IG5hbWUgb3IgYWxpYXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB0aGUgcmVtb3RlIGVudHJ5IHRvIGEgY29tcGxldGUgcGF0aFxuICAgICAgICAgICAgaWYgKCdlbnRyeScgaW4gcmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQnJvd3NlckVudigpICYmICFyZW1vdGUuZW50cnkuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZS5lbnRyeSA9IG5ldyBVUkwocmVtb3RlLmVudHJ5LCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKS5ocmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVtb3RlLnNoYXJlU2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdGUuc2hhcmVTY29wZSA9IERFRkFVTFRfU0NPUEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlbW90ZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlLnR5cGUgPSBERUZBVUxUX1JFTU9URV9UWVBFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhvb2tzLmxpZmVjeWNsZS5iZWZvcmVSZWdpc3RlclJlbW90ZS5lbWl0KHtcbiAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFJlbW90ZSA9IHRhcmdldFJlbW90ZXMuZmluZCgoaXRlbSk9Pml0ZW0ubmFtZSA9PT0gcmVtb3RlLm5hbWUpO1xuICAgICAgICBpZiAoIXJlZ2lzdGVyZWRSZW1vdGUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVJlbW90ZSgpO1xuICAgICAgICAgICAgdGFyZ2V0UmVtb3Rlcy5wdXNoKHJlbW90ZSk7XG4gICAgICAgICAgICB0aGlzLmhvb2tzLmxpZmVjeWNsZS5yZWdpc3RlclJlbW90ZS5lbWl0KHtcbiAgICAgICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgIGBUaGUgcmVtb3RlIFwiJHtyZW1vdGUubmFtZX1cIiBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuYCxcbiAgICAgICAgICAgICAgICAnUGxlYXNlIG5vdGUgdGhhdCBvdmVycmlkaW5nIGl0IG1heSBjYXVzZSB1bmV4cGVjdGVkIGVycm9ycy4nXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yY2UpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgcmVnaXN0ZXJlZCByZW1vdGVcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlbW90ZShyZWdpc3RlcmVkUmVtb3RlKTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVSZW1vdGUoKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRSZW1vdGVzLnB1c2gocmVtb3RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzLmxpZmVjeWNsZS5yZWdpc3RlclJlbW90ZS5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3YXJuJDEobWVzc2FnZXMuam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVSZW1vdGUocmVtb3RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHJlbW90ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluZGV4ID0gaG9zdC5vcHRpb25zLnJlbW90ZXMuZmluZEluZGV4KChpdGVtKT0+aXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgIGlmIChyZW1vdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBob3N0Lm9wdGlvbnMucmVtb3Rlcy5zcGxpY2UocmVtb3RlSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9hZGVkTW9kdWxlID0gaG9zdC5tb2R1bGVDYWNoZS5nZXQocmVtb3RlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGxvYWRlZE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluZm8gPSBsb2FkZWRNb2R1bGUucmVtb3RlSW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSByZW1vdGVJbmZvLmVudHJ5R2xvYmFsTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoQ3VycmVudEdsb2JhbFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfT2JqZWN0X2dldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfT2JqZWN0X2dldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQ3VycmVudEdsb2JhbCwga2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9PYmplY3RfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIEN1cnJlbnRHbG9iYWxba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIEN1cnJlbnRHbG9iYWxba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVFbnRyeVVuaXF1ZUtleSA9IGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KGxvYWRlZE1vZHVsZS5yZW1vdGVJbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsTG9hZGluZ1tyZW1vdGVFbnRyeVVuaXF1ZUtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbExvYWRpbmdbcmVtb3RlRW50cnlVbmlxdWVLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob3N0LnNuYXBzaG90SGFuZGxlci5tYW5pZmVzdENhY2hlLmRlbGV0ZShyZW1vdGVJbmZvLmVudHJ5KTtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgdW5sb2FkZWQgc2hhcmVkIGFuZCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGxldCByZW1vdGVJbnNJZCA9IHJlbW90ZUluZm8uYnVpbGRWZXJzaW9uID8gY29tcG9zZUtleVdpdGhTZXBhcmF0b3IocmVtb3RlSW5mby5uYW1lLCByZW1vdGVJbmZvLmJ1aWxkVmVyc2lvbikgOiByZW1vdGVJbmZvLm5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlSW5zSW5kZXggPSBDdXJyZW50R2xvYmFsLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX18uZmluZEluZGV4KChpbnMpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdGVJbmZvLmJ1aWxkVmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucy5vcHRpb25zLmlkID09PSByZW1vdGVJbnNJZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnMubmFtZSA9PT0gcmVtb3RlSW5zSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlSW5zSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUlucyA9IEN1cnJlbnRHbG9iYWwuX19GRURFUkFUSU9OX18uX19JTlNUQU5DRVNfX1tyZW1vdGVJbnNJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUluc0lkID0gcmVtb3RlSW5zLm9wdGlvbnMuaWQgfHwgcmVtb3RlSW5zSWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNoYXJlU2NvcGVNYXAgPSBnZXRHbG9iYWxTaGFyZVNjb3BlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc0FsbFNoYXJlZE5vdFVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkRGVsZXRlS2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhnbG9iYWxTaGFyZVNjb3BlTWFwKS5mb3JFYWNoKChpbnN0SWQpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZVNjb3BlTWFwID0gZ2xvYmFsU2hhcmVTY29wZU1hcFtpbnN0SWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVTY29wZU1hcCAmJiBPYmplY3Qua2V5cyhzaGFyZVNjb3BlTWFwKS5mb3JFYWNoKChzaGFyZVNjb3BlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlU2NvcGVWYWwgPSBzaGFyZVNjb3BlTWFwW3NoYXJlU2NvcGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGVWYWwgJiYgT2JqZWN0LmtleXMoc2hhcmVTY29wZVZhbCkuZm9yRWFjaCgoc2hhcmVOYW1lKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWRQa2dzID0gc2hhcmVTY29wZVZhbFtzaGFyZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRQa2dzICYmIE9iamVjdC5rZXlzKHNoYXJlZFBrZ3MpLmZvckVhY2goKHNoYXJlVmVyc2lvbik9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlZCA9IHNoYXJlZFBrZ3Nbc2hhcmVWZXJzaW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZWQgJiYgdHlwZW9mIHNoYXJlZCA9PT0gJ29iamVjdCcgJiYgc2hhcmVkLmZyb20gPT09IHJlbW90ZUluZm8ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZWQubG9hZGVkIHx8IHNoYXJlZC5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZC51c2VJbiA9IHNoYXJlZC51c2VJbi5maWx0ZXIoKHVzZWRIb3N0TmFtZSk9PnVzZWRIb3N0TmFtZSAhPT0gcmVtb3RlSW5mby5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXJlZC51c2VJbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsU2hhcmVkTm90VXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZERlbGV0ZUtleXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlVmVyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkRGVsZXRlS2V5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWxsU2hhcmVkTm90VXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlSW5zLnNoYXJlU2NvcGVNYXAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBnbG9iYWxTaGFyZVNjb3BlTWFwW3JlbW90ZUluc0lkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZWVkRGVsZXRlS2V5cy5mb3JFYWNoKChbaW5zSWQsIHNoYXJlU2NvcGUsIHNoYXJlTmFtZSwgc2hhcmVWZXJzaW9uXSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZF9zaGFyZVNjb3BlX3NoYXJlTmFtZSwgX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZSwgX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWQgPSBnbG9iYWxTaGFyZVNjb3BlTWFwW2luc0lkXSkgPT0gbnVsbCA/IHRydWUgOiAoX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZSA9IF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkW3NoYXJlU2NvcGVdKSA9PSBudWxsID8gdHJ1ZSA6IChfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZF9zaGFyZVNjb3BlX3NoYXJlTmFtZSA9IF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGVbc2hhcmVOYW1lXSkgPT0gbnVsbCA/IHRydWUgOiBkZWxldGUgX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZV9zaGFyZU5hbWVbc2hhcmVWZXJzaW9uXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIEN1cnJlbnRHbG9iYWwuX19GRURFUkFUSU9OX18uX19JTlNUQU5DRVNfXy5zcGxpY2UocmVtb3RlSW5zSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGhvc3RHbG9iYWxTbmFwc2hvdCB9ID0gZ2V0R2xvYmFsUmVtb3RlSW5mbyhyZW1vdGUsIGhvc3QpO1xuICAgICAgICAgICAgICAgIGlmIChob3N0R2xvYmFsU25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlS2V5ID0gaG9zdEdsb2JhbFNuYXBzaG90ICYmICdyZW1vdGVzSW5mbycgaW4gaG9zdEdsb2JhbFNuYXBzaG90ICYmIGhvc3RHbG9iYWxTbmFwc2hvdC5yZW1vdGVzSW5mbyAmJiBnZXRJbmZvV2l0aG91dFR5cGUoaG9zdEdsb2JhbFNuYXBzaG90LnJlbW90ZXNJbmZvLCByZW1vdGUubmFtZSkua2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaG9zdEdsb2JhbFNuYXBzaG90LnJlbW90ZXNJbmZvW3JlbW90ZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBCb29sZWFuKEdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX01BTklGRVNUX0xPQURJTkdfX1tyZW1vdGVLZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBHbG9iYWwuX19GRURFUkFUSU9OX18uX19NQU5JRkVTVF9MT0FESU5HX19bcmVtb3RlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob3N0Lm1vZHVsZUNhY2hlLmRlbGV0ZShyZW1vdGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZygncmVtb3ZlUmVtb3RlIGZhaWw6ICcsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoaG9zdCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSBuZXcgUGx1Z2luU3lzdGVtKHtcbiAgICAgICAgICAgIGJlZm9yZVJlZ2lzdGVyUmVtb3RlOiBuZXcgU3luY1dhdGVyZmFsbEhvb2soJ2JlZm9yZVJlZ2lzdGVyUmVtb3RlJyksXG4gICAgICAgICAgICByZWdpc3RlclJlbW90ZTogbmV3IFN5bmNXYXRlcmZhbGxIb29rKCdyZWdpc3RlclJlbW90ZScpLFxuICAgICAgICAgICAgYmVmb3JlUmVxdWVzdDogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnYmVmb3JlUmVxdWVzdCcpLFxuICAgICAgICAgICAgb25Mb2FkOiBuZXcgQXN5bmNIb29rKCdvbkxvYWQnKSxcbiAgICAgICAgICAgIGhhbmRsZVByZWxvYWRNb2R1bGU6IG5ldyBTeW5jSG9vaygnaGFuZGxlUHJlbG9hZE1vZHVsZScpLFxuICAgICAgICAgICAgZXJyb3JMb2FkUmVtb3RlOiBuZXcgQXN5bmNIb29rKCdlcnJvckxvYWRSZW1vdGUnKSxcbiAgICAgICAgICAgIGJlZm9yZVByZWxvYWRSZW1vdGU6IG5ldyBBc3luY0hvb2soJ2JlZm9yZVByZWxvYWRSZW1vdGUnKSxcbiAgICAgICAgICAgIGdlbmVyYXRlUHJlbG9hZEFzc2V0czogbmV3IEFzeW5jSG9vaygnZ2VuZXJhdGVQcmVsb2FkQXNzZXRzJyksXG4gICAgICAgICAgICAvLyBub3QgdXNlZCB5ZXRcbiAgICAgICAgICAgIGFmdGVyUHJlbG9hZFJlbW90ZTogbmV3IEFzeW5jSG9vaygpLFxuICAgICAgICAgICAgbG9hZEVudHJ5OiBuZXcgQXN5bmNIb29rKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuaWRUb1JlbW90ZU1hcCA9IHt9O1xuICAgIH1cbn1cblxuY29uc3QgVVNFX1NOQVBTSE9UID0gdHlwZW9mIEZFREVSQVRJT05fT1BUSU1JWkVfTk9fU05BUFNIT1RfUExVR0lOID09PSAnYm9vbGVhbicgPyAhRkVERVJBVElPTl9PUFRJTUlaRV9OT19TTkFQU0hPVF9QTFVHSU4gOiB0cnVlOyAvLyBEZWZhdWx0IHRvIHRydWUgKHVzZSBzbmFwc2hvdCkgd2hlbiBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5jbGFzcyBNb2R1bGVGZWRlcmF0aW9uIHtcbiAgICBpbml0T3B0aW9ucyh1c2VyT3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUGx1Z2lucyh1c2VyT3B0aW9ucy5wbHVnaW5zKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZm9ybWF0T3B0aW9ucyh0aGlzLm9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRTaGFyZShwa2dOYW1lLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkSGFuZGxlci5sb2FkU2hhcmUocGtnTmFtZSwgZXh0cmFPcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVGhlIGxpYiBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgYXZhaWxhYmxlIGlmIHRoZSBzaGFyZWQgc2V0IGJ5IGVhZ2VyIG9yIHJ1bnRpbWUgaW5pdCBpcyBzZXQgb3IgdGhlIHNoYXJlZCBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgIC8vIDEuIElmIHRoZSBsb2FkZWQgc2hhcmVkIGFscmVhZHkgZXhpc3RzIGdsb2JhbGx5LCB0aGVuIGl0IHdpbGwgYmUgcmV1c2VkXG4gICAgLy8gMi4gSWYgbGliIGV4aXN0cyBpbiBsb2NhbCBzaGFyZWQsIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIC8vIDMuIElmIHRoZSBsb2NhbCBnZXQgcmV0dXJucyBzb21ldGhpbmcgb3RoZXIgdGhhbiBQcm9taXNlLCB0aGVuIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIGxvYWRTaGFyZVN5bmMocGtnTmFtZSwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXJlZEhhbmRsZXIubG9hZFNoYXJlU3luYyhwa2dOYW1lLCBleHRyYU9wdGlvbnMpO1xuICAgIH1cbiAgICBpbml0aWFsaXplU2hhcmluZyhzaGFyZVNjb3BlTmFtZSA9IERFRkFVTFRfU0NPUEUsIGV4dHJhT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZWRIYW5kbGVyLmluaXRpYWxpemVTaGFyaW5nKHNoYXJlU2NvcGVOYW1lLCBleHRyYU9wdGlvbnMpO1xuICAgIH1cbiAgICBpbml0UmF3Q29udGFpbmVyKG5hbWUsIHVybCwgY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHJlbW90ZUluZm8gPSBnZXRSZW1vdGVJbmZvKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBlbnRyeTogdXJsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBuZXcgTW9kdWxlKHtcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMsXG4gICAgICAgICAgICByZW1vdGVJbmZvXG4gICAgICAgIH0pO1xuICAgICAgICBtb2R1bGUucmVtb3RlRW50cnlFeHBvcnRzID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLm1vZHVsZUNhY2hlLnNldChuYW1lLCBtb2R1bGUpO1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgYXN5bmMgbG9hZFJlbW90ZShpZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVIYW5kbGVyLmxvYWRSZW1vdGUoaWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIGFzeW5jIHByZWxvYWRSZW1vdGUocHJlbG9hZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlSGFuZGxlci5wcmVsb2FkUmVtb3RlKHByZWxvYWRPcHRpb25zKTtcbiAgICB9XG4gICAgaW5pdFNoYXJlU2NvcGVNYXAoc2NvcGVOYW1lLCBzaGFyZVNjb3BlLCBleHRyYU9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnNoYXJlZEhhbmRsZXIuaW5pdFNoYXJlU2NvcGVNYXAoc2NvcGVOYW1lLCBzaGFyZVNjb3BlLCBleHRyYU9wdGlvbnMpO1xuICAgIH1cbiAgICBmb3JtYXRPcHRpb25zKGdsb2JhbE9wdGlvbnMsIHVzZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVkIH0gPSBmb3JtYXRTaGFyZUNvbmZpZ3MoZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IHVzZXJPcHRpb25zOiB1c2VyT3B0aW9uc1Jlcywgb3B0aW9uczogZ2xvYmFsT3B0aW9uc1JlcyB9ID0gdGhpcy5ob29rcy5saWZlY3ljbGUuYmVmb3JlSW5pdC5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcyxcbiAgICAgICAgICAgIHVzZXJPcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9uczogZ2xvYmFsT3B0aW9ucyxcbiAgICAgICAgICAgIHNoYXJlSW5mbzogc2hhcmVkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZW1vdGVzID0gdGhpcy5yZW1vdGVIYW5kbGVyLmZvcm1hdEFuZFJlZ2lzdGVyUmVtb3RlKGdsb2JhbE9wdGlvbnNSZXMsIHVzZXJPcHRpb25zUmVzKTtcbiAgICAgICAgY29uc3QgeyBzaGFyZWQ6IGhhbmRsZWRTaGFyZWQgfSA9IHRoaXMuc2hhcmVkSGFuZGxlci5yZWdpc3RlclNoYXJlZChnbG9iYWxPcHRpb25zUmVzLCB1c2VyT3B0aW9uc1Jlcyk7XG4gICAgICAgIGNvbnN0IHBsdWdpbnMgPSBbXG4gICAgICAgICAgICAuLi5nbG9iYWxPcHRpb25zUmVzLnBsdWdpbnNcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHVzZXJPcHRpb25zUmVzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIHVzZXJPcHRpb25zUmVzLnBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKT0+e1xuICAgICAgICAgICAgICAgIGlmICghcGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnNSZXMgPSBfZXh0ZW5kcyh7fSwgZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMsIHtcbiAgICAgICAgICAgIHBsdWdpbnMsXG4gICAgICAgICAgICByZW1vdGVzLFxuICAgICAgICAgICAgc2hhcmVkOiBoYW5kbGVkU2hhcmVkXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhvb2tzLmxpZmVjeWNsZS5pbml0LmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luOiB0aGlzLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1Jlc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNSZXM7XG4gICAgfVxuICAgIHJlZ2lzdGVyUGx1Z2lucyhwbHVnaW5zKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpblJlcyA9IHJlZ2lzdGVyUGx1Z2lucyhwbHVnaW5zLCB0aGlzKTtcbiAgICAgICAgLy8gTWVyZ2UgcGx1Z2luXG4gICAgICAgIHRoaXMub3B0aW9ucy5wbHVnaW5zID0gdGhpcy5vcHRpb25zLnBsdWdpbnMucmVkdWNlKChyZXMsIHBsdWdpbik9PntcbiAgICAgICAgICAgIGlmICghcGx1Z2luKSByZXR1cm4gcmVzO1xuICAgICAgICAgICAgaWYgKHJlcyAmJiAhcmVzLmZpbmQoKGl0ZW0pPT5pdGVtLm5hbWUgPT09IHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBwbHVnaW5SZXMgfHwgW10pO1xuICAgIH1cbiAgICByZWdpc3RlclJlbW90ZXMocmVtb3Rlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVIYW5kbGVyLnJlZ2lzdGVyUmVtb3RlcyhyZW1vdGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJTaGFyZWQoc2hhcmVkKSB7XG4gICAgICAgIHRoaXMuc2hhcmVkSGFuZGxlci5yZWdpc3RlclNoYXJlZCh0aGlzLm9wdGlvbnMsIF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgICAgIHNoYXJlZFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHVzZXJPcHRpb25zKXtcbiAgICAgICAgdGhpcy5ob29rcyA9IG5ldyBQbHVnaW5TeXN0ZW0oe1xuICAgICAgICAgICAgYmVmb3JlSW5pdDogbmV3IFN5bmNXYXRlcmZhbGxIb29rKCdiZWZvcmVJbml0JyksXG4gICAgICAgICAgICBpbml0OiBuZXcgU3luY0hvb2soKSxcbiAgICAgICAgICAgIC8vIG1heWJlIHdpbGwgY2hhbmdlLCB0ZW1wb3JhcmlseSBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgICAgIGJlZm9yZUluaXRDb250YWluZXI6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2JlZm9yZUluaXRDb250YWluZXInKSxcbiAgICAgICAgICAgIC8vIG1heWJlIHdpbGwgY2hhbmdlLCB0ZW1wb3JhcmlseSBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgICAgIGluaXRDb250YWluZXI6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2luaXRDb250YWluZXInKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCIwLjE4LjNcIjtcbiAgICAgICAgdGhpcy5tb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sb2FkZXJIb29rID0gbmV3IFBsdWdpblN5c3RlbSh7XG4gICAgICAgICAgICAvLyBGSVhNRTogbWF5IG5vdCBiZSBzdWl0YWJsZSAsIG5vdCBvcGVuIHRvIHRoZSBwdWJsaWMgeWV0XG4gICAgICAgICAgICBnZXRNb2R1bGVJbmZvOiBuZXcgU3luY0hvb2soKSxcbiAgICAgICAgICAgIGNyZWF0ZVNjcmlwdDogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICBjcmVhdGVMaW5rOiBuZXcgU3luY0hvb2soKSxcbiAgICAgICAgICAgIGZldGNoOiBuZXcgQXN5bmNIb29rKCksXG4gICAgICAgICAgICBsb2FkRW50cnlFcnJvcjogbmV3IEFzeW5jSG9vaygpLFxuICAgICAgICAgICAgZ2V0TW9kdWxlRmFjdG9yeTogbmV3IEFzeW5jSG9vaygpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJyaWRnZUhvb2sgPSBuZXcgUGx1Z2luU3lzdGVtKHtcbiAgICAgICAgICAgIGJlZm9yZUJyaWRnZVJlbmRlcjogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICBhZnRlckJyaWRnZVJlbmRlcjogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICBiZWZvcmVCcmlkZ2VEZXN0cm95OiBuZXcgU3luY0hvb2soKSxcbiAgICAgICAgICAgIGFmdGVyQnJpZGdlRGVzdHJveTogbmV3IFN5bmNIb29rKClcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBsdWdpbnMgPSBVU0VfU05BUFNIT1QgPyBbXG4gICAgICAgICAgICBzbmFwc2hvdFBsdWdpbigpLFxuICAgICAgICAgICAgZ2VuZXJhdGVQcmVsb2FkQXNzZXRzUGx1Z2luKClcbiAgICAgICAgXSA6IFtdO1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGUgZGV0YWlscyBvZiB0aGUgb3B0aW9uc1xuICAgICAgICAvLyBJbml0aWFsaXplIG9wdGlvbnMgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGlkOiBnZXRCdWlsZGVySWQoKSxcbiAgICAgICAgICAgIG5hbWU6IHVzZXJPcHRpb25zLm5hbWUsXG4gICAgICAgICAgICBwbHVnaW5zLFxuICAgICAgICAgICAgcmVtb3RlczogW10sXG4gICAgICAgICAgICBzaGFyZWQ6IHt9LFxuICAgICAgICAgICAgaW5Ccm93c2VyOiBpc0Jyb3dzZXJFbnYoKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSB1c2VyT3B0aW9ucy5uYW1lO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgdGhpcy5zbmFwc2hvdEhhbmRsZXIgPSBuZXcgU25hcHNob3RIYW5kbGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnNoYXJlZEhhbmRsZXIgPSBuZXcgU2hhcmVkSGFuZGxlcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdGVIYW5kbGVyID0gbmV3IFJlbW90ZUhhbmRsZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc2hhcmVTY29wZU1hcCA9IHRoaXMuc2hhcmVkSGFuZGxlci5zaGFyZVNjb3BlTWFwO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUGx1Z2lucyhbXG4gICAgICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucy5wbHVnaW5zLFxuICAgICAgICAgICAgLi4udXNlck9wdGlvbnMucGx1Z2lucyB8fCBbXVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5mb3JtYXRPcHRpb25zKGRlZmF1bHRPcHRpb25zLCB1c2VyT3B0aW9ucyk7XG4gICAgfVxufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsXG59KTtcblxuZXhwb3J0IHsgQ3VycmVudEdsb2JhbCwgR2xvYmFsLCBNb2R1bGUsIE1vZHVsZUZlZGVyYXRpb24sIGFkZEdsb2JhbFNuYXBzaG90LCBhc3NlcnQsIGdldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvciwgZ2V0R2xvYmFsU25hcHNob3QsIGdldEluZm9XaXRob3V0VHlwZSwgZ2V0UmVnaXN0ZXJlZFNoYXJlLCBnZXRSZW1vdGVFbnRyeSwgZ2V0UmVtb3RlSW5mbywgaGVscGVycywgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbCwgbWF0Y2hSZW1vdGVXaXRoTmFtZUFuZEV4cG9zZSwgcmVnaXN0ZXJHbG9iYWxQbHVnaW5zLCByZXNldEZlZGVyYXRpb25HbG9iYWxJbmZvLCBzYWZlV3JhcHBlciwgc2F0aXNmeSwgc2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yLCBzZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UsIGluZGV4IGFzIHR5cGVzIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/runtime-core/dist/index.esm.js\n");

/***/ }),

/***/ "./node_modules/@module-federation/runtime-core/dist/polyfills.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@module-federation/runtime-core/dist/polyfills.esm.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _extends),\n/* harmony export */   a: () => (/* binding */ _object_without_properties_loose)\n/* harmony export */ });\nfunction _extends() {\n    _extends = Object.assign || function assign(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3J1bnRpbWUtY29yZS9kaXN0L3BvbHlmaWxscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxXaW4gMTFcXERlc2t0b3BcXFJlYWN0LU1pY3JvRnJvbnRlbmRcXG1pY3JvLWZyb250ZW5kXFxjaGFydFxcbm9kZV9tb2R1bGVzXFxAbW9kdWxlLWZlZGVyYXRpb25cXHJ1bnRpbWUtY29yZVxcZGlzdFxccG9seWZpbGxzLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2UpaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGZvcihpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgeyBfZXh0ZW5kcyBhcyBfLCBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSBhcyBhIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/runtime-core/dist/polyfills.esm.js\n");

/***/ }),

/***/ "./node_modules/@module-federation/runtime/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@module-federation/runtime/dist/index.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Module: () => (/* reexport safe */ _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Module),\n/* harmony export */   ModuleFederation: () => (/* reexport safe */ _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ModuleFederation),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   getInstance: () => (/* binding */ getInstance),\n/* harmony export */   getRemoteEntry: () => (/* reexport safe */ _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getRemoteEntry),\n/* harmony export */   getRemoteInfo: () => (/* reexport safe */ _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getRemoteInfo),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadRemote: () => (/* binding */ loadRemote),\n/* harmony export */   loadScript: () => (/* reexport safe */ _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.loadScript),\n/* harmony export */   loadScriptNode: () => (/* reexport safe */ _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.loadScriptNode),\n/* harmony export */   loadShare: () => (/* binding */ loadShare),\n/* harmony export */   loadShareSync: () => (/* binding */ loadShareSync),\n/* harmony export */   preloadRemote: () => (/* binding */ preloadRemote),\n/* harmony export */   registerGlobalPlugins: () => (/* reexport safe */ _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerGlobalPlugins),\n/* harmony export */   registerPlugins: () => (/* binding */ registerPlugins),\n/* harmony export */   registerRemotes: () => (/* binding */ registerRemotes),\n/* harmony export */   registerShared: () => (/* binding */ registerShared)\n/* harmony export */ });\n/* harmony import */ var _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @module-federation/runtime-core */ \"./node_modules/@module-federation/runtime-core/dist/index.esm.js\");\n/* harmony import */ var _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @module-federation/error-codes */ \"./node_modules/@module-federation/error-codes/dist/index.esm.mjs\");\n/* harmony import */ var _utils_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.esm.js */ \"./node_modules/@module-federation/runtime/dist/utils.esm.js\");\n\n\n\n\n\nfunction createInstance(options) {\n    // Retrieve debug constructor\n    const ModuleFederationConstructor = (0,_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getGlobalFederationConstructor)() || _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ModuleFederation;\n    const instance = new ModuleFederationConstructor(options);\n    (0,_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setGlobalFederationInstance)(instance);\n    return instance;\n}\nlet FederationInstance = null;\n/**\n * @deprecated Use createInstance or getInstance instead\n */ function init(options) {\n    // Retrieve the same instance with the same name\n    const instance = (0,_utils_esm_js__WEBPACK_IMPORTED_MODULE_2__.g)(options.name, options.version);\n    if (!instance) {\n        FederationInstance = createInstance(options);\n        return FederationInstance;\n    } else {\n        // Merge options\n        instance.initOptions(options);\n        if (!FederationInstance) {\n            FederationInstance = instance;\n        }\n        return instance;\n    }\n}\nfunction loadRemote(...args) {\n    (0,_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assert)(FederationInstance, (0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.RUNTIME_009, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.runtimeDescMap));\n    const loadRemote1 = FederationInstance.loadRemote;\n    // eslint-disable-next-line prefer-spread\n    return loadRemote1.apply(FederationInstance, args);\n}\nfunction loadShare(...args) {\n    (0,_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assert)(FederationInstance, (0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.RUNTIME_009, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.runtimeDescMap));\n    // eslint-disable-next-line prefer-spread\n    const loadShare1 = FederationInstance.loadShare;\n    return loadShare1.apply(FederationInstance, args);\n}\nfunction loadShareSync(...args) {\n    (0,_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assert)(FederationInstance, (0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.RUNTIME_009, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.runtimeDescMap));\n    const loadShareSync1 = FederationInstance.loadShareSync;\n    // eslint-disable-next-line prefer-spread\n    return loadShareSync1.apply(FederationInstance, args);\n}\nfunction preloadRemote(...args) {\n    (0,_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assert)(FederationInstance, (0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.RUNTIME_009, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.runtimeDescMap));\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.preloadRemote.apply(FederationInstance, args);\n}\nfunction registerRemotes(...args) {\n    (0,_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assert)(FederationInstance, (0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.RUNTIME_009, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.runtimeDescMap));\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.registerRemotes.apply(FederationInstance, args);\n}\nfunction registerPlugins(...args) {\n    (0,_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assert)(FederationInstance, (0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.RUNTIME_009, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.runtimeDescMap));\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.registerPlugins.apply(FederationInstance, args);\n}\nfunction getInstance() {\n    return FederationInstance;\n}\nfunction registerShared(...args) {\n    (0,_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assert)(FederationInstance, (0,_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.getShortErrorMsg)(_module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.RUNTIME_009, _module_federation_error_codes__WEBPACK_IMPORTED_MODULE_1__.runtimeDescMap));\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.registerShared.apply(FederationInstance, args);\n}\n// Inject for debug\n(0,_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setGlobalFederationConstructor)(_module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ModuleFederation);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3J1bnRpbWUvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0s7QUFDWDtBQUM5RDtBQUM3Qjs7QUFFbEU7QUFDQTtBQUNBLHdDQUF3QywrRkFBOEIsTUFBTSw2RUFBZ0I7QUFDNUY7QUFDQSxJQUFJLDRGQUEyQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnREFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQU0scUJBQXFCLGdGQUFnQixDQUFDLHVFQUFXLEVBQUUsMEVBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQU0scUJBQXFCLGdGQUFnQixDQUFDLHVFQUFXLEVBQUUsMEVBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQU0scUJBQXFCLGdGQUFnQixDQUFDLHVFQUFXLEVBQUUsMEVBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQU0scUJBQXFCLGdGQUFnQixDQUFDLHVFQUFXLEVBQUUsMEVBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVFQUFNLHFCQUFxQixnRkFBZ0IsQ0FBQyx1RUFBVyxFQUFFLDBFQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1RUFBTSxxQkFBcUIsZ0ZBQWdCLENBQUMsdUVBQVcsRUFBRSwwRUFBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQU0scUJBQXFCLGdGQUFnQixDQUFDLHVFQUFXLEVBQUUsMEVBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBOEIsQ0FBQyw2RUFBZ0I7O0FBRXFHIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFdpbiAxMVxcRGVza3RvcFxcUmVhY3QtTWljcm9Gcm9udGVuZFxcbWljcm8tZnJvbnRlbmRcXGNoYXJ0XFxub2RlX21vZHVsZXNcXEBtb2R1bGUtZmVkZXJhdGlvblxccnVudGltZVxcZGlzdFxcaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvciwgTW9kdWxlRmVkZXJhdGlvbiwgZ2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yLCBzZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UsIGFzc2VydCB9IGZyb20gJ0Btb2R1bGUtZmVkZXJhdGlvbi9ydW50aW1lLWNvcmUnO1xuZXhwb3J0IHsgTW9kdWxlLCBNb2R1bGVGZWRlcmF0aW9uLCBnZXRSZW1vdGVFbnRyeSwgZ2V0UmVtb3RlSW5mbywgbG9hZFNjcmlwdCwgbG9hZFNjcmlwdE5vZGUsIHJlZ2lzdGVyR2xvYmFsUGx1Z2lucyB9IGZyb20gJ0Btb2R1bGUtZmVkZXJhdGlvbi9ydW50aW1lLWNvcmUnO1xuaW1wb3J0IHsgZ2V0U2hvcnRFcnJvck1zZywgUlVOVElNRV8wMDksIHJ1bnRpbWVEZXNjTWFwIH0gZnJvbSAnQG1vZHVsZS1mZWRlcmF0aW9uL2Vycm9yLWNvZGVzJztcbmltcG9ydCB7IGcgYXMgZ2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlIH0gZnJvbSAnLi91dGlscy5lc20uanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShvcHRpb25zKSB7XG4gICAgLy8gUmV0cmlldmUgZGVidWcgY29uc3RydWN0b3JcbiAgICBjb25zdCBNb2R1bGVGZWRlcmF0aW9uQ29uc3RydWN0b3IgPSBnZXRHbG9iYWxGZWRlcmF0aW9uQ29uc3RydWN0b3IoKSB8fCBNb2R1bGVGZWRlcmF0aW9uO1xuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IE1vZHVsZUZlZGVyYXRpb25Db25zdHJ1Y3RvcihvcHRpb25zKTtcbiAgICBzZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmxldCBGZWRlcmF0aW9uSW5zdGFuY2UgPSBudWxsO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgY3JlYXRlSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2UgaW5zdGVhZFxuICovIGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgIC8vIFJldHJpZXZlIHRoZSBzYW1lIGluc3RhbmNlIHdpdGggdGhlIHNhbWUgbmFtZVxuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlKG9wdGlvbnMubmFtZSwgb3B0aW9ucy52ZXJzaW9uKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgIEZlZGVyYXRpb25JbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gRmVkZXJhdGlvbkluc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIG9wdGlvbnNcbiAgICAgICAgaW5zdGFuY2UuaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmICghRmVkZXJhdGlvbkluc3RhbmNlKSB7XG4gICAgICAgICAgICBGZWRlcmF0aW9uSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9hZFJlbW90ZSguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgZ2V0U2hvcnRFcnJvck1zZyhSVU5USU1FXzAwOSwgcnVudGltZURlc2NNYXApKTtcbiAgICBjb25zdCBsb2FkUmVtb3RlMSA9IEZlZGVyYXRpb25JbnN0YW5jZS5sb2FkUmVtb3RlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIGxvYWRSZW1vdGUxLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiBsb2FkU2hhcmUoLi4uYXJncykge1xuICAgIGFzc2VydChGZWRlcmF0aW9uSW5zdGFuY2UsIGdldFNob3J0RXJyb3JNc2coUlVOVElNRV8wMDksIHJ1bnRpbWVEZXNjTWFwKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICBjb25zdCBsb2FkU2hhcmUxID0gRmVkZXJhdGlvbkluc3RhbmNlLmxvYWRTaGFyZTtcbiAgICByZXR1cm4gbG9hZFNoYXJlMS5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xufVxuZnVuY3Rpb24gbG9hZFNoYXJlU3luYyguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgZ2V0U2hvcnRFcnJvck1zZyhSVU5USU1FXzAwOSwgcnVudGltZURlc2NNYXApKTtcbiAgICBjb25zdCBsb2FkU2hhcmVTeW5jMSA9IEZlZGVyYXRpb25JbnN0YW5jZS5sb2FkU2hhcmVTeW5jO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIGxvYWRTaGFyZVN5bmMxLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiBwcmVsb2FkUmVtb3RlKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoRmVkZXJhdGlvbkluc3RhbmNlLCBnZXRTaG9ydEVycm9yTXNnKFJVTlRJTUVfMDA5LCBydW50aW1lRGVzY01hcCkpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIEZlZGVyYXRpb25JbnN0YW5jZS5wcmVsb2FkUmVtb3RlLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiByZWdpc3RlclJlbW90ZXMoLi4uYXJncykge1xuICAgIGFzc2VydChGZWRlcmF0aW9uSW5zdGFuY2UsIGdldFNob3J0RXJyb3JNc2coUlVOVElNRV8wMDksIHJ1bnRpbWVEZXNjTWFwKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICByZXR1cm4gRmVkZXJhdGlvbkluc3RhbmNlLnJlZ2lzdGVyUmVtb3Rlcy5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoRmVkZXJhdGlvbkluc3RhbmNlLCBnZXRTaG9ydEVycm9yTXNnKFJVTlRJTUVfMDA5LCBydW50aW1lRGVzY01hcCkpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIEZlZGVyYXRpb25JbnN0YW5jZS5yZWdpc3RlclBsdWdpbnMuYXBwbHkoRmVkZXJhdGlvbkluc3RhbmNlLCBhcmdzKTtcbn1cbmZ1bmN0aW9uIGdldEluc3RhbmNlKCkge1xuICAgIHJldHVybiBGZWRlcmF0aW9uSW5zdGFuY2U7XG59XG5mdW5jdGlvbiByZWdpc3RlclNoYXJlZCguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgZ2V0U2hvcnRFcnJvck1zZyhSVU5USU1FXzAwOSwgcnVudGltZURlc2NNYXApKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgIHJldHVybiBGZWRlcmF0aW9uSW5zdGFuY2UucmVnaXN0ZXJTaGFyZWQuYXBwbHkoRmVkZXJhdGlvbkluc3RhbmNlLCBhcmdzKTtcbn1cbi8vIEluamVjdCBmb3IgZGVidWdcbnNldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvcihNb2R1bGVGZWRlcmF0aW9uKTtcblxuZXhwb3J0IHsgY3JlYXRlSW5zdGFuY2UsIGdldEluc3RhbmNlLCBpbml0LCBsb2FkUmVtb3RlLCBsb2FkU2hhcmUsIGxvYWRTaGFyZVN5bmMsIHByZWxvYWRSZW1vdGUsIHJlZ2lzdGVyUGx1Z2lucywgcmVnaXN0ZXJSZW1vdGVzLCByZWdpc3RlclNoYXJlZCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/runtime/dist/index.esm.js\n");

/***/ }),

/***/ "./node_modules/@module-federation/runtime/dist/utils.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@module-federation/runtime/dist/utils.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: () => (/* binding */ getGlobalFederationInstance)\n/* harmony export */ });\n/* harmony import */ var _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @module-federation/runtime-core */ \"./node_modules/@module-federation/runtime-core/dist/index.esm.js\");\n\n\n// injected by bundler, so it can not use runtime-core stuff\nfunction getBuilderId() {\n    //@ts-ignore\n    return  true ? \"chart_app:0.1.0\" : 0;\n}\nfunction getGlobalFederationInstance(name, version) {\n    const buildId = getBuilderId();\n    return _module_federation_runtime_core__WEBPACK_IMPORTED_MODULE_0__.CurrentGlobal.__FEDERATION__.__INSTANCES__.find((GMInstance)=>{\n        if (buildId && GMInstance.options.id === buildId) {\n            return true;\n        }\n        if (GMInstance.options.name === name && !GMInstance.options.version && !version) {\n            return true;\n        }\n        if (GMInstance.options.name === name && version && GMInstance.options.version === version) {\n            return true;\n        }\n        return false;\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3J1bnRpbWUvZGlzdC91dGlscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBa0QsR0FBRyxpQkFBMkIsR0FBRyxDQUFFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEVBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRTRDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFdpbiAxMVxcRGVza3RvcFxcUmVhY3QtTWljcm9Gcm9udGVuZFxcbWljcm8tZnJvbnRlbmRcXGNoYXJ0XFxub2RlX21vZHVsZXNcXEBtb2R1bGUtZmVkZXJhdGlvblxccnVudGltZVxcZGlzdFxcdXRpbHMuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEN1cnJlbnRHbG9iYWwgfSBmcm9tICdAbW9kdWxlLWZlZGVyYXRpb24vcnVudGltZS1jb3JlJztcblxuLy8gaW5qZWN0ZWQgYnkgYnVuZGxlciwgc28gaXQgY2FuIG5vdCB1c2UgcnVudGltZS1jb3JlIHN0dWZmXG5mdW5jdGlvbiBnZXRCdWlsZGVySWQoKSB7XG4gICAgLy9AdHMtaWdub3JlXG4gICAgcmV0dXJuIHR5cGVvZiBGRURFUkFUSU9OX0JVSUxEX0lERU5USUZJRVIgIT09ICd1bmRlZmluZWQnID8gRkVERVJBVElPTl9CVUlMRF9JREVOVElGSUVSIDogJyc7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UobmFtZSwgdmVyc2lvbikge1xuICAgIGNvbnN0IGJ1aWxkSWQgPSBnZXRCdWlsZGVySWQoKTtcbiAgICByZXR1cm4gQ3VycmVudEdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX0lOU1RBTkNFU19fLmZpbmQoKEdNSW5zdGFuY2UpPT57XG4gICAgICAgIGlmIChidWlsZElkICYmIEdNSW5zdGFuY2Uub3B0aW9ucy5pZCA9PT0gYnVpbGRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEdNSW5zdGFuY2Uub3B0aW9ucy5uYW1lID09PSBuYW1lICYmICFHTUluc3RhbmNlLm9wdGlvbnMudmVyc2lvbiAmJiAhdmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEdNSW5zdGFuY2Uub3B0aW9ucy5uYW1lID09PSBuYW1lICYmIHZlcnNpb24gJiYgR01JbnN0YW5jZS5vcHRpb25zLnZlcnNpb24gPT09IHZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgZ2V0R2xvYmFsRmVkZXJhdGlvbkluc3RhbmNlIGFzIGcgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/runtime/dist/utils.esm.js\n");

/***/ }),

/***/ "./node_modules/@module-federation/sdk/dist/index.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@module-federation/sdk/dist/index.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BROWSER_LOG_KEY: () => (/* binding */ BROWSER_LOG_KEY),\n/* harmony export */   ENCODE_NAME_PREFIX: () => (/* binding */ ENCODE_NAME_PREFIX),\n/* harmony export */   EncodedNameTransformMap: () => (/* binding */ EncodedNameTransformMap),\n/* harmony export */   FederationModuleManifest: () => (/* binding */ FederationModuleManifest),\n/* harmony export */   MANIFEST_EXT: () => (/* binding */ MANIFEST_EXT),\n/* harmony export */   MFModuleType: () => (/* binding */ MFModuleType),\n/* harmony export */   MFPrefetchCommon: () => (/* binding */ MFPrefetchCommon),\n/* harmony export */   MODULE_DEVTOOL_IDENTIFIER: () => (/* binding */ MODULE_DEVTOOL_IDENTIFIER),\n/* harmony export */   ManifestFileName: () => (/* binding */ ManifestFileName),\n/* harmony export */   NameTransformMap: () => (/* binding */ NameTransformMap),\n/* harmony export */   NameTransformSymbol: () => (/* binding */ NameTransformSymbol),\n/* harmony export */   SEPARATOR: () => (/* binding */ SEPARATOR),\n/* harmony export */   StatsFileName: () => (/* binding */ StatsFileName),\n/* harmony export */   TEMP_DIR: () => (/* binding */ TEMP_DIR),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   composeKeyWithSeparator: () => (/* binding */ composeKeyWithSeparator),\n/* harmony export */   containerPlugin: () => (/* binding */ ContainerPlugin),\n/* harmony export */   containerReferencePlugin: () => (/* binding */ ContainerReferencePlugin),\n/* harmony export */   createLink: () => (/* binding */ createLink),\n/* harmony export */   createLogger: () => (/* binding */ createLogger),\n/* harmony export */   createModuleFederationConfig: () => (/* binding */ createModuleFederationConfig),\n/* harmony export */   createScript: () => (/* binding */ createScript),\n/* harmony export */   createScriptNode: () => (/* binding */ createScriptNode),\n/* harmony export */   decodeName: () => (/* binding */ decodeName),\n/* harmony export */   encodeName: () => (/* binding */ encodeName),\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   generateExposeFilename: () => (/* binding */ generateExposeFilename),\n/* harmony export */   generateShareFilename: () => (/* binding */ generateShareFilename),\n/* harmony export */   generateSnapshotFromManifest: () => (/* binding */ generateSnapshotFromManifest),\n/* harmony export */   getProcessEnv: () => (/* binding */ getProcessEnv),\n/* harmony export */   getResourceUrl: () => (/* binding */ getResourceUrl),\n/* harmony export */   inferAutoPublicPath: () => (/* binding */ inferAutoPublicPath),\n/* harmony export */   isBrowserEnv: () => (/* binding */ isBrowserEnv),\n/* harmony export */   isDebugMode: () => (/* binding */ isDebugMode),\n/* harmony export */   isManifestProvider: () => (/* binding */ isManifestProvider),\n/* harmony export */   isReactNativeEnv: () => (/* binding */ isReactNativeEnv),\n/* harmony export */   isRequiredVersion: () => (/* binding */ isRequiredVersion),\n/* harmony export */   isStaticResourcesEqual: () => (/* binding */ isStaticResourcesEqual),\n/* harmony export */   loadScript: () => (/* binding */ loadScript),\n/* harmony export */   loadScriptNode: () => (/* binding */ loadScriptNode),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   moduleFederationPlugin: () => (/* binding */ ModuleFederationPlugin),\n/* harmony export */   normalizeOptions: () => (/* binding */ normalizeOptions),\n/* harmony export */   parseEntry: () => (/* binding */ parseEntry),\n/* harmony export */   safeToString: () => (/* binding */ safeToString),\n/* harmony export */   safeWrapper: () => (/* binding */ safeWrapper),\n/* harmony export */   sharePlugin: () => (/* binding */ SharePlugin),\n/* harmony export */   simpleJoinRemoteEntry: () => (/* binding */ simpleJoinRemoteEntry),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\n/* harmony import */ var _polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfills.esm.js */ \"./node_modules/@module-federation/sdk/dist/polyfills.esm.js\");\n\n\nconst FederationModuleManifest = 'federation-manifest.json';\nconst MANIFEST_EXT = '.json';\nconst BROWSER_LOG_KEY = 'FEDERATION_DEBUG';\nconst NameTransformSymbol = {\n    AT: '@',\n    HYPHEN: '-',\n    SLASH: '/'\n};\nconst NameTransformMap = {\n    [NameTransformSymbol.AT]: 'scope_',\n    [NameTransformSymbol.HYPHEN]: '_',\n    [NameTransformSymbol.SLASH]: '__'\n};\nconst EncodedNameTransformMap = {\n    [NameTransformMap[NameTransformSymbol.AT]]: NameTransformSymbol.AT,\n    [NameTransformMap[NameTransformSymbol.HYPHEN]]: NameTransformSymbol.HYPHEN,\n    [NameTransformMap[NameTransformSymbol.SLASH]]: NameTransformSymbol.SLASH\n};\nconst SEPARATOR = ':';\nconst ManifestFileName = 'mf-manifest.json';\nconst StatsFileName = 'mf-stats.json';\nconst MFModuleType = {\n    NPM: 'npm',\n    APP: 'app'\n};\nconst MODULE_DEVTOOL_IDENTIFIER = '__MF_DEVTOOLS_MODULE_INFO__';\nconst ENCODE_NAME_PREFIX = 'ENCODE_NAME_PREFIX';\nconst TEMP_DIR = '.federation';\nconst MFPrefetchCommon = {\n    identifier: 'MFDataPrefetch',\n    globalKey: '__PREFETCH__',\n    library: 'mf-data-prefetch',\n    exportsKey: '__PREFETCH_EXPORTS__',\n    fileName: 'bootstrap.js'\n};\n\nvar ContainerPlugin = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nvar ContainerReferencePlugin = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nvar ModuleFederationPlugin = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nvar SharePlugin = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined' && typeof window.document !== 'undefined';\n}\nfunction isReactNativeEnv() {\n    var _navigator;\n    return typeof navigator !== 'undefined' && ((_navigator = navigator) == null ? void 0 : _navigator.product) === 'ReactNative';\n}\nfunction isBrowserDebug() {\n    try {\n        if (isBrowserEnv() && window.localStorage) {\n            return Boolean(localStorage.getItem(BROWSER_LOG_KEY));\n        }\n    } catch (error) {\n        return false;\n    }\n    return false;\n}\nfunction isDebugMode() {\n    if (typeof process !== 'undefined' && process.env && process.env['FEDERATION_DEBUG']) {\n        return Boolean(process.env['FEDERATION_DEBUG']);\n    }\n    if (typeof FEDERATION_DEBUG !== 'undefined' && Boolean(FEDERATION_DEBUG)) {\n        return true;\n    }\n    return isBrowserDebug();\n}\nconst getProcessEnv = function() {\n    return typeof process !== 'undefined' && process.env ? process.env : {};\n};\n\nconst LOG_CATEGORY = '[ Federation Runtime ]';\n// entry: name:version   version : 1.0.0 | ^1.2.3\n// entry: name:entry  entry:  https://localhost:9000/federation-manifest.json\nconst parseEntry = (str, devVerOrUrl, separator = SEPARATOR)=>{\n    const strSplit = str.split(separator);\n    const devVersionOrUrl = getProcessEnv()['NODE_ENV'] === 'development' && devVerOrUrl;\n    const defaultVersion = '*';\n    const isEntry = (s)=>s.startsWith('http') || s.includes(MANIFEST_EXT);\n    // Check if the string starts with a type\n    if (strSplit.length >= 2) {\n        let [name, ...versionOrEntryArr] = strSplit;\n        // @name@manifest-url.json\n        if (str.startsWith(separator)) {\n            name = strSplit.slice(0, 2).join(separator);\n            versionOrEntryArr = [\n                devVersionOrUrl || strSplit.slice(2).join(separator)\n            ];\n        }\n        let versionOrEntry = devVersionOrUrl || versionOrEntryArr.join(separator);\n        if (isEntry(versionOrEntry)) {\n            return {\n                name,\n                entry: versionOrEntry\n            };\n        } else {\n            // Apply version rule\n            // devVersionOrUrl => inputVersion => defaultVersion\n            return {\n                name,\n                version: versionOrEntry || defaultVersion\n            };\n        }\n    } else if (strSplit.length === 1) {\n        const [name] = strSplit;\n        if (devVersionOrUrl && isEntry(devVersionOrUrl)) {\n            return {\n                name,\n                entry: devVersionOrUrl\n            };\n        }\n        return {\n            name,\n            version: devVersionOrUrl || defaultVersion\n        };\n    } else {\n        throw `Invalid entry value: ${str}`;\n    }\n};\nconst composeKeyWithSeparator = function(...args) {\n    if (!args.length) {\n        return '';\n    }\n    return args.reduce((sum, cur)=>{\n        if (!cur) {\n            return sum;\n        }\n        if (!sum) {\n            return cur;\n        }\n        return `${sum}${SEPARATOR}${cur}`;\n    }, '');\n};\nconst encodeName = function(name, prefix = '', withExt = false) {\n    try {\n        const ext = withExt ? '.js' : '';\n        return `${prefix}${name.replace(new RegExp(`${NameTransformSymbol.AT}`, 'g'), NameTransformMap[NameTransformSymbol.AT]).replace(new RegExp(`${NameTransformSymbol.HYPHEN}`, 'g'), NameTransformMap[NameTransformSymbol.HYPHEN]).replace(new RegExp(`${NameTransformSymbol.SLASH}`, 'g'), NameTransformMap[NameTransformSymbol.SLASH])}${ext}`;\n    } catch (err) {\n        throw err;\n    }\n};\nconst decodeName = function(name, prefix, withExt) {\n    try {\n        let decodedName = name;\n        if (prefix) {\n            if (!decodedName.startsWith(prefix)) {\n                return decodedName;\n            }\n            decodedName = decodedName.replace(new RegExp(prefix, 'g'), '');\n        }\n        decodedName = decodedName.replace(new RegExp(`${NameTransformMap[NameTransformSymbol.AT]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]]).replace(new RegExp(`${NameTransformMap[NameTransformSymbol.SLASH]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.SLASH]]).replace(new RegExp(`${NameTransformMap[NameTransformSymbol.HYPHEN]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.HYPHEN]]);\n        if (withExt) {\n            decodedName = decodedName.replace('.js', '');\n        }\n        return decodedName;\n    } catch (err) {\n        throw err;\n    }\n};\nconst generateExposeFilename = (exposeName, withExt)=>{\n    if (!exposeName) {\n        return '';\n    }\n    let expose = exposeName;\n    if (expose === '.') {\n        expose = 'default_export';\n    }\n    if (expose.startsWith('./')) {\n        expose = expose.replace('./', '');\n    }\n    return encodeName(expose, '__federation_expose_', withExt);\n};\nconst generateShareFilename = (pkgName, withExt)=>{\n    if (!pkgName) {\n        return '';\n    }\n    return encodeName(pkgName, '__federation_shared_', withExt);\n};\nconst getResourceUrl = (module, sourceUrl)=>{\n    if ('getPublicPath' in module) {\n        let publicPath;\n        if (!module.getPublicPath.startsWith('function')) {\n            publicPath = new Function(module.getPublicPath)();\n        } else {\n            publicPath = new Function('return ' + module.getPublicPath)()();\n        }\n        return `${publicPath}${sourceUrl}`;\n    } else if ('publicPath' in module) {\n        if (!isBrowserEnv() && !isReactNativeEnv() && 'ssrPublicPath' in module) {\n            return `${module.ssrPublicPath}${sourceUrl}`;\n        }\n        return `${module.publicPath}${sourceUrl}`;\n    } else {\n        console.warn('Cannot get resource URL. If in debug mode, please ignore.', module, sourceUrl);\n        return '';\n    }\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nconst assert = (condition, msg)=>{\n    if (!condition) {\n        error(msg);\n    }\n};\nconst error = (msg)=>{\n    throw new Error(`${LOG_CATEGORY}: ${msg}`);\n};\nconst warn = (msg)=>{\n    console.warn(`${LOG_CATEGORY}: ${msg}`);\n};\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\n// RegExp for version string\nconst VERSION_PATTERN_REGEXP = /^([\\d^=v<>~]|[*xX]$)/;\nfunction isRequiredVersion(str) {\n    return VERSION_PATTERN_REGEXP.test(str);\n}\n\nconst simpleJoinRemoteEntry = (rPath, rName)=>{\n    if (!rPath) {\n        return rName;\n    }\n    const transformPath = (str)=>{\n        if (str === '.') {\n            return '';\n        }\n        if (str.startsWith('./')) {\n            return str.replace('./', '');\n        }\n        if (str.startsWith('/')) {\n            const strWithoutSlash = str.slice(1);\n            if (strWithoutSlash.endsWith('/')) {\n                return strWithoutSlash.slice(0, -1);\n            }\n            return strWithoutSlash;\n        }\n        return str;\n    };\n    const transformedPath = transformPath(rPath);\n    if (!transformedPath) {\n        return rName;\n    }\n    if (transformedPath.endsWith('/')) {\n        return `${transformedPath}${rName}`;\n    }\n    return `${transformedPath}/${rName}`;\n};\nfunction inferAutoPublicPath(url) {\n    return url.replace(/#.*$/, '').replace(/\\?.*$/, '').replace(/\\/[^\\/]+$/, '/');\n}\n// Priority: overrides > remotes\n// eslint-disable-next-line max-lines-per-function\nfunction generateSnapshotFromManifest(manifest, options = {}) {\n    var _manifest_metaData, _manifest_metaData1;\n    const { remotes = {}, overrides = {}, version } = options;\n    let remoteSnapshot;\n    const getPublicPath = ()=>{\n        if ('publicPath' in manifest.metaData) {\n            if (manifest.metaData.publicPath === 'auto' && version) {\n                // use same implementation as publicPath auto runtime module implements\n                return inferAutoPublicPath(version);\n            }\n            return manifest.metaData.publicPath;\n        } else {\n            return manifest.metaData.getPublicPath;\n        }\n    };\n    const overridesKeys = Object.keys(overrides);\n    let remotesInfo = {};\n    // If remotes are not provided, only the remotes in the manifest will be read\n    if (!Object.keys(remotes).length) {\n        var _manifest_remotes;\n        remotesInfo = ((_manifest_remotes = manifest.remotes) == null ? void 0 : _manifest_remotes.reduce((res, next)=>{\n            let matchedVersion;\n            const name = next.federationContainerName;\n            // overrides have higher priority\n            if (overridesKeys.includes(name)) {\n                matchedVersion = overrides[name];\n            } else {\n                if ('version' in next) {\n                    matchedVersion = next.version;\n                } else {\n                    matchedVersion = next.entry;\n                }\n            }\n            res[name] = {\n                matchedVersion\n            };\n            return res;\n        }, {})) || {};\n    }\n    // If remotes (deploy scenario) are specified, they need to be traversed again\n    Object.keys(remotes).forEach((key)=>remotesInfo[key] = {\n            // overrides will override dependencies\n            matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]\n        });\n    const { remoteEntry: { path: remoteEntryPath, name: remoteEntryName, type: remoteEntryType }, types: remoteTypes, buildInfo: { buildVersion }, globalName, ssrRemoteEntry } = manifest.metaData;\n    const { exposes } = manifest;\n    let basicRemoteSnapshot = {\n        version: version ? version : '',\n        buildVersion,\n        globalName,\n        remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),\n        remoteEntryType,\n        remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),\n        remoteTypesZip: remoteTypes.zip || '',\n        remoteTypesAPI: remoteTypes.api || '',\n        remotesInfo,\n        shared: manifest == null ? void 0 : manifest.shared.map((item)=>({\n                assets: item.assets,\n                sharedName: item.name,\n                version: item.version\n            })),\n        modules: exposes == null ? void 0 : exposes.map((expose)=>({\n                moduleName: expose.name,\n                modulePath: expose.path,\n                assets: expose.assets\n            }))\n    };\n    if ((_manifest_metaData = manifest.metaData) == null ? void 0 : _manifest_metaData.prefetchInterface) {\n        const prefetchInterface = manifest.metaData.prefetchInterface;\n        basicRemoteSnapshot = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, basicRemoteSnapshot, {\n            prefetchInterface\n        });\n    }\n    if ((_manifest_metaData1 = manifest.metaData) == null ? void 0 : _manifest_metaData1.prefetchEntry) {\n        const { path, name, type } = manifest.metaData.prefetchEntry;\n        basicRemoteSnapshot = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, basicRemoteSnapshot, {\n            prefetchEntry: simpleJoinRemoteEntry(path, name),\n            prefetchEntryType: type\n        });\n    }\n    if ('publicPath' in manifest.metaData) {\n        remoteSnapshot = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, basicRemoteSnapshot, {\n            publicPath: getPublicPath(),\n            ssrPublicPath: manifest.metaData.ssrPublicPath\n        });\n    } else {\n        remoteSnapshot = (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, basicRemoteSnapshot, {\n            getPublicPath: getPublicPath()\n        });\n    }\n    if (ssrRemoteEntry) {\n        const fullSSRRemoteEntry = simpleJoinRemoteEntry(ssrRemoteEntry.path, ssrRemoteEntry.name);\n        remoteSnapshot.ssrRemoteEntry = fullSSRRemoteEntry;\n        remoteSnapshot.ssrRemoteEntryType = ssrRemoteEntry.type || 'commonjs-module';\n    }\n    return remoteSnapshot;\n}\nfunction isManifestProvider(moduleInfo) {\n    if ('remoteEntry' in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nconst PREFIX = '[ Module Federation ]';\nlet Logger = class Logger {\n    setPrefix(prefix) {\n        this.prefix = prefix;\n    }\n    log(...args) {\n        console.log(this.prefix, ...args);\n    }\n    warn(...args) {\n        console.log(this.prefix, ...args);\n    }\n    error(...args) {\n        console.log(this.prefix, ...args);\n    }\n    success(...args) {\n        console.log(this.prefix, ...args);\n    }\n    info(...args) {\n        console.log(this.prefix, ...args);\n    }\n    ready(...args) {\n        console.log(this.prefix, ...args);\n    }\n    debug(...args) {\n        if (isDebugMode()) {\n            console.log(this.prefix, ...args);\n        }\n    }\n    constructor(prefix){\n        this.prefix = prefix;\n    }\n};\nfunction createLogger(prefix) {\n    return new Logger(prefix);\n}\nconst logger = createLogger(PREFIX);\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function safeWrapper(callback, disableWarn) {\n    try {\n        const res = await callback();\n        return res;\n    } catch (e) {\n        !disableWarn && warn(e);\n        return;\n    }\n}\nfunction isStaticResourcesEqual(url1, url2) {\n    const REG_EXP = /^(https?:)?\\/\\//i;\n    // Transform url1 and url2 into relative paths\n    const relativeUrl1 = url1.replace(REG_EXP, '').replace(/\\/$/, '');\n    const relativeUrl2 = url2.replace(REG_EXP, '').replace(/\\/$/, '');\n    // Check if the relative paths are identical\n    return relativeUrl1 === relativeUrl2;\n}\nfunction createScript(info) {\n    // Retrieve the existing script element by its src attribute\n    let script = null;\n    let needAttach = true;\n    let timeout = 20000;\n    let timeoutId;\n    const scripts = document.getElementsByTagName('script');\n    for(let i = 0; i < scripts.length; i++){\n        const s = scripts[i];\n        const scriptSrc = s.getAttribute('src');\n        if (scriptSrc && isStaticResourcesEqual(scriptSrc, info.url)) {\n            script = s;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!script) {\n        const attrs = info.attrs;\n        script = document.createElement('script');\n        script.type = (attrs == null ? void 0 : attrs['type']) === 'module' ? 'module' : 'text/javascript';\n        let createScriptRes = undefined;\n        if (info.createScriptHook) {\n            createScriptRes = info.createScriptHook(info.url, info.attrs);\n            if (createScriptRes instanceof HTMLScriptElement) {\n                script = createScriptRes;\n            } else if (typeof createScriptRes === 'object') {\n                if ('script' in createScriptRes && createScriptRes.script) {\n                    script = createScriptRes.script;\n                }\n                if ('timeout' in createScriptRes && createScriptRes.timeout) {\n                    timeout = createScriptRes.timeout;\n                }\n            }\n        }\n        if (!script.src) {\n            script.src = info.url;\n        }\n        if (attrs && !createScriptRes) {\n            Object.keys(attrs).forEach((name)=>{\n                if (script) {\n                    if (name === 'async' || name === 'defer') {\n                        script[name] = attrs[name];\n                    // Attributes that do not exist are considered overridden\n                    } else if (!script.getAttribute(name)) {\n                        script.setAttribute(name, attrs[name]);\n                    }\n                }\n            });\n        }\n    }\n    const onScriptComplete = async (prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event)=>{\n        clearTimeout(timeoutId);\n        const onScriptCompleteCallback = ()=>{\n            if ((event == null ? void 0 : event.type) === 'error') {\n                (info == null ? void 0 : info.onErrorCallback) && (info == null ? void 0 : info.onErrorCallback(event));\n            } else {\n                (info == null ? void 0 : info.cb) && (info == null ? void 0 : info.cb());\n            }\n        };\n        // Prevent memory leaks in IE.\n        if (script) {\n            script.onerror = null;\n            script.onload = null;\n            safeWrapper(()=>{\n                const { needDeleteScript = true } = info;\n                if (needDeleteScript) {\n                    (script == null ? void 0 : script.parentNode) && script.parentNode.removeChild(script);\n                }\n            });\n            if (prev && typeof prev === 'function') {\n                const result = prev(event);\n                if (result instanceof Promise) {\n                    const res = await result;\n                    onScriptCompleteCallback();\n                    return res;\n                }\n                onScriptCompleteCallback();\n                return result;\n            }\n        }\n        onScriptCompleteCallback();\n    };\n    script.onerror = onScriptComplete.bind(null, script.onerror);\n    script.onload = onScriptComplete.bind(null, script.onload);\n    timeoutId = setTimeout(()=>{\n        onScriptComplete(null, new Error(`Remote script \"${info.url}\" time-outed.`));\n    }, timeout);\n    return {\n        script,\n        needAttach\n    };\n}\nfunction createLink(info) {\n    // <link rel=\"preload\" href=\"script.js\" as=\"script\">\n    // Retrieve the existing script element by its src attribute\n    let link = null;\n    let needAttach = true;\n    const links = document.getElementsByTagName('link');\n    for(let i = 0; i < links.length; i++){\n        const l = links[i];\n        const linkHref = l.getAttribute('href');\n        const linkRel = l.getAttribute('rel');\n        if (linkHref && isStaticResourcesEqual(linkHref, info.url) && linkRel === info.attrs['rel']) {\n            link = l;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!link) {\n        link = document.createElement('link');\n        link.setAttribute('href', info.url);\n        let createLinkRes = undefined;\n        const attrs = info.attrs;\n        if (info.createLinkHook) {\n            createLinkRes = info.createLinkHook(info.url, attrs);\n            if (createLinkRes instanceof HTMLLinkElement) {\n                link = createLinkRes;\n            }\n        }\n        if (attrs && !createLinkRes) {\n            Object.keys(attrs).forEach((name)=>{\n                if (link && !link.getAttribute(name)) {\n                    link.setAttribute(name, attrs[name]);\n                }\n            });\n        }\n    }\n    const onLinkComplete = (prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event)=>{\n        const onLinkCompleteCallback = ()=>{\n            if ((event == null ? void 0 : event.type) === 'error') {\n                (info == null ? void 0 : info.onErrorCallback) && (info == null ? void 0 : info.onErrorCallback(event));\n            } else {\n                (info == null ? void 0 : info.cb) && (info == null ? void 0 : info.cb());\n            }\n        };\n        // Prevent memory leaks in IE.\n        if (link) {\n            link.onerror = null;\n            link.onload = null;\n            safeWrapper(()=>{\n                const { needDeleteLink = true } = info;\n                if (needDeleteLink) {\n                    (link == null ? void 0 : link.parentNode) && link.parentNode.removeChild(link);\n                }\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const res = prev(event);\n                onLinkCompleteCallback();\n                return res;\n            }\n        }\n        onLinkCompleteCallback();\n    };\n    link.onerror = onLinkComplete.bind(null, link.onerror);\n    link.onload = onLinkComplete.bind(null, link.onload);\n    return {\n        link,\n        needAttach\n    };\n}\nfunction loadScript(url, info) {\n    const { attrs = {}, createScriptHook } = info;\n    return new Promise((resolve, reject)=>{\n        const { script, needAttach } = createScript({\n            url,\n            cb: resolve,\n            onErrorCallback: reject,\n            attrs: (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n                fetchpriority: 'high'\n            }, attrs),\n            createScriptHook,\n            needDeleteScript: true\n        });\n        needAttach && document.head.appendChild(script);\n    });\n}\n\nconst sdkImportCache = new Map();\nfunction importNodeModule(name) {\n    if (!name) {\n        throw new Error('import specifier is required');\n    }\n    // Check cache to prevent infinite recursion\n    if (sdkImportCache.has(name)) {\n        return sdkImportCache.get(name);\n    }\n    const importModule = new Function('name', `return import(name)`);\n    const promise = importModule(name).then((res)=>res).catch((error)=>{\n        console.error(`Error importing module ${name}:`, error);\n        // Remove from cache on error so it can be retried\n        sdkImportCache.delete(name);\n        throw error;\n    });\n    // Cache the promise to prevent recursive calls\n    sdkImportCache.set(name, promise);\n    return promise;\n}\nconst loadNodeFetch = async ()=>{\n    const fetchModule = await importNodeModule('node-fetch');\n    return fetchModule.default || fetchModule;\n};\nconst lazyLoaderHookFetch = async (input, init, loaderHook)=>{\n    const hook = (url, init)=>{\n        return loaderHook.lifecycle.fetch.emit(url, init);\n    };\n    const res = await hook(input, init || {});\n    if (!res || !(res instanceof Response)) {\n        const fetchFunction = typeof fetch === 'undefined' ? await loadNodeFetch() : fetch;\n        return fetchFunction(input, init || {});\n    }\n    return res;\n};\nconst createScriptNode = typeof ENV_TARGET === 'undefined' || ENV_TARGET !== 'web' ? (url, cb, attrs, loaderHook)=>{\n    if (loaderHook == null ? void 0 : loaderHook.createScriptHook) {\n        const hookResult = loaderHook.createScriptHook(url);\n        if (hookResult && typeof hookResult === 'object' && 'url' in hookResult) {\n            url = hookResult.url;\n        }\n    }\n    let urlObj;\n    try {\n        urlObj = new URL(url);\n    } catch (e) {\n        console.error('Error constructing URL:', e);\n        cb(new Error(`Invalid URL: ${e}`));\n        return;\n    }\n    const getFetch = async ()=>{\n        if (loaderHook == null ? void 0 : loaderHook.fetch) {\n            return (input, init)=>lazyLoaderHookFetch(input, init, loaderHook);\n        }\n        return typeof fetch === 'undefined' ? loadNodeFetch() : fetch;\n    };\n    const handleScriptFetch = async (f, urlObj)=>{\n        try {\n            var //@ts-ignore\n            _vm_constants;\n            const res = await f(urlObj.href);\n            const data = await res.text();\n            const [path, vm] = await Promise.all([\n                importNodeModule('path'),\n                importNodeModule('vm')\n            ]);\n            const scriptContext = {\n                exports: {},\n                module: {\n                    exports: {}\n                }\n            };\n            const urlDirname = urlObj.pathname.split('/').slice(0, -1).join('/');\n            const filename = path.basename(urlObj.pathname);\n            var _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER;\n            const script = new vm.Script(`(function(exports, module, require, __dirname, __filename) {${data}\\n})`, {\n                filename,\n                importModuleDynamically: (_vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER = (_vm_constants = vm.constants) == null ? void 0 : _vm_constants.USE_MAIN_CONTEXT_DEFAULT_LOADER) != null ? _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER : importNodeModule\n            });\n            script.runInThisContext()(scriptContext.exports, scriptContext.module, eval('require'), urlDirname, filename);\n            const exportedInterface = scriptContext.module.exports || scriptContext.exports;\n            if (attrs && exportedInterface && attrs['globalName']) {\n                const container = exportedInterface[attrs['globalName']] || exportedInterface;\n                cb(undefined, container);\n                return;\n            }\n            cb(undefined, exportedInterface);\n        } catch (e) {\n            cb(e instanceof Error ? e : new Error(`Script execution error: ${e}`));\n        }\n    };\n    getFetch().then(async (f)=>{\n        if ((attrs == null ? void 0 : attrs['type']) === 'esm' || (attrs == null ? void 0 : attrs['type']) === 'module') {\n            return loadModule(urlObj.href, {\n                fetch: f,\n                vm: await importNodeModule('vm')\n            }).then(async (module)=>{\n                await module.evaluate();\n                cb(undefined, module.namespace);\n            }).catch((e)=>{\n                cb(e instanceof Error ? e : new Error(`Script execution error: ${e}`));\n            });\n        }\n        handleScriptFetch(f, urlObj);\n    }).catch((err)=>{\n        cb(err);\n    });\n} : (url, cb, attrs, loaderHook)=>{\n    cb(new Error('createScriptNode is disabled in non-Node.js environment'));\n};\nconst loadScriptNode = typeof ENV_TARGET === 'undefined' || ENV_TARGET !== 'web' ? (url, info)=>{\n    return new Promise((resolve, reject)=>{\n        createScriptNode(url, (error, scriptContext)=>{\n            if (error) {\n                reject(error);\n            } else {\n                var _info_attrs, _info_attrs1;\n                const remoteEntryKey = (info == null ? void 0 : (_info_attrs = info.attrs) == null ? void 0 : _info_attrs['globalName']) || `__FEDERATION_${info == null ? void 0 : (_info_attrs1 = info.attrs) == null ? void 0 : _info_attrs1['name']}:custom__`;\n                const entryExports = globalThis[remoteEntryKey] = scriptContext;\n                resolve(entryExports);\n            }\n        }, info.attrs, info.loaderHook);\n    });\n} : (url, info)=>{\n    throw new Error('loadScriptNode is disabled in non-Node.js environment');\n};\nconst esmModuleCache = new Map();\nasync function loadModule(url, options) {\n    // Check cache to prevent infinite recursion in ESM loading\n    if (esmModuleCache.has(url)) {\n        return esmModuleCache.get(url);\n    }\n    const { fetch: fetch1, vm } = options;\n    const response = await fetch1(url);\n    const code = await response.text();\n    const module = new vm.SourceTextModule(code, {\n        // @ts-ignore\n        importModuleDynamically: async (specifier, script)=>{\n            const resolvedUrl = new URL(specifier, url).href;\n            return loadModule(resolvedUrl, options);\n        }\n    });\n    // Cache the module before linking to prevent cycles\n    esmModuleCache.set(url, module);\n    await module.link(async (specifier)=>{\n        const resolvedUrl = new URL(specifier, url).href;\n        const module = await loadModule(resolvedUrl, options);\n        return module;\n    });\n    return module;\n}\n\nfunction normalizeOptions(enableDefault, defaultOptions, key) {\n    return function(options) {\n        if (options === false) {\n            return false;\n        }\n        if (typeof options === 'undefined') {\n            if (enableDefault) {\n                return defaultOptions;\n            } else {\n                return false;\n            }\n        }\n        if (options === true) {\n            return defaultOptions;\n        }\n        if (options && typeof options === 'object') {\n            return (0,_polyfills_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, defaultOptions, options);\n        }\n        throw new Error(`Unexpected type for \\`${key}\\`, expect boolean/undefined/object, got: ${typeof options}`);\n    };\n}\n\nconst createModuleFederationConfig = (options)=>{\n    return options;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3Nkay9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFB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Q0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2RUFBNkUsRUFBRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlGQUFpRixFQUFFO0FBQ25GLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDRKQUE0Siw0RkFBNEY7QUFDeFA7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBUSxHQUFHO0FBQzlCO0FBQ0EsaURBQWlELElBQUksNENBQTRDLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRSs2QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxXaW4gMTFcXERlc2t0b3BcXFJlYWN0LU1pY3JvRnJvbnRlbmRcXG1pY3JvLWZyb250ZW5kXFxjaGFydFxcbm9kZV9tb2R1bGVzXFxAbW9kdWxlLWZlZGVyYXRpb25cXHNka1xcZGlzdFxcaW5kZXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF8gYXMgX2V4dGVuZHMgfSBmcm9tICcuL3BvbHlmaWxscy5lc20uanMnO1xuXG5jb25zdCBGZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3QgPSAnZmVkZXJhdGlvbi1tYW5pZmVzdC5qc29uJztcbmNvbnN0IE1BTklGRVNUX0VYVCA9ICcuanNvbic7XG5jb25zdCBCUk9XU0VSX0xPR19LRVkgPSAnRkVERVJBVElPTl9ERUJVRyc7XG5jb25zdCBOYW1lVHJhbnNmb3JtU3ltYm9sID0ge1xuICAgIEFUOiAnQCcsXG4gICAgSFlQSEVOOiAnLScsXG4gICAgU0xBU0g6ICcvJ1xufTtcbmNvbnN0IE5hbWVUcmFuc2Zvcm1NYXAgPSB7XG4gICAgW05hbWVUcmFuc2Zvcm1TeW1ib2wuQVRdOiAnc2NvcGVfJyxcbiAgICBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dOiAnXycsXG4gICAgW05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0hdOiAnX18nXG59O1xuY29uc3QgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXAgPSB7XG4gICAgW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF1dOiBOYW1lVHJhbnNmb3JtU3ltYm9sLkFULFxuICAgIFtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXV06IE5hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOLFxuICAgIFtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0hdXTogTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSFxufTtcbmNvbnN0IFNFUEFSQVRPUiA9ICc6JztcbmNvbnN0IE1hbmlmZXN0RmlsZU5hbWUgPSAnbWYtbWFuaWZlc3QuanNvbic7XG5jb25zdCBTdGF0c0ZpbGVOYW1lID0gJ21mLXN0YXRzLmpzb24nO1xuY29uc3QgTUZNb2R1bGVUeXBlID0ge1xuICAgIE5QTTogJ25wbScsXG4gICAgQVBQOiAnYXBwJ1xufTtcbmNvbnN0IE1PRFVMRV9ERVZUT09MX0lERU5USUZJRVIgPSAnX19NRl9ERVZUT09MU19NT0RVTEVfSU5GT19fJztcbmNvbnN0IEVOQ09ERV9OQU1FX1BSRUZJWCA9ICdFTkNPREVfTkFNRV9QUkVGSVgnO1xuY29uc3QgVEVNUF9ESVIgPSAnLmZlZGVyYXRpb24nO1xuY29uc3QgTUZQcmVmZXRjaENvbW1vbiA9IHtcbiAgICBpZGVudGlmaWVyOiAnTUZEYXRhUHJlZmV0Y2gnLFxuICAgIGdsb2JhbEtleTogJ19fUFJFRkVUQ0hfXycsXG4gICAgbGlicmFyeTogJ21mLWRhdGEtcHJlZmV0Y2gnLFxuICAgIGV4cG9ydHNLZXk6ICdfX1BSRUZFVENIX0VYUE9SVFNfXycsXG4gICAgZmlsZU5hbWU6ICdib290c3RyYXAuanMnXG59O1xuXG52YXIgQ29udGFpbmVyUGx1Z2luID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBDb250YWluZXJSZWZlcmVuY2VQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsXG59KTtcblxudmFyIE1vZHVsZUZlZGVyYXRpb25QbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsXG59KTtcblxudmFyIFNoYXJlUGx1Z2luID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmZ1bmN0aW9uIGlzQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlRW52KCkge1xuICAgIHZhciBfbmF2aWdhdG9yO1xuICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAoKF9uYXZpZ2F0b3IgPSBuYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfbmF2aWdhdG9yLnByb2R1Y3QpID09PSAnUmVhY3ROYXRpdmUnO1xufVxuZnVuY3Rpb24gaXNCcm93c2VyRGVidWcoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzQnJvd3NlckVudigpICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGxvY2FsU3RvcmFnZS5nZXRJdGVtKEJST1dTRVJfTE9HX0tFWSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RlYnVnTW9kZSgpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52WydGRURFUkFUSU9OX0RFQlVHJ10pIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocHJvY2Vzcy5lbnZbJ0ZFREVSQVRJT05fREVCVUcnXSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRkVERVJBVElPTl9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgQm9vbGVhbihGRURFUkFUSU9OX0RFQlVHKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQnJvd3NlckRlYnVnKCk7XG59XG5jb25zdCBnZXRQcm9jZXNzRW52ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiA/IHByb2Nlc3MuZW52IDoge307XG59O1xuXG5jb25zdCBMT0dfQ0FURUdPUlkgPSAnWyBGZWRlcmF0aW9uIFJ1bnRpbWUgXSc7XG4vLyBlbnRyeTogbmFtZTp2ZXJzaW9uICAgdmVyc2lvbiA6IDEuMC4wIHwgXjEuMi4zXG4vLyBlbnRyeTogbmFtZTplbnRyeSAgZW50cnk6ICBodHRwczovL2xvY2FsaG9zdDo5MDAwL2ZlZGVyYXRpb24tbWFuaWZlc3QuanNvblxuY29uc3QgcGFyc2VFbnRyeSA9IChzdHIsIGRldlZlck9yVXJsLCBzZXBhcmF0b3IgPSBTRVBBUkFUT1IpPT57XG4gICAgY29uc3Qgc3RyU3BsaXQgPSBzdHIuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICBjb25zdCBkZXZWZXJzaW9uT3JVcmwgPSBnZXRQcm9jZXNzRW52KClbJ05PREVfRU5WJ10gPT09ICdkZXZlbG9wbWVudCcgJiYgZGV2VmVyT3JVcmw7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb24gPSAnKic7XG4gICAgY29uc3QgaXNFbnRyeSA9IChzKT0+cy5zdGFydHNXaXRoKCdodHRwJykgfHwgcy5pbmNsdWRlcyhNQU5JRkVTVF9FWFQpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggYSB0eXBlXG4gICAgaWYgKHN0clNwbGl0Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGxldCBbbmFtZSwgLi4udmVyc2lvbk9yRW50cnlBcnJdID0gc3RyU3BsaXQ7XG4gICAgICAgIC8vIEBuYW1lQG1hbmlmZXN0LXVybC5qc29uXG4gICAgICAgIGlmIChzdHIuc3RhcnRzV2l0aChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICBuYW1lID0gc3RyU3BsaXQuc2xpY2UoMCwgMikuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgdmVyc2lvbk9yRW50cnlBcnIgPSBbXG4gICAgICAgICAgICAgICAgZGV2VmVyc2lvbk9yVXJsIHx8IHN0clNwbGl0LnNsaWNlKDIpLmpvaW4oc2VwYXJhdG9yKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmVyc2lvbk9yRW50cnkgPSBkZXZWZXJzaW9uT3JVcmwgfHwgdmVyc2lvbk9yRW50cnlBcnIuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaXNFbnRyeSh2ZXJzaW9uT3JFbnRyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBlbnRyeTogdmVyc2lvbk9yRW50cnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBcHBseSB2ZXJzaW9uIHJ1bGVcbiAgICAgICAgICAgIC8vIGRldlZlcnNpb25PclVybCA9PiBpbnB1dFZlcnNpb24gPT4gZGVmYXVsdFZlcnNpb25cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uT3JFbnRyeSB8fCBkZWZhdWx0VmVyc2lvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyU3BsaXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lXSA9IHN0clNwbGl0O1xuICAgICAgICBpZiAoZGV2VmVyc2lvbk9yVXJsICYmIGlzRW50cnkoZGV2VmVyc2lvbk9yVXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGVudHJ5OiBkZXZWZXJzaW9uT3JVcmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB2ZXJzaW9uOiBkZXZWZXJzaW9uT3JVcmwgfHwgZGVmYXVsdFZlcnNpb25cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBgSW52YWxpZCBlbnRyeSB2YWx1ZTogJHtzdHJ9YDtcbiAgICB9XG59O1xuY29uc3QgY29tcG9zZUtleVdpdGhTZXBhcmF0b3IgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBhcmdzLnJlZHVjZSgoc3VtLCBjdXIpPT57XG4gICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VtKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtzdW19JHtTRVBBUkFUT1J9JHtjdXJ9YDtcbiAgICB9LCAnJyk7XG59O1xuY29uc3QgZW5jb2RlTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIHByZWZpeCA9ICcnLCB3aXRoRXh0ID0gZmFsc2UpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBleHQgPSB3aXRoRXh0ID8gJy5qcycgOiAnJztcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke25hbWUucmVwbGFjZShuZXcgUmVnRXhwKGAke05hbWVUcmFuc2Zvcm1TeW1ib2wuQVR9YCwgJ2cnKSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXSkucmVwbGFjZShuZXcgUmVnRXhwKGAke05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOfWAsICdnJyksIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dKS5yZXBsYWNlKG5ldyBSZWdFeHAoYCR7TmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSH1gLCAnZycpLCBOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0hdKX0ke2V4dH1gO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbmNvbnN0IGRlY29kZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBwcmVmaXgsIHdpdGhFeHQpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgZGVjb2RlZE5hbWUgPSBuYW1lO1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICBpZiAoIWRlY29kZWROYW1lLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVkTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWROYW1lID0gZGVjb2RlZE5hbWUucmVwbGFjZShuZXcgUmVnRXhwKHByZWZpeCwgJ2cnKSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWROYW1lID0gZGVjb2RlZE5hbWUucmVwbGFjZShuZXcgUmVnRXhwKGAke05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF19YCwgJ2cnKSwgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXV0pLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0hdfWAsICdnJyksIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF1dKS5yZXBsYWNlKG5ldyBSZWdFeHAoYCR7TmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl19YCwgJ2cnKSwgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl1dKTtcbiAgICAgICAgaWYgKHdpdGhFeHQpIHtcbiAgICAgICAgICAgIGRlY29kZWROYW1lID0gZGVjb2RlZE5hbWUucmVwbGFjZSgnLmpzJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvZGVkTmFtZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG5jb25zdCBnZW5lcmF0ZUV4cG9zZUZpbGVuYW1lID0gKGV4cG9zZU5hbWUsIHdpdGhFeHQpPT57XG4gICAgaWYgKCFleHBvc2VOYW1lKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IGV4cG9zZSA9IGV4cG9zZU5hbWU7XG4gICAgaWYgKGV4cG9zZSA9PT0gJy4nKSB7XG4gICAgICAgIGV4cG9zZSA9ICdkZWZhdWx0X2V4cG9ydCc7XG4gICAgfVxuICAgIGlmIChleHBvc2Uuc3RhcnRzV2l0aCgnLi8nKSkge1xuICAgICAgICBleHBvc2UgPSBleHBvc2UucmVwbGFjZSgnLi8nLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVOYW1lKGV4cG9zZSwgJ19fZmVkZXJhdGlvbl9leHBvc2VfJywgd2l0aEV4dCk7XG59O1xuY29uc3QgZ2VuZXJhdGVTaGFyZUZpbGVuYW1lID0gKHBrZ05hbWUsIHdpdGhFeHQpPT57XG4gICAgaWYgKCFwa2dOYW1lKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZU5hbWUocGtnTmFtZSwgJ19fZmVkZXJhdGlvbl9zaGFyZWRfJywgd2l0aEV4dCk7XG59O1xuY29uc3QgZ2V0UmVzb3VyY2VVcmwgPSAobW9kdWxlLCBzb3VyY2VVcmwpPT57XG4gICAgaWYgKCdnZXRQdWJsaWNQYXRoJyBpbiBtb2R1bGUpIHtcbiAgICAgICAgbGV0IHB1YmxpY1BhdGg7XG4gICAgICAgIGlmICghbW9kdWxlLmdldFB1YmxpY1BhdGguc3RhcnRzV2l0aCgnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgcHVibGljUGF0aCA9IG5ldyBGdW5jdGlvbihtb2R1bGUuZ2V0UHVibGljUGF0aCkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHB1YmxpY1BhdGggPSBuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgbW9kdWxlLmdldFB1YmxpY1BhdGgpKCkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7cHVibGljUGF0aH0ke3NvdXJjZVVybH1gO1xuICAgIH0gZWxzZSBpZiAoJ3B1YmxpY1BhdGgnIGluIG1vZHVsZSkge1xuICAgICAgICBpZiAoIWlzQnJvd3NlckVudigpICYmICFpc1JlYWN0TmF0aXZlRW52KCkgJiYgJ3NzclB1YmxpY1BhdGgnIGluIG1vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke21vZHVsZS5zc3JQdWJsaWNQYXRofSR7c291cmNlVXJsfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke21vZHVsZS5wdWJsaWNQYXRofSR7c291cmNlVXJsfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgZ2V0IHJlc291cmNlIFVSTC4gSWYgaW4gZGVidWcgbW9kZSwgcGxlYXNlIGlnbm9yZS4nLCBtb2R1bGUsIHNvdXJjZVVybCk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmNvbnN0IGFzc2VydCA9IChjb25kaXRpb24sIG1zZyk9PntcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBlcnJvcihtc2cpO1xuICAgIH1cbn07XG5jb25zdCBlcnJvciA9IChtc2cpPT57XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke0xPR19DQVRFR09SWX06ICR7bXNnfWApO1xufTtcbmNvbnN0IHdhcm4gPSAobXNnKT0+e1xuICAgIGNvbnNvbGUud2FybihgJHtMT0dfQ0FURUdPUll9OiAke21zZ31gKTtcbn07XG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcoaW5mbykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbmZvLCBudWxsLCAyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4vLyBSZWdFeHAgZm9yIHZlcnNpb24gc3RyaW5nXG5jb25zdCBWRVJTSU9OX1BBVFRFUk5fUkVHRVhQID0gL14oW1xcZF49djw+fl18Wyp4WF0kKS87XG5mdW5jdGlvbiBpc1JlcXVpcmVkVmVyc2lvbihzdHIpIHtcbiAgICByZXR1cm4gVkVSU0lPTl9QQVRURVJOX1JFR0VYUC50ZXN0KHN0cik7XG59XG5cbmNvbnN0IHNpbXBsZUpvaW5SZW1vdGVFbnRyeSA9IChyUGF0aCwgck5hbWUpPT57XG4gICAgaWYgKCFyUGF0aCkge1xuICAgICAgICByZXR1cm4gck5hbWU7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybVBhdGggPSAoc3RyKT0+e1xuICAgICAgICBpZiAoc3RyID09PSAnLicpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgnLi8nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cldpdGhvdXRTbGFzaCA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmIChzdHJXaXRob3V0U2xhc2guZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJXaXRob3V0U2xhc2guc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRTbGFzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgY29uc3QgdHJhbnNmb3JtZWRQYXRoID0gdHJhbnNmb3JtUGF0aChyUGF0aCk7XG4gICAgaWYgKCF0cmFuc2Zvcm1lZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJOYW1lO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZWRQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIGAke3RyYW5zZm9ybWVkUGF0aH0ke3JOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHt0cmFuc2Zvcm1lZFBhdGh9LyR7ck5hbWV9YDtcbn07XG5mdW5jdGlvbiBpbmZlckF1dG9QdWJsaWNQYXRoKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvIy4qJC8sICcnKS5yZXBsYWNlKC9cXD8uKiQvLCAnJykucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnLycpO1xufVxuLy8gUHJpb3JpdHk6IG92ZXJyaWRlcyA+IHJlbW90ZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uXG5mdW5jdGlvbiBnZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0KG1hbmlmZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX21hbmlmZXN0X21ldGFEYXRhLCBfbWFuaWZlc3RfbWV0YURhdGExO1xuICAgIGNvbnN0IHsgcmVtb3RlcyA9IHt9LCBvdmVycmlkZXMgPSB7fSwgdmVyc2lvbiB9ID0gb3B0aW9ucztcbiAgICBsZXQgcmVtb3RlU25hcHNob3Q7XG4gICAgY29uc3QgZ2V0UHVibGljUGF0aCA9ICgpPT57XG4gICAgICAgIGlmICgncHVibGljUGF0aCcgaW4gbWFuaWZlc3QubWV0YURhdGEpIHtcbiAgICAgICAgICAgIGlmIChtYW5pZmVzdC5tZXRhRGF0YS5wdWJsaWNQYXRoID09PSAnYXV0bycgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHB1YmxpY1BhdGggYXV0byBydW50aW1lIG1vZHVsZSBpbXBsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZmVyQXV0b1B1YmxpY1BhdGgodmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QubWV0YURhdGEucHVibGljUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdC5tZXRhRGF0YS5nZXRQdWJsaWNQYXRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvdmVycmlkZXNLZXlzID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKTtcbiAgICBsZXQgcmVtb3Rlc0luZm8gPSB7fTtcbiAgICAvLyBJZiByZW1vdGVzIGFyZSBub3QgcHJvdmlkZWQsIG9ubHkgdGhlIHJlbW90ZXMgaW4gdGhlIG1hbmlmZXN0IHdpbGwgYmUgcmVhZFxuICAgIGlmICghT2JqZWN0LmtleXMocmVtb3RlcykubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfbWFuaWZlc3RfcmVtb3RlcztcbiAgICAgICAgcmVtb3Rlc0luZm8gPSAoKF9tYW5pZmVzdF9yZW1vdGVzID0gbWFuaWZlc3QucmVtb3RlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9yZW1vdGVzLnJlZHVjZSgocmVzLCBuZXh0KT0+e1xuICAgICAgICAgICAgbGV0IG1hdGNoZWRWZXJzaW9uO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5leHQuZmVkZXJhdGlvbkNvbnRhaW5lck5hbWU7XG4gICAgICAgICAgICAvLyBvdmVycmlkZXMgaGF2ZSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXNLZXlzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb24gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgndmVyc2lvbicgaW4gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQudmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQuZW50cnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRWZXJzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwge30pKSB8fCB7fTtcbiAgICB9XG4gICAgLy8gSWYgcmVtb3RlcyAoZGVwbG95IHNjZW5hcmlvKSBhcmUgc3BlY2lmaWVkLCB0aGV5IG5lZWQgdG8gYmUgdHJhdmVyc2VkIGFnYWluXG4gICAgT2JqZWN0LmtleXMocmVtb3RlcykuZm9yRWFjaCgoa2V5KT0+cmVtb3Rlc0luZm9ba2V5XSA9IHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlcyB3aWxsIG92ZXJyaWRlIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb246IG92ZXJyaWRlc0tleXMuaW5jbHVkZXMoa2V5KSA/IG92ZXJyaWRlc1trZXldIDogcmVtb3Rlc1trZXldXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IHsgcmVtb3RlRW50cnk6IHsgcGF0aDogcmVtb3RlRW50cnlQYXRoLCBuYW1lOiByZW1vdGVFbnRyeU5hbWUsIHR5cGU6IHJlbW90ZUVudHJ5VHlwZSB9LCB0eXBlczogcmVtb3RlVHlwZXMsIGJ1aWxkSW5mbzogeyBidWlsZFZlcnNpb24gfSwgZ2xvYmFsTmFtZSwgc3NyUmVtb3RlRW50cnkgfSA9IG1hbmlmZXN0Lm1ldGFEYXRhO1xuICAgIGNvbnN0IHsgZXhwb3NlcyB9ID0gbWFuaWZlc3Q7XG4gICAgbGV0IGJhc2ljUmVtb3RlU25hcHNob3QgPSB7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb24gPyB2ZXJzaW9uIDogJycsXG4gICAgICAgIGJ1aWxkVmVyc2lvbixcbiAgICAgICAgZ2xvYmFsTmFtZSxcbiAgICAgICAgcmVtb3RlRW50cnk6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShyZW1vdGVFbnRyeVBhdGgsIHJlbW90ZUVudHJ5TmFtZSksXG4gICAgICAgIHJlbW90ZUVudHJ5VHlwZSxcbiAgICAgICAgcmVtb3RlVHlwZXM6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShyZW1vdGVUeXBlcy5wYXRoLCByZW1vdGVUeXBlcy5uYW1lKSxcbiAgICAgICAgcmVtb3RlVHlwZXNaaXA6IHJlbW90ZVR5cGVzLnppcCB8fCAnJyxcbiAgICAgICAgcmVtb3RlVHlwZXNBUEk6IHJlbW90ZVR5cGVzLmFwaSB8fCAnJyxcbiAgICAgICAgcmVtb3Rlc0luZm8sXG4gICAgICAgIHNoYXJlZDogbWFuaWZlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IG1hbmlmZXN0LnNoYXJlZC5tYXAoKGl0ZW0pPT4oe1xuICAgICAgICAgICAgICAgIGFzc2V0czogaXRlbS5hc3NldHMsXG4gICAgICAgICAgICAgICAgc2hhcmVkTmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGl0ZW0udmVyc2lvblxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBtb2R1bGVzOiBleHBvc2VzID09IG51bGwgPyB2b2lkIDAgOiBleHBvc2VzLm1hcCgoZXhwb3NlKT0+KHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBleHBvc2UubmFtZSxcbiAgICAgICAgICAgICAgICBtb2R1bGVQYXRoOiBleHBvc2UucGF0aCxcbiAgICAgICAgICAgICAgICBhc3NldHM6IGV4cG9zZS5hc3NldHNcbiAgICAgICAgICAgIH0pKVxuICAgIH07XG4gICAgaWYgKChfbWFuaWZlc3RfbWV0YURhdGEgPSBtYW5pZmVzdC5tZXRhRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YS5wcmVmZXRjaEludGVyZmFjZSkge1xuICAgICAgICBjb25zdCBwcmVmZXRjaEludGVyZmFjZSA9IG1hbmlmZXN0Lm1ldGFEYXRhLnByZWZldGNoSW50ZXJmYWNlO1xuICAgICAgICBiYXNpY1JlbW90ZVNuYXBzaG90ID0gX2V4dGVuZHMoe30sIGJhc2ljUmVtb3RlU25hcHNob3QsIHtcbiAgICAgICAgICAgIHByZWZldGNoSW50ZXJmYWNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoKF9tYW5pZmVzdF9tZXRhRGF0YTEgPSBtYW5pZmVzdC5tZXRhRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YTEucHJlZmV0Y2hFbnRyeSkge1xuICAgICAgICBjb25zdCB7IHBhdGgsIG5hbWUsIHR5cGUgfSA9IG1hbmlmZXN0Lm1ldGFEYXRhLnByZWZldGNoRW50cnk7XG4gICAgICAgIGJhc2ljUmVtb3RlU25hcHNob3QgPSBfZXh0ZW5kcyh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCwge1xuICAgICAgICAgICAgcHJlZmV0Y2hFbnRyeTogc2ltcGxlSm9pblJlbW90ZUVudHJ5KHBhdGgsIG5hbWUpLFxuICAgICAgICAgICAgcHJlZmV0Y2hFbnRyeVR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgncHVibGljUGF0aCcgaW4gbWFuaWZlc3QubWV0YURhdGEpIHtcbiAgICAgICAgcmVtb3RlU25hcHNob3QgPSBfZXh0ZW5kcyh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCwge1xuICAgICAgICAgICAgcHVibGljUGF0aDogZ2V0UHVibGljUGF0aCgpLFxuICAgICAgICAgICAgc3NyUHVibGljUGF0aDogbWFuaWZlc3QubWV0YURhdGEuc3NyUHVibGljUGF0aFxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdGVTbmFwc2hvdCA9IF9leHRlbmRzKHt9LCBiYXNpY1JlbW90ZVNuYXBzaG90LCB7XG4gICAgICAgICAgICBnZXRQdWJsaWNQYXRoOiBnZXRQdWJsaWNQYXRoKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzc3JSZW1vdGVFbnRyeSkge1xuICAgICAgICBjb25zdCBmdWxsU1NSUmVtb3RlRW50cnkgPSBzaW1wbGVKb2luUmVtb3RlRW50cnkoc3NyUmVtb3RlRW50cnkucGF0aCwgc3NyUmVtb3RlRW50cnkubmFtZSk7XG4gICAgICAgIHJlbW90ZVNuYXBzaG90LnNzclJlbW90ZUVudHJ5ID0gZnVsbFNTUlJlbW90ZUVudHJ5O1xuICAgICAgICByZW1vdGVTbmFwc2hvdC5zc3JSZW1vdGVFbnRyeVR5cGUgPSBzc3JSZW1vdGVFbnRyeS50eXBlIHx8ICdjb21tb25qcy1tb2R1bGUnO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3RlU25hcHNob3Q7XG59XG5mdW5jdGlvbiBpc01hbmlmZXN0UHJvdmlkZXIobW9kdWxlSW5mbykge1xuICAgIGlmICgncmVtb3RlRW50cnknIGluIG1vZHVsZUluZm8gJiYgbW9kdWxlSW5mby5yZW1vdGVFbnRyeS5pbmNsdWRlcyhNQU5JRkVTVF9FWFQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmNvbnN0IFBSRUZJWCA9ICdbIE1vZHVsZSBGZWRlcmF0aW9uIF0nO1xubGV0IExvZ2dlciA9IGNsYXNzIExvZ2dlciB7XG4gICAgc2V0UHJlZml4KHByZWZpeCkge1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB9XG4gICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5wcmVmaXgsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5wcmVmaXgsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMucHJlZml4LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgc3VjY2VzcyguLi5hcmdzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMucHJlZml4LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMucHJlZml4LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgcmVhZHkoLi4uYXJncykge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnByZWZpeCwgLi4uYXJncyk7XG4gICAgfVxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGlzRGVidWdNb2RlKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucHJlZml4LCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgpe1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKHByZWZpeCkge1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKHByZWZpeCk7XG59XG5jb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoUFJFRklYKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmFzeW5jIGZ1bmN0aW9uIHNhZmVXcmFwcGVyKGNhbGxiYWNrLCBkaXNhYmxlV2Fybikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAhZGlzYWJsZVdhcm4gJiYgd2FybihlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwodXJsMSwgdXJsMikge1xuICAgIGNvbnN0IFJFR19FWFAgPSAvXihodHRwcz86KT9cXC9cXC8vaTtcbiAgICAvLyBUcmFuc2Zvcm0gdXJsMSBhbmQgdXJsMiBpbnRvIHJlbGF0aXZlIHBhdGhzXG4gICAgY29uc3QgcmVsYXRpdmVVcmwxID0gdXJsMS5yZXBsYWNlKFJFR19FWFAsICcnKS5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgIGNvbnN0IHJlbGF0aXZlVXJsMiA9IHVybDIucmVwbGFjZShSRUdfRVhQLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgcmVsYXRpdmUgcGF0aHMgYXJlIGlkZW50aWNhbFxuICAgIHJldHVybiByZWxhdGl2ZVVybDEgPT09IHJlbGF0aXZlVXJsMjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjcmlwdChpbmZvKSB7XG4gICAgLy8gUmV0cmlldmUgdGhlIGV4aXN0aW5nIHNjcmlwdCBlbGVtZW50IGJ5IGl0cyBzcmMgYXR0cmlidXRlXG4gICAgbGV0IHNjcmlwdCA9IG51bGw7XG4gICAgbGV0IG5lZWRBdHRhY2ggPSB0cnVlO1xuICAgIGxldCB0aW1lb3V0ID0gMjAwMDA7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgcyA9IHNjcmlwdHNbaV07XG4gICAgICAgIGNvbnN0IHNjcmlwdFNyYyA9IHMuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgaWYgKHNjcmlwdFNyYyAmJiBpc1N0YXRpY1Jlc291cmNlc0VxdWFsKHNjcmlwdFNyYywgaW5mby51cmwpKSB7XG4gICAgICAgICAgICBzY3JpcHQgPSBzO1xuICAgICAgICAgICAgbmVlZEF0dGFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBpbmZvLmF0dHJzO1xuICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAoYXR0cnMgPT0gbnVsbCA/IHZvaWQgMCA6IGF0dHJzWyd0eXBlJ10pID09PSAnbW9kdWxlJyA/ICdtb2R1bGUnIDogJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIGxldCBjcmVhdGVTY3JpcHRSZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpbmZvLmNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFJlcyA9IGluZm8uY3JlYXRlU2NyaXB0SG9vayhpbmZvLnVybCwgaW5mby5hdHRycyk7XG4gICAgICAgICAgICBpZiAoY3JlYXRlU2NyaXB0UmVzIGluc3RhbmNlb2YgSFRNTFNjcmlwdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBjcmVhdGVTY3JpcHRSZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjcmVhdGVTY3JpcHRSZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdzY3JpcHQnIGluIGNyZWF0ZVNjcmlwdFJlcyAmJiBjcmVhdGVTY3JpcHRSZXMuc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGNyZWF0ZVNjcmlwdFJlcy5zY3JpcHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgndGltZW91dCcgaW4gY3JlYXRlU2NyaXB0UmVzICYmIGNyZWF0ZVNjcmlwdFJlcy50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBjcmVhdGVTY3JpcHRSZXMudGltZW91dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzY3JpcHQuc3JjKSB7XG4gICAgICAgICAgICBzY3JpcHQuc3JjID0gaW5mby51cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzICYmICFjcmVhdGVTY3JpcHRSZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKChuYW1lKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdhc3luYycgfHwgbmFtZSA9PT0gJ2RlZmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0W25hbWVdID0gYXR0cnNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZXMgdGhhdCBkbyBub3QgZXhpc3QgYXJlIGNvbnNpZGVyZWQgb3ZlcnJpZGRlblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFzY3JpcHQuZ2V0QXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9uU2NyaXB0Q29tcGxldGUgPSBhc3luYyAocHJldiwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBldmVudCk9PntcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGNvbnN0IG9uU2NyaXB0Q29tcGxldGVDYWxsYmFjayA9ICgpPT57XG4gICAgICAgICAgICBpZiAoKGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC50eXBlKSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIChpbmZvID09IG51bGwgPyB2b2lkIDAgOiBpbmZvLm9uRXJyb3JDYWxsYmFjaykgJiYgKGluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IGluZm8ub25FcnJvckNhbGxiYWNrKGV2ZW50KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChpbmZvID09IG51bGwgPyB2b2lkIDAgOiBpbmZvLmNiKSAmJiAoaW5mbyA9PSBudWxsID8gdm9pZCAwIDogaW5mby5jYigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gUHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUUuXG4gICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgc2FmZVdyYXBwZXIoKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5lZWREZWxldGVTY3JpcHQgPSB0cnVlIH0gPSBpbmZvO1xuICAgICAgICAgICAgICAgIGlmIChuZWVkRGVsZXRlU2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIChzY3JpcHQgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcmlwdC5wYXJlbnROb2RlKSAmJiBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgdHlwZW9mIHByZXYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwcmV2KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIG9uU2NyaXB0Q29tcGxldGVDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblNjcmlwdENvbXBsZXRlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9uU2NyaXB0Q29tcGxldGVDYWxsYmFjaygpO1xuICAgIH07XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuICAgIHNjcmlwdC5vbmxvYWQgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9ubG9hZCk7XG4gICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICBvblNjcmlwdENvbXBsZXRlKG51bGwsIG5ldyBFcnJvcihgUmVtb3RlIHNjcmlwdCBcIiR7aW5mby51cmx9XCIgdGltZS1vdXRlZC5gKSk7XG4gICAgfSwgdGltZW91dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NyaXB0LFxuICAgICAgICBuZWVkQXR0YWNoXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpbmsoaW5mbykge1xuICAgIC8vIDxsaW5rIHJlbD1cInByZWxvYWRcIiBocmVmPVwic2NyaXB0LmpzXCIgYXM9XCJzY3JpcHRcIj5cbiAgICAvLyBSZXRyaWV2ZSB0aGUgZXhpc3Rpbmcgc2NyaXB0IGVsZW1lbnQgYnkgaXRzIHNyYyBhdHRyaWJ1dGVcbiAgICBsZXQgbGluayA9IG51bGw7XG4gICAgbGV0IG5lZWRBdHRhY2ggPSB0cnVlO1xuICAgIGNvbnN0IGxpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpbmsnKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBsID0gbGlua3NbaV07XG4gICAgICAgIGNvbnN0IGxpbmtIcmVmID0gbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgY29uc3QgbGlua1JlbCA9IGwuZ2V0QXR0cmlidXRlKCdyZWwnKTtcbiAgICAgICAgaWYgKGxpbmtIcmVmICYmIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwobGlua0hyZWYsIGluZm8udXJsKSAmJiBsaW5rUmVsID09PSBpbmZvLmF0dHJzWydyZWwnXSkge1xuICAgICAgICAgICAgbGluayA9IGw7XG4gICAgICAgICAgICBuZWVkQXR0YWNoID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBpbmZvLnVybCk7XG4gICAgICAgIGxldCBjcmVhdGVMaW5rUmVzID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBhdHRycyA9IGluZm8uYXR0cnM7XG4gICAgICAgIGlmIChpbmZvLmNyZWF0ZUxpbmtIb29rKSB7XG4gICAgICAgICAgICBjcmVhdGVMaW5rUmVzID0gaW5mby5jcmVhdGVMaW5rSG9vayhpbmZvLnVybCwgYXR0cnMpO1xuICAgICAgICAgICAgaWYgKGNyZWF0ZUxpbmtSZXMgaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBsaW5rID0gY3JlYXRlTGlua1JlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMgJiYgIWNyZWF0ZUxpbmtSZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKChuYW1lKT0+e1xuICAgICAgICAgICAgICAgIGlmIChsaW5rICYmICFsaW5rLmdldEF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb25MaW5rQ29tcGxldGUgPSAocHJldiwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBldmVudCk9PntcbiAgICAgICAgY29uc3Qgb25MaW5rQ29tcGxldGVDYWxsYmFjayA9ICgpPT57XG4gICAgICAgICAgICBpZiAoKGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC50eXBlKSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIChpbmZvID09IG51bGwgPyB2b2lkIDAgOiBpbmZvLm9uRXJyb3JDYWxsYmFjaykgJiYgKGluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IGluZm8ub25FcnJvckNhbGxiYWNrKGV2ZW50KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChpbmZvID09IG51bGwgPyB2b2lkIDAgOiBpbmZvLmNiKSAmJiAoaW5mbyA9PSBudWxsID8gdm9pZCAwIDogaW5mby5jYigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gUHJldmVudCBtZW1vcnkgbGVha3MgaW4gSUUuXG4gICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICBsaW5rLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgbGluay5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgc2FmZVdyYXBwZXIoKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5lZWREZWxldGVMaW5rID0gdHJ1ZSB9ID0gaW5mbztcbiAgICAgICAgICAgICAgICBpZiAobmVlZERlbGV0ZUxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgKGxpbmsgPT0gbnVsbCA/IHZvaWQgMCA6IGxpbmsucGFyZW50Tm9kZSkgJiYgbGluay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHByZXYoZXZlbnQpO1xuICAgICAgICAgICAgICAgIG9uTGlua0NvbXBsZXRlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9uTGlua0NvbXBsZXRlQ2FsbGJhY2soKTtcbiAgICB9O1xuICAgIGxpbmsub25lcnJvciA9IG9uTGlua0NvbXBsZXRlLmJpbmQobnVsbCwgbGluay5vbmVycm9yKTtcbiAgICBsaW5rLm9ubG9hZCA9IG9uTGlua0NvbXBsZXRlLmJpbmQobnVsbCwgbGluay5vbmxvYWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmssXG4gICAgICAgIG5lZWRBdHRhY2hcbiAgICB9O1xufVxuZnVuY3Rpb24gbG9hZFNjcmlwdCh1cmwsIGluZm8pIHtcbiAgICBjb25zdCB7IGF0dHJzID0ge30sIGNyZWF0ZVNjcmlwdEhvb2sgfSA9IGluZm87XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHsgc2NyaXB0LCBuZWVkQXR0YWNoIH0gPSBjcmVhdGVTY3JpcHQoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgY2I6IHJlc29sdmUsXG4gICAgICAgICAgICBvbkVycm9yQ2FsbGJhY2s6IHJlamVjdCxcbiAgICAgICAgICAgIGF0dHJzOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgZmV0Y2hwcmlvcml0eTogJ2hpZ2gnXG4gICAgICAgICAgICB9LCBhdHRycyksXG4gICAgICAgICAgICBjcmVhdGVTY3JpcHRIb29rLFxuICAgICAgICAgICAgbmVlZERlbGV0ZVNjcmlwdDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgbmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG59XG5cbmNvbnN0IHNka0ltcG9ydENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gaW1wb3J0Tm9kZU1vZHVsZShuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW1wb3J0IHNwZWNpZmllciBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICAvLyBDaGVjayBjYWNoZSB0byBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvblxuICAgIGlmIChzZGtJbXBvcnRDYWNoZS5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHNka0ltcG9ydENhY2hlLmdldChuYW1lKTtcbiAgICB9XG4gICAgY29uc3QgaW1wb3J0TW9kdWxlID0gbmV3IEZ1bmN0aW9uKCduYW1lJywgYHJldHVybiBpbXBvcnQobmFtZSlgKTtcbiAgICBjb25zdCBwcm9taXNlID0gaW1wb3J0TW9kdWxlKG5hbWUpLnRoZW4oKHJlcyk9PnJlcykuY2F0Y2goKGVycm9yKT0+e1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbXBvcnRpbmcgbW9kdWxlICR7bmFtZX06YCwgZXJyb3IpO1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSBjYWNoZSBvbiBlcnJvciBzbyBpdCBjYW4gYmUgcmV0cmllZFxuICAgICAgICBzZGtJbXBvcnRDYWNoZS5kZWxldGUobmFtZSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIC8vIENhY2hlIHRoZSBwcm9taXNlIHRvIHByZXZlbnQgcmVjdXJzaXZlIGNhbGxzXG4gICAgc2RrSW1wb3J0Q2FjaGUuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuY29uc3QgbG9hZE5vZGVGZXRjaCA9IGFzeW5jICgpPT57XG4gICAgY29uc3QgZmV0Y2hNb2R1bGUgPSBhd2FpdCBpbXBvcnROb2RlTW9kdWxlKCdub2RlLWZldGNoJyk7XG4gICAgcmV0dXJuIGZldGNoTW9kdWxlLmRlZmF1bHQgfHwgZmV0Y2hNb2R1bGU7XG59O1xuY29uc3QgbGF6eUxvYWRlckhvb2tGZXRjaCA9IGFzeW5jIChpbnB1dCwgaW5pdCwgbG9hZGVySG9vayk9PntcbiAgICBjb25zdCBob29rID0gKHVybCwgaW5pdCk9PntcbiAgICAgICAgcmV0dXJuIGxvYWRlckhvb2subGlmZWN5Y2xlLmZldGNoLmVtaXQodXJsLCBpbml0KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGhvb2soaW5wdXQsIGluaXQgfHwge30pO1xuICAgIGlmICghcmVzIHx8ICEocmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIGNvbnN0IGZldGNoRnVuY3Rpb24gPSB0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnID8gYXdhaXQgbG9hZE5vZGVGZXRjaCgpIDogZmV0Y2g7XG4gICAgICAgIHJldHVybiBmZXRjaEZ1bmN0aW9uKGlucHV0LCBpbml0IHx8IHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBjcmVhdGVTY3JpcHROb2RlID0gdHlwZW9mIEVOVl9UQVJHRVQgPT09ICd1bmRlZmluZWQnIHx8IEVOVl9UQVJHRVQgIT09ICd3ZWInID8gKHVybCwgY2IsIGF0dHJzLCBsb2FkZXJIb29rKT0+e1xuICAgIGlmIChsb2FkZXJIb29rID09IG51bGwgPyB2b2lkIDAgOiBsb2FkZXJIb29rLmNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAgICAgY29uc3QgaG9va1Jlc3VsdCA9IGxvYWRlckhvb2suY3JlYXRlU2NyaXB0SG9vayh1cmwpO1xuICAgICAgICBpZiAoaG9va1Jlc3VsdCAmJiB0eXBlb2YgaG9va1Jlc3VsdCA9PT0gJ29iamVjdCcgJiYgJ3VybCcgaW4gaG9va1Jlc3VsdCkge1xuICAgICAgICAgICAgdXJsID0gaG9va1Jlc3VsdC51cmw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHVybE9iajtcbiAgICB0cnkge1xuICAgICAgICB1cmxPYmogPSBuZXcgVVJMKHVybCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb25zdHJ1Y3RpbmcgVVJMOicsIGUpO1xuICAgICAgICBjYihuZXcgRXJyb3IoYEludmFsaWQgVVJMOiAke2V9YCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGdldEZldGNoID0gYXN5bmMgKCk9PntcbiAgICAgICAgaWYgKGxvYWRlckhvb2sgPT0gbnVsbCA/IHZvaWQgMCA6IGxvYWRlckhvb2suZmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiAoaW5wdXQsIGluaXQpPT5sYXp5TG9hZGVySG9va0ZldGNoKGlucHV0LCBpbml0LCBsb2FkZXJIb29rKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJyA/IGxvYWROb2RlRmV0Y2goKSA6IGZldGNoO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlU2NyaXB0RmV0Y2ggPSBhc3luYyAoZiwgdXJsT2JqKT0+e1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgX3ZtX2NvbnN0YW50cztcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGYodXJsT2JqLmhyZWYpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBbcGF0aCwgdm1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGltcG9ydE5vZGVNb2R1bGUoJ3BhdGgnKSxcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKCd2bScpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdENvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0czoge30sXG4gICAgICAgICAgICAgICAgbW9kdWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHVybERpcm5hbWUgPSB1cmxPYmoucGF0aG5hbWUuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuam9pbignLycpO1xuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHVybE9iai5wYXRobmFtZSk7XG4gICAgICAgICAgICB2YXIgX3ZtX2NvbnN0YW50c19VU0VfTUFJTl9DT05URVhUX0RFRkFVTFRfTE9BREVSO1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gbmV3IHZtLlNjcmlwdChgKGZ1bmN0aW9uKGV4cG9ydHMsIG1vZHVsZSwgcmVxdWlyZSwgX19kaXJuYW1lLCBfX2ZpbGVuYW1lKSB7JHtkYXRhfVxcbn0pYCwge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGltcG9ydE1vZHVsZUR5bmFtaWNhbGx5OiAoX3ZtX2NvbnN0YW50c19VU0VfTUFJTl9DT05URVhUX0RFRkFVTFRfTE9BREVSID0gKF92bV9jb25zdGFudHMgPSB2bS5jb25zdGFudHMpID09IG51bGwgPyB2b2lkIDAgOiBfdm1fY29uc3RhbnRzLlVTRV9NQUlOX0NPTlRFWFRfREVGQVVMVF9MT0FERVIpICE9IG51bGwgPyBfdm1fY29uc3RhbnRzX1VTRV9NQUlOX0NPTlRFWFRfREVGQVVMVF9MT0FERVIgOiBpbXBvcnROb2RlTW9kdWxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNjcmlwdC5ydW5JblRoaXNDb250ZXh0KCkoc2NyaXB0Q29udGV4dC5leHBvcnRzLCBzY3JpcHRDb250ZXh0Lm1vZHVsZSwgZXZhbCgncmVxdWlyZScpLCB1cmxEaXJuYW1lLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZEludGVyZmFjZSA9IHNjcmlwdENvbnRleHQubW9kdWxlLmV4cG9ydHMgfHwgc2NyaXB0Q29udGV4dC5leHBvcnRzO1xuICAgICAgICAgICAgaWYgKGF0dHJzICYmIGV4cG9ydGVkSW50ZXJmYWNlICYmIGF0dHJzWydnbG9iYWxOYW1lJ10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBleHBvcnRlZEludGVyZmFjZVthdHRyc1snZ2xvYmFsTmFtZSddXSB8fCBleHBvcnRlZEludGVyZmFjZTtcbiAgICAgICAgICAgICAgICBjYih1bmRlZmluZWQsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IodW5kZWZpbmVkLCBleHBvcnRlZEludGVyZmFjZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNiKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoYFNjcmlwdCBleGVjdXRpb24gZXJyb3I6ICR7ZX1gKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGdldEZldGNoKCkudGhlbihhc3luYyAoZik9PntcbiAgICAgICAgaWYgKChhdHRycyA9PSBudWxsID8gdm9pZCAwIDogYXR0cnNbJ3R5cGUnXSkgPT09ICdlc20nIHx8IChhdHRycyA9PSBudWxsID8gdm9pZCAwIDogYXR0cnNbJ3R5cGUnXSkgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZE1vZHVsZSh1cmxPYmouaHJlZiwge1xuICAgICAgICAgICAgICAgIGZldGNoOiBmLFxuICAgICAgICAgICAgICAgIHZtOiBhd2FpdCBpbXBvcnROb2RlTW9kdWxlKCd2bScpXG4gICAgICAgICAgICB9KS50aGVuKGFzeW5jIChtb2R1bGUpPT57XG4gICAgICAgICAgICAgICAgYXdhaXQgbW9kdWxlLmV2YWx1YXRlKCk7XG4gICAgICAgICAgICAgICAgY2IodW5kZWZpbmVkLCBtb2R1bGUubmFtZXNwYWNlKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlKT0+e1xuICAgICAgICAgICAgICAgIGNiKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IoYFNjcmlwdCBleGVjdXRpb24gZXJyb3I6ICR7ZX1gKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVTY3JpcHRGZXRjaChmLCB1cmxPYmopO1xuICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgIGNiKGVycik7XG4gICAgfSk7XG59IDogKHVybCwgY2IsIGF0dHJzLCBsb2FkZXJIb29rKT0+e1xuICAgIGNiKG5ldyBFcnJvcignY3JlYXRlU2NyaXB0Tm9kZSBpcyBkaXNhYmxlZCBpbiBub24tTm9kZS5qcyBlbnZpcm9ubWVudCcpKTtcbn07XG5jb25zdCBsb2FkU2NyaXB0Tm9kZSA9IHR5cGVvZiBFTlZfVEFSR0VUID09PSAndW5kZWZpbmVkJyB8fCBFTlZfVEFSR0VUICE9PSAnd2ViJyA/ICh1cmwsIGluZm8pPT57XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNyZWF0ZVNjcmlwdE5vZGUodXJsLCAoZXJyb3IsIHNjcmlwdENvbnRleHQpPT57XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2luZm9fYXR0cnMsIF9pbmZvX2F0dHJzMTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVFbnRyeUtleSA9IChpbmZvID09IG51bGwgPyB2b2lkIDAgOiAoX2luZm9fYXR0cnMgPSBpbmZvLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fYXR0cnNbJ2dsb2JhbE5hbWUnXSkgfHwgYF9fRkVERVJBVElPTl8ke2luZm8gPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5mb19hdHRyczEgPSBpbmZvLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fYXR0cnMxWyduYW1lJ119OmN1c3RvbV9fYDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeUV4cG9ydHMgPSBnbG9iYWxUaGlzW3JlbW90ZUVudHJ5S2V5XSA9IHNjcmlwdENvbnRleHQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRyeUV4cG9ydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpbmZvLmF0dHJzLCBpbmZvLmxvYWRlckhvb2spO1xuICAgIH0pO1xufSA6ICh1cmwsIGluZm8pPT57XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsb2FkU2NyaXB0Tm9kZSBpcyBkaXNhYmxlZCBpbiBub24tTm9kZS5qcyBlbnZpcm9ubWVudCcpO1xufTtcbmNvbnN0IGVzbU1vZHVsZUNhY2hlID0gbmV3IE1hcCgpO1xuYXN5bmMgZnVuY3Rpb24gbG9hZE1vZHVsZSh1cmwsIG9wdGlvbnMpIHtcbiAgICAvLyBDaGVjayBjYWNoZSB0byBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvbiBpbiBFU00gbG9hZGluZ1xuICAgIGlmIChlc21Nb2R1bGVDYWNoZS5oYXModXJsKSkge1xuICAgICAgICByZXR1cm4gZXNtTW9kdWxlQ2FjaGUuZ2V0KHVybCk7XG4gICAgfVxuICAgIGNvbnN0IHsgZmV0Y2g6IGZldGNoMSwgdm0gfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaDEodXJsKTtcbiAgICBjb25zdCBjb2RlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGNvbnN0IG1vZHVsZSA9IG5ldyB2bS5Tb3VyY2VUZXh0TW9kdWxlKGNvZGUsIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpbXBvcnRNb2R1bGVEeW5hbWljYWxseTogYXN5bmMgKHNwZWNpZmllciwgc2NyaXB0KT0+e1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRVcmwgPSBuZXcgVVJMKHNwZWNpZmllciwgdXJsKS5ocmVmO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRNb2R1bGUocmVzb2x2ZWRVcmwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQ2FjaGUgdGhlIG1vZHVsZSBiZWZvcmUgbGlua2luZyB0byBwcmV2ZW50IGN5Y2xlc1xuICAgIGVzbU1vZHVsZUNhY2hlLnNldCh1cmwsIG1vZHVsZSk7XG4gICAgYXdhaXQgbW9kdWxlLmxpbmsoYXN5bmMgKHNwZWNpZmllcik9PntcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRVcmwgPSBuZXcgVVJMKHNwZWNpZmllciwgdXJsKS5ocmVmO1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBsb2FkTW9kdWxlKHJlc29sdmVkVXJsLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9KTtcbiAgICByZXR1cm4gbW9kdWxlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKGVuYWJsZURlZmF1bHQsIGRlZmF1bHRPcHRpb25zLCBrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBmb3IgXFxgJHtrZXl9XFxgLCBleHBlY3QgYm9vbGVhbi91bmRlZmluZWQvb2JqZWN0LCBnb3Q6ICR7dHlwZW9mIG9wdGlvbnN9YCk7XG4gICAgfTtcbn1cblxuY29uc3QgY3JlYXRlTW9kdWxlRmVkZXJhdGlvbkNvbmZpZyA9IChvcHRpb25zKT0+e1xuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuZXhwb3J0IHsgQlJPV1NFUl9MT0dfS0VZLCBFTkNPREVfTkFNRV9QUkVGSVgsIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwLCBGZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3QsIE1BTklGRVNUX0VYVCwgTUZNb2R1bGVUeXBlLCBNRlByZWZldGNoQ29tbW9uLCBNT0RVTEVfREVWVE9PTF9JREVOVElGSUVSLCBNYW5pZmVzdEZpbGVOYW1lLCBOYW1lVHJhbnNmb3JtTWFwLCBOYW1lVHJhbnNmb3JtU3ltYm9sLCBTRVBBUkFUT1IsIFN0YXRzRmlsZU5hbWUsIFRFTVBfRElSLCBhc3NlcnQsIGNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yLCBDb250YWluZXJQbHVnaW4gYXMgY29udGFpbmVyUGx1Z2luLCBDb250YWluZXJSZWZlcmVuY2VQbHVnaW4gYXMgY29udGFpbmVyUmVmZXJlbmNlUGx1Z2luLCBjcmVhdGVMaW5rLCBjcmVhdGVMb2dnZXIsIGNyZWF0ZU1vZHVsZUZlZGVyYXRpb25Db25maWcsIGNyZWF0ZVNjcmlwdCwgY3JlYXRlU2NyaXB0Tm9kZSwgZGVjb2RlTmFtZSwgZW5jb2RlTmFtZSwgZXJyb3IsIGdlbmVyYXRlRXhwb3NlRmlsZW5hbWUsIGdlbmVyYXRlU2hhcmVGaWxlbmFtZSwgZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdCwgZ2V0UHJvY2Vzc0VudiwgZ2V0UmVzb3VyY2VVcmwsIGluZmVyQXV0b1B1YmxpY1BhdGgsIGlzQnJvd3NlckVudiwgaXNEZWJ1Z01vZGUsIGlzTWFuaWZlc3RQcm92aWRlciwgaXNSZWFjdE5hdGl2ZUVudiwgaXNSZXF1aXJlZFZlcnNpb24sIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwsIGxvYWRTY3JpcHQsIGxvYWRTY3JpcHROb2RlLCBsb2dnZXIsIE1vZHVsZUZlZGVyYXRpb25QbHVnaW4gYXMgbW9kdWxlRmVkZXJhdGlvblBsdWdpbiwgbm9ybWFsaXplT3B0aW9ucywgcGFyc2VFbnRyeSwgc2FmZVRvU3RyaW5nLCBzYWZlV3JhcHBlciwgU2hhcmVQbHVnaW4gYXMgc2hhcmVQbHVnaW4sIHNpbXBsZUpvaW5SZW1vdGVFbnRyeSwgd2FybiB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/sdk/dist/index.esm.js\n");

/***/ }),

/***/ "./node_modules/@module-federation/sdk/dist/polyfills.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@module-federation/sdk/dist/polyfills.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _extends)\n/* harmony export */ });\nfunction _extends() {\n    _extends = Object.assign || function assign(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3Nkay9kaXN0L3BvbHlmaWxscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxXaW4gMTFcXERlc2t0b3BcXFJlYWN0LU1pY3JvRnJvbnRlbmRcXG1pY3JvLWZyb250ZW5kXFxjaGFydFxcbm9kZV9tb2R1bGVzXFxAbW9kdWxlLWZlZGVyYXRpb25cXHNka1xcZGlzdFxccG9seWZpbGxzLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2UpaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgeyBfZXh0ZW5kcyBhcyBfIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/sdk/dist/polyfills.esm.js\n");

/***/ }),

/***/ "./node_modules/@module-federation/webpack-bundler-runtime/dist/constant.esm.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@module-federation/webpack-bundler-runtime/dist/constant.esm.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FEDERATION_SUPPORTED_TYPES: () => (/* binding */ FEDERATION_SUPPORTED_TYPES)\n/* harmony export */ });\nconst FEDERATION_SUPPORTED_TYPES = [\n    'script'\n];\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3dlYnBhY2stYnVuZGxlci1ydW50aW1lL2Rpc3QvY29uc3RhbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRXNDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFdpbiAxMVxcRGVza3RvcFxcUmVhY3QtTWljcm9Gcm9udGVuZFxcbWljcm8tZnJvbnRlbmRcXGNoYXJ0XFxub2RlX21vZHVsZXNcXEBtb2R1bGUtZmVkZXJhdGlvblxcd2VicGFjay1idW5kbGVyLXJ1bnRpbWVcXGRpc3RcXGNvbnN0YW50LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBGRURFUkFUSU9OX1NVUFBPUlRFRF9UWVBFUyA9IFtcbiAgICAnc2NyaXB0J1xuXTtcblxuZXhwb3J0IHsgRkVERVJBVElPTl9TVVBQT1JURURfVFlQRVMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/webpack-bundler-runtime/dist/constant.esm.js\n");

/***/ }),

/***/ "./node_modules/@module-federation/webpack-bundler-runtime/dist/index.esm.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@module-federation/webpack-bundler-runtime/dist/index.esm.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ federation)\n/* harmony export */ });\n/* harmony import */ var _module_federation_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @module-federation/runtime */ \"./node_modules/@module-federation/runtime/dist/index.esm.js\");\n/* harmony import */ var _constant_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.esm.js */ \"./node_modules/@module-federation/webpack-bundler-runtime/dist/constant.esm.js\");\n/* harmony import */ var _module_federation_sdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @module-federation/sdk */ \"./node_modules/@module-federation/sdk/dist/index.esm.js\");\n\n\n\n\nfunction attachShareScopeMap(webpackRequire) {\n    if (!webpackRequire.S || webpackRequire.federation.hasAttachShareScopeMap || !webpackRequire.federation.instance || !webpackRequire.federation.instance.shareScopeMap) {\n        return;\n    }\n    webpackRequire.S = webpackRequire.federation.instance.shareScopeMap;\n    webpackRequire.federation.hasAttachShareScopeMap = true;\n}\n\nfunction remotes(options) {\n    const { chunkId, promises, chunkMapping, idToExternalAndNameMapping, webpackRequire, idToRemoteMap } = options;\n    attachShareScopeMap(webpackRequire);\n    if (webpackRequire.o(chunkMapping, chunkId)) {\n        chunkMapping[chunkId].forEach((id)=>{\n            let getScope = webpackRequire.R;\n            if (!getScope) {\n                getScope = [];\n            }\n            const data = idToExternalAndNameMapping[id];\n            const remoteInfos = idToRemoteMap[id];\n            // @ts-ignore seems not work\n            if (getScope.indexOf(data) >= 0) {\n                return;\n            }\n            // @ts-ignore seems not work\n            getScope.push(data);\n            if (data.p) {\n                return promises.push(data.p);\n            }\n            const onError = (error)=>{\n                if (!error) {\n                    error = new Error('Container missing');\n                }\n                if (typeof error.message === 'string') {\n                    error.message += `\\nwhile loading \"${data[1]}\" from ${data[2]}`;\n                }\n                webpackRequire.m[id] = ()=>{\n                    throw error;\n                };\n                data.p = 0;\n            };\n            const handleFunction = (fn, arg1, arg2, d, next, first)=>{\n                try {\n                    const promise = fn(arg1, arg2);\n                    if (promise && promise.then) {\n                        const p = promise.then((result)=>next(result, d), onError);\n                        if (first) {\n                            promises.push(data.p = p);\n                        } else {\n                            return p;\n                        }\n                    } else {\n                        return next(promise, d, first);\n                    }\n                } catch (error) {\n                    onError(error);\n                }\n            };\n            const onExternal = (external, _, first)=>external ? handleFunction(webpackRequire.I, data[0], 0, external, onInitialized, first) : onError();\n            // eslint-disable-next-line no-var\n            var onInitialized = (_, external, first)=>handleFunction(external.get, data[1], getScope, 0, onFactory, first);\n            // eslint-disable-next-line no-var\n            var onFactory = (factory)=>{\n                data.p = 1;\n                webpackRequire.m[id] = (module)=>{\n                    module.exports = factory();\n                };\n            };\n            const onRemoteLoaded = ()=>{\n                try {\n                    const remoteName = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_2__.decodeName)(remoteInfos[0].name, _module_federation_sdk__WEBPACK_IMPORTED_MODULE_2__.ENCODE_NAME_PREFIX);\n                    const remoteModuleName = remoteName + data[1].slice(1);\n                    const instance = webpackRequire.federation.instance;\n                    const loadRemote = ()=>webpackRequire.federation.instance.loadRemote(remoteModuleName, {\n                            loadFactory: false,\n                            from: 'build'\n                        });\n                    if (instance.options.shareStrategy === 'version-first') {\n                        return Promise.all(instance.sharedHandler.initializeSharing(data[0])).then(()=>{\n                            return loadRemote();\n                        });\n                    }\n                    return loadRemote();\n                } catch (error) {\n                    onError(error);\n                }\n            };\n            const useRuntimeLoad = remoteInfos.length === 1 && _constant_esm_js__WEBPACK_IMPORTED_MODULE_1__.FEDERATION_SUPPORTED_TYPES.includes(remoteInfos[0].externalType) && remoteInfos[0].name;\n            if (useRuntimeLoad) {\n                handleFunction(onRemoteLoaded, data[2], 0, 0, onFactory, 1);\n            } else {\n                handleFunction(webpackRequire, data[2], 0, 0, onExternal, 1);\n            }\n        });\n    }\n}\n\nfunction consumes(options) {\n    const { chunkId, promises, chunkMapping, installedModules, moduleToHandlerMapping, webpackRequire } = options;\n    attachShareScopeMap(webpackRequire);\n    if (webpackRequire.o(chunkMapping, chunkId)) {\n        chunkMapping[chunkId].forEach((id)=>{\n            if (webpackRequire.o(installedModules, id)) {\n                return promises.push(installedModules[id]);\n            }\n            const onFactory = (factory)=>{\n                installedModules[id] = 0;\n                webpackRequire.m[id] = (module)=>{\n                    var _shareInfo_shareConfig;\n                    delete webpackRequire.c[id];\n                    const result = factory();\n                    // Add layer property from shareConfig if available\n                    const { shareInfo } = moduleToHandlerMapping[id];\n                    if ((shareInfo == null ? void 0 : (_shareInfo_shareConfig = shareInfo.shareConfig) == null ? void 0 : _shareInfo_shareConfig.layer) && result && typeof result === 'object') {\n                        try {\n                            // Only set layer if it's not already defined or if it's undefined\n                            if (!result.hasOwnProperty('layer') || result.layer === undefined) {\n                                result.layer = shareInfo.shareConfig.layer;\n                            }\n                        } catch (e) {\n                        // Ignore if layer property is read-only\n                        }\n                    }\n                    module.exports = result;\n                };\n            };\n            const onError = (error)=>{\n                delete installedModules[id];\n                webpackRequire.m[id] = (module)=>{\n                    delete webpackRequire.c[id];\n                    throw error;\n                };\n            };\n            try {\n                const federationInstance = webpackRequire.federation.instance;\n                if (!federationInstance) {\n                    throw new Error('Federation instance not found!');\n                }\n                const { shareKey, getter, shareInfo } = moduleToHandlerMapping[id];\n                const promise = federationInstance.loadShare(shareKey, {\n                    customShareInfo: shareInfo\n                }).then((factory)=>{\n                    if (factory === false) {\n                        return getter();\n                    }\n                    return factory;\n                });\n                if (promise.then) {\n                    promises.push(installedModules[id] = promise.then(onFactory).catch(onError));\n                } else {\n                    // @ts-ignore maintain previous logic\n                    onFactory(promise);\n                }\n            } catch (e) {\n                onError(e);\n            }\n        });\n    }\n}\n\nfunction initializeSharing({ shareScopeName, webpackRequire, initPromises, initTokens, initScope }) {\n    const shareScopeKeys = Array.isArray(shareScopeName) ? shareScopeName : [\n        shareScopeName\n    ];\n    var initializeSharingPromises = [];\n    var _initializeSharing = function(shareScopeKey) {\n        if (!initScope) initScope = [];\n        const mfInstance = webpackRequire.federation.instance;\n        // handling circular init calls\n        var initToken = initTokens[shareScopeKey];\n        if (!initToken) initToken = initTokens[shareScopeKey] = {\n            from: mfInstance.name\n        };\n        if (initScope.indexOf(initToken) >= 0) return;\n        initScope.push(initToken);\n        const promise = initPromises[shareScopeKey];\n        if (promise) return promise;\n        var warn = (msg)=>typeof console !== 'undefined' && console.warn && console.warn(msg);\n        var initExternal = (id)=>{\n            var handleError = (err)=>warn('Initialization of sharing external failed: ' + err);\n            try {\n                var module = webpackRequire(id);\n                if (!module) return;\n                var initFn = (module)=>module && module.init && // @ts-ignore compat legacy mf shared behavior\n                    module.init(webpackRequire.S[shareScopeKey], initScope, {\n                        shareScopeMap: webpackRequire.S || {},\n                        shareScopeKeys: shareScopeName\n                    });\n                if (module.then) return promises.push(module.then(initFn, handleError));\n                var initResult = initFn(module);\n                // @ts-ignore\n                if (initResult && typeof initResult !== 'boolean' && initResult.then) // @ts-ignore\n                return promises.push(initResult['catch'](handleError));\n            } catch (err) {\n                handleError(err);\n            }\n        };\n        const promises = mfInstance.initializeSharing(shareScopeKey, {\n            strategy: mfInstance.options.shareStrategy,\n            initScope,\n            from: 'build'\n        });\n        attachShareScopeMap(webpackRequire);\n        const bundlerRuntimeRemotesOptions = webpackRequire.federation.bundlerRuntimeOptions.remotes;\n        if (bundlerRuntimeRemotesOptions) {\n            Object.keys(bundlerRuntimeRemotesOptions.idToRemoteMap).forEach((moduleId)=>{\n                const info = bundlerRuntimeRemotesOptions.idToRemoteMap[moduleId];\n                const externalModuleId = bundlerRuntimeRemotesOptions.idToExternalAndNameMapping[moduleId][2];\n                if (info.length > 1) {\n                    initExternal(externalModuleId);\n                } else if (info.length === 1) {\n                    const remoteInfo = info[0];\n                    if (!_constant_esm_js__WEBPACK_IMPORTED_MODULE_1__.FEDERATION_SUPPORTED_TYPES.includes(remoteInfo.externalType)) {\n                        initExternal(externalModuleId);\n                    }\n                }\n            });\n        }\n        if (!promises.length) {\n            return initPromises[shareScopeKey] = true;\n        }\n        return initPromises[shareScopeKey] = Promise.all(promises).then(()=>initPromises[shareScopeKey] = true);\n    };\n    shareScopeKeys.forEach((key)=>{\n        initializeSharingPromises.push(_initializeSharing(key));\n    });\n    return Promise.all(initializeSharingPromises).then(()=>true);\n}\n\nfunction handleInitialConsumes(options) {\n    const { moduleId, moduleToHandlerMapping, webpackRequire } = options;\n    const federationInstance = webpackRequire.federation.instance;\n    if (!federationInstance) {\n        throw new Error('Federation instance not found!');\n    }\n    const { shareKey, shareInfo } = moduleToHandlerMapping[moduleId];\n    try {\n        return federationInstance.loadShareSync(shareKey, {\n            customShareInfo: shareInfo\n        });\n    } catch (err) {\n        console.error('loadShareSync failed! The function should not be called unless you set \"eager:true\". If you do not set it, and encounter this issue, you can check whether an async boundary is implemented.');\n        console.error('The original error message is as follows: ');\n        throw err;\n    }\n}\nfunction installInitialConsumes(options) {\n    const { moduleToHandlerMapping, webpackRequire, installedModules, initialConsumes } = options;\n    initialConsumes.forEach((id)=>{\n        webpackRequire.m[id] = (module)=>{\n            var _shareInfo_shareConfig;\n            // Handle scenario when module is used synchronously\n            installedModules[id] = 0;\n            delete webpackRequire.c[id];\n            const factory = handleInitialConsumes({\n                moduleId: id,\n                moduleToHandlerMapping,\n                webpackRequire\n            });\n            if (typeof factory !== 'function') {\n                throw new Error(`Shared module is not available for eager consumption: ${id}`);\n            }\n            const result = factory();\n            // Add layer property from shareConfig if available\n            const { shareInfo } = moduleToHandlerMapping[id];\n            if ((shareInfo == null ? void 0 : (_shareInfo_shareConfig = shareInfo.shareConfig) == null ? void 0 : _shareInfo_shareConfig.layer) && result && typeof result === 'object') {\n                try {\n                    // Only set layer if it's not already defined or if it's undefined\n                    if (!result.hasOwnProperty('layer') || result.layer === undefined) {\n                        result.layer = shareInfo.shareConfig.layer;\n                    }\n                } catch (e) {\n                // Ignore if layer property is read-only\n                }\n            }\n            module.exports = result;\n        };\n    });\n}\n\nfunction _extends() {\n    _extends = Object.assign || function assign(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n\nfunction initContainerEntry(options) {\n    const { webpackRequire, shareScope, initScope, shareScopeKey, remoteEntryInitOptions } = options;\n    if (!webpackRequire.S) return;\n    if (!webpackRequire.federation || !webpackRequire.federation.instance || !webpackRequire.federation.initOptions) return;\n    const federationInstance = webpackRequire.federation.instance;\n    federationInstance.initOptions(_extends({\n        name: webpackRequire.federation.initOptions.name,\n        remotes: []\n    }, remoteEntryInitOptions));\n    const hostShareScopeKeys = remoteEntryInitOptions == null ? void 0 : remoteEntryInitOptions.shareScopeKeys;\n    const hostShareScopeMap = remoteEntryInitOptions == null ? void 0 : remoteEntryInitOptions.shareScopeMap;\n    // host: 'default' remote: 'default'  remote['default'] = hostShareScopeMap['default']\n    // host: ['default', 'scope1'] remote: 'default'  remote['default'] = hostShareScopeMap['default']; remote['scope1'] = hostShareScopeMap['scop1']\n    // host: 'default' remote: ['default','scope1']  remote['default'] = hostShareScopeMap['default']; remote['scope1'] = hostShareScopeMap['scope1'] = {}\n    // host: ['scope1','default'] remote: ['scope1','scope2'] => remote['scope1'] = hostShareScopeMap['scope1']; remote['scope2'] = hostShareScopeMap['scope2'] = {};\n    if (!shareScopeKey || typeof shareScopeKey === 'string') {\n        const key = shareScopeKey || 'default';\n        if (Array.isArray(hostShareScopeKeys)) {\n            // const sc = hostShareScopeMap![key];\n            // if (!sc) {\n            //   throw new Error('shareScopeKey is not exist in hostShareScopeMap');\n            // }\n            // federationInstance.initShareScopeMap(key, sc, {\n            //   hostShareScopeMap: remoteEntryInitOptions?.shareScopeMap || {},\n            // });\n            hostShareScopeKeys.forEach((hostKey)=>{\n                if (!hostShareScopeMap[hostKey]) {\n                    hostShareScopeMap[hostKey] = {};\n                }\n                const sc = hostShareScopeMap[hostKey];\n                federationInstance.initShareScopeMap(hostKey, sc, {\n                    hostShareScopeMap: (remoteEntryInitOptions == null ? void 0 : remoteEntryInitOptions.shareScopeMap) || {}\n                });\n            });\n        } else {\n            federationInstance.initShareScopeMap(key, shareScope, {\n                hostShareScopeMap: (remoteEntryInitOptions == null ? void 0 : remoteEntryInitOptions.shareScopeMap) || {}\n            });\n        }\n    } else {\n        shareScopeKey.forEach((key)=>{\n            if (!hostShareScopeKeys || !hostShareScopeMap) {\n                federationInstance.initShareScopeMap(key, shareScope, {\n                    hostShareScopeMap: (remoteEntryInitOptions == null ? void 0 : remoteEntryInitOptions.shareScopeMap) || {}\n                });\n                return;\n            }\n            if (!hostShareScopeMap[key]) {\n                hostShareScopeMap[key] = {};\n            }\n            const sc = hostShareScopeMap[key];\n            federationInstance.initShareScopeMap(key, sc, {\n                hostShareScopeMap: (remoteEntryInitOptions == null ? void 0 : remoteEntryInitOptions.shareScopeMap) || {}\n            });\n        });\n    }\n    if (webpackRequire.federation.attachShareScopeMap) {\n        webpackRequire.federation.attachShareScopeMap(webpackRequire);\n    }\n    if (typeof webpackRequire.federation.prefetch === 'function') {\n        webpackRequire.federation.prefetch();\n    }\n    if (!Array.isArray(shareScopeKey)) {\n        // @ts-ignore\n        return webpackRequire.I(shareScopeKey || 'default', initScope);\n    }\n    var proxyInitializeSharing = Boolean(webpackRequire.federation.initOptions.shared);\n    if (proxyInitializeSharing) {\n        // @ts-ignore\n        return webpackRequire.I(shareScopeKey, initScope);\n    }\n    // @ts-ignore\n    return Promise.all(shareScopeKey.map((key)=>{\n        // @ts-ignore\n        return webpackRequire.I(key, initScope);\n    })).then(()=>true);\n}\n\nconst federation = {\n    runtime: _module_federation_runtime__WEBPACK_IMPORTED_MODULE_0__,\n    instance: undefined,\n    initOptions: undefined,\n    bundlerRuntime: {\n        remotes,\n        consumes,\n        I: initializeSharing,\n        S: {},\n        installInitialConsumes,\n        initContainerEntry\n    },\n    attachShareScopeMap,\n    bundlerRuntimeOptions: {}\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3dlYnBhY2stYnVuZGxlci1ydW50aW1lL2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0Q7QUFDUztBQUNTOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNkZBQTZGO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxTQUFTLFFBQVE7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrRUFBVSxzQkFBc0Isc0VBQWtCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHdFQUEwQjtBQUN6RjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFlBQVksNEZBQTRGO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsNkJBQTZCLHFFQUFxRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EseUJBQXlCLHdFQUEwQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEVBQTRFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EseUZBQXlGLEdBQUc7QUFDNUY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLCtFQUErRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHLHVHQUF1RztBQUN2RyxpSEFBaUg7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVpQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxXaW4gMTFcXERlc2t0b3BcXFJlYWN0LU1pY3JvRnJvbnRlbmRcXG1pY3JvLWZyb250ZW5kXFxjaGFydFxcbm9kZV9tb2R1bGVzXFxAbW9kdWxlLWZlZGVyYXRpb25cXHdlYnBhY2stYnVuZGxlci1ydW50aW1lXFxkaXN0XFxpbmRleC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcnVudGltZSBmcm9tICdAbW9kdWxlLWZlZGVyYXRpb24vcnVudGltZSc7XG5pbXBvcnQgeyBGRURFUkFUSU9OX1NVUFBPUlRFRF9UWVBFUyB9IGZyb20gJy4vY29uc3RhbnQuZXNtLmpzJztcbmltcG9ydCB7IGRlY29kZU5hbWUsIEVOQ09ERV9OQU1FX1BSRUZJWCB9IGZyb20gJ0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsnO1xuXG5mdW5jdGlvbiBhdHRhY2hTaGFyZVNjb3BlTWFwKHdlYnBhY2tSZXF1aXJlKSB7XG4gICAgaWYgKCF3ZWJwYWNrUmVxdWlyZS5TIHx8IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaGFzQXR0YWNoU2hhcmVTY29wZU1hcCB8fCAhd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZSB8fCAhd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZS5zaGFyZVNjb3BlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2VicGFja1JlcXVpcmUuUyA9IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2Uuc2hhcmVTY29wZU1hcDtcbiAgICB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmhhc0F0dGFjaFNoYXJlU2NvcGVNYXAgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiByZW1vdGVzKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNodW5rSWQsIHByb21pc2VzLCBjaHVua01hcHBpbmcsIGlkVG9FeHRlcm5hbEFuZE5hbWVNYXBwaW5nLCB3ZWJwYWNrUmVxdWlyZSwgaWRUb1JlbW90ZU1hcCB9ID0gb3B0aW9ucztcbiAgICBhdHRhY2hTaGFyZVNjb3BlTWFwKHdlYnBhY2tSZXF1aXJlKTtcbiAgICBpZiAod2VicGFja1JlcXVpcmUubyhjaHVua01hcHBpbmcsIGNodW5rSWQpKSB7XG4gICAgICAgIGNodW5rTWFwcGluZ1tjaHVua0lkXS5mb3JFYWNoKChpZCk9PntcbiAgICAgICAgICAgIGxldCBnZXRTY29wZSA9IHdlYnBhY2tSZXF1aXJlLlI7XG4gICAgICAgICAgICBpZiAoIWdldFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgZ2V0U2NvcGUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBpZFRvRXh0ZXJuYWxBbmROYW1lTWFwcGluZ1tpZF07XG4gICAgICAgICAgICBjb25zdCByZW1vdGVJbmZvcyA9IGlkVG9SZW1vdGVNYXBbaWRdO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzZWVtcyBub3Qgd29ya1xuICAgICAgICAgICAgaWYgKGdldFNjb3BlLmluZGV4T2YoZGF0YSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc2VlbXMgbm90IHdvcmtcbiAgICAgICAgICAgIGdldFNjb3BlLnB1c2goZGF0YSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzLnB1c2goZGF0YS5wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyb3IpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQ29udGFpbmVyIG1pc3NpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlICs9IGBcXG53aGlsZSBsb2FkaW5nIFwiJHtkYXRhWzFdfVwiIGZyb20gJHtkYXRhWzJdfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdlYnBhY2tSZXF1aXJlLm1baWRdID0gKCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkYXRhLnAgPSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUZ1bmN0aW9uID0gKGZuLCBhcmcxLCBhcmcyLCBkLCBuZXh0LCBmaXJzdCk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZm4oYXJnMSwgYXJnMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlICYmIHByb21pc2UudGhlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHByb21pc2UudGhlbigocmVzdWx0KT0+bmV4dChyZXN1bHQsIGQpLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZGF0YS5wID0gcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQocHJvbWlzZSwgZCwgZmlyc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXh0ZXJuYWwgPSAoZXh0ZXJuYWwsIF8sIGZpcnN0KT0+ZXh0ZXJuYWwgPyBoYW5kbGVGdW5jdGlvbih3ZWJwYWNrUmVxdWlyZS5JLCBkYXRhWzBdLCAwLCBleHRlcm5hbCwgb25Jbml0aWFsaXplZCwgZmlyc3QpIDogb25FcnJvcigpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICAgICAgICAgICAgdmFyIG9uSW5pdGlhbGl6ZWQgPSAoXywgZXh0ZXJuYWwsIGZpcnN0KT0+aGFuZGxlRnVuY3Rpb24oZXh0ZXJuYWwuZ2V0LCBkYXRhWzFdLCBnZXRTY29wZSwgMCwgb25GYWN0b3J5LCBmaXJzdCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyXG4gICAgICAgICAgICB2YXIgb25GYWN0b3J5ID0gKGZhY3RvcnkpPT57XG4gICAgICAgICAgICAgICAgZGF0YS5wID0gMTtcbiAgICAgICAgICAgICAgICB3ZWJwYWNrUmVxdWlyZS5tW2lkXSA9IChtb2R1bGUpPT57XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25SZW1vdGVMb2FkZWQgPSAoKT0+e1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZU5hbWUgPSBkZWNvZGVOYW1lKHJlbW90ZUluZm9zWzBdLm5hbWUsIEVOQ09ERV9OQU1FX1BSRUZJWCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZU1vZHVsZU5hbWUgPSByZW1vdGVOYW1lICsgZGF0YVsxXS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkUmVtb3RlID0gKCk9PndlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2UubG9hZFJlbW90ZShyZW1vdGVNb2R1bGVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEZhY3Rvcnk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206ICdidWlsZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uub3B0aW9ucy5zaGFyZVN0cmF0ZWd5ID09PSAndmVyc2lvbi1maXJzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChpbnN0YW5jZS5zaGFyZWRIYW5kbGVyLmluaXRpYWxpemVTaGFyaW5nKGRhdGFbMF0pKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRSZW1vdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2FkUmVtb3RlKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHVzZVJ1bnRpbWVMb2FkID0gcmVtb3RlSW5mb3MubGVuZ3RoID09PSAxICYmIEZFREVSQVRJT05fU1VQUE9SVEVEX1RZUEVTLmluY2x1ZGVzKHJlbW90ZUluZm9zWzBdLmV4dGVybmFsVHlwZSkgJiYgcmVtb3RlSW5mb3NbMF0ubmFtZTtcbiAgICAgICAgICAgIGlmICh1c2VSdW50aW1lTG9hZCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUZ1bmN0aW9uKG9uUmVtb3RlTG9hZGVkLCBkYXRhWzJdLCAwLCAwLCBvbkZhY3RvcnksIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVGdW5jdGlvbih3ZWJwYWNrUmVxdWlyZSwgZGF0YVsyXSwgMCwgMCwgb25FeHRlcm5hbCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29uc3VtZXMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2h1bmtJZCwgcHJvbWlzZXMsIGNodW5rTWFwcGluZywgaW5zdGFsbGVkTW9kdWxlcywgbW9kdWxlVG9IYW5kbGVyTWFwcGluZywgd2VicGFja1JlcXVpcmUgfSA9IG9wdGlvbnM7XG4gICAgYXR0YWNoU2hhcmVTY29wZU1hcCh3ZWJwYWNrUmVxdWlyZSk7XG4gICAgaWYgKHdlYnBhY2tSZXF1aXJlLm8oY2h1bmtNYXBwaW5nLCBjaHVua0lkKSkge1xuICAgICAgICBjaHVua01hcHBpbmdbY2h1bmtJZF0uZm9yRWFjaCgoaWQpPT57XG4gICAgICAgICAgICBpZiAod2VicGFja1JlcXVpcmUubyhpbnN0YWxsZWRNb2R1bGVzLCBpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZXMucHVzaChpbnN0YWxsZWRNb2R1bGVzW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvbkZhY3RvcnkgPSAoZmFjdG9yeSk9PntcbiAgICAgICAgICAgICAgICBpbnN0YWxsZWRNb2R1bGVzW2lkXSA9IDA7XG4gICAgICAgICAgICAgICAgd2VicGFja1JlcXVpcmUubVtpZF0gPSAobW9kdWxlKT0+e1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3NoYXJlSW5mb19zaGFyZUNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdlYnBhY2tSZXF1aXJlLmNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBsYXllciBwcm9wZXJ0eSBmcm9tIHNoYXJlQ29uZmlnIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNoYXJlSW5mbyB9ID0gbW9kdWxlVG9IYW5kbGVyTWFwcGluZ1tpZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2hhcmVJbmZvID09IG51bGwgPyB2b2lkIDAgOiAoX3NoYXJlSW5mb19zaGFyZUNvbmZpZyA9IHNoYXJlSW5mby5zaGFyZUNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zaGFyZUluZm9fc2hhcmVDb25maWcubGF5ZXIpICYmIHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHNldCBsYXllciBpZiBpdCdzIG5vdCBhbHJlYWR5IGRlZmluZWQgb3IgaWYgaXQncyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5oYXNPd25Qcm9wZXJ0eSgnbGF5ZXInKSB8fCByZXN1bHQubGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGF5ZXIgPSBzaGFyZUluZm8uc2hhcmVDb25maWcubGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGlmIGxheWVyIHByb3BlcnR5IGlzIHJlYWQtb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnJvcik9PntcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1tpZF07XG4gICAgICAgICAgICAgICAgd2VicGFja1JlcXVpcmUubVtpZF0gPSAobW9kdWxlKT0+e1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2VicGFja1JlcXVpcmUuY1tpZF07XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmZWRlcmF0aW9uSW5zdGFuY2UgPSB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmICghZmVkZXJhdGlvbkluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmVkZXJhdGlvbiBpbnN0YW5jZSBub3QgZm91bmQhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2hhcmVLZXksIGdldHRlciwgc2hhcmVJbmZvIH0gPSBtb2R1bGVUb0hhbmRsZXJNYXBwaW5nW2lkXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZmVkZXJhdGlvbkluc3RhbmNlLmxvYWRTaGFyZShzaGFyZUtleSwge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21TaGFyZUluZm86IHNoYXJlSW5mb1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZhY3RvcnkpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWN0b3J5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChpbnN0YWxsZWRNb2R1bGVzW2lkXSA9IHByb21pc2UudGhlbihvbkZhY3RvcnkpLmNhdGNoKG9uRXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIG1haW50YWluIHByZXZpb3VzIGxvZ2ljXG4gICAgICAgICAgICAgICAgICAgIG9uRmFjdG9yeShwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplU2hhcmluZyh7IHNoYXJlU2NvcGVOYW1lLCB3ZWJwYWNrUmVxdWlyZSwgaW5pdFByb21pc2VzLCBpbml0VG9rZW5zLCBpbml0U2NvcGUgfSkge1xuICAgIGNvbnN0IHNoYXJlU2NvcGVLZXlzID0gQXJyYXkuaXNBcnJheShzaGFyZVNjb3BlTmFtZSkgPyBzaGFyZVNjb3BlTmFtZSA6IFtcbiAgICAgICAgc2hhcmVTY29wZU5hbWVcbiAgICBdO1xuICAgIHZhciBpbml0aWFsaXplU2hhcmluZ1Byb21pc2VzID0gW107XG4gICAgdmFyIF9pbml0aWFsaXplU2hhcmluZyA9IGZ1bmN0aW9uKHNoYXJlU2NvcGVLZXkpIHtcbiAgICAgICAgaWYgKCFpbml0U2NvcGUpIGluaXRTY29wZSA9IFtdO1xuICAgICAgICBjb25zdCBtZkluc3RhbmNlID0gd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZTtcbiAgICAgICAgLy8gaGFuZGxpbmcgY2lyY3VsYXIgaW5pdCBjYWxsc1xuICAgICAgICB2YXIgaW5pdFRva2VuID0gaW5pdFRva2Vuc1tzaGFyZVNjb3BlS2V5XTtcbiAgICAgICAgaWYgKCFpbml0VG9rZW4pIGluaXRUb2tlbiA9IGluaXRUb2tlbnNbc2hhcmVTY29wZUtleV0gPSB7XG4gICAgICAgICAgICBmcm9tOiBtZkluc3RhbmNlLm5hbWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluaXRTY29wZS5pbmRleE9mKGluaXRUb2tlbikgPj0gMCkgcmV0dXJuO1xuICAgICAgICBpbml0U2NvcGUucHVzaChpbml0VG9rZW4pO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gaW5pdFByb21pc2VzW3NoYXJlU2NvcGVLZXldO1xuICAgICAgICBpZiAocHJvbWlzZSkgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIHZhciB3YXJuID0gKG1zZyk9PnR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4gJiYgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgIHZhciBpbml0RXh0ZXJuYWwgPSAoaWQpPT57XG4gICAgICAgICAgICB2YXIgaGFuZGxlRXJyb3IgPSAoZXJyKT0+d2FybignSW5pdGlhbGl6YXRpb24gb2Ygc2hhcmluZyBleHRlcm5hbCBmYWlsZWQ6ICcgKyBlcnIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlID0gd2VicGFja1JlcXVpcmUoaWQpO1xuICAgICAgICAgICAgICAgIGlmICghbW9kdWxlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGluaXRGbiA9IChtb2R1bGUpPT5tb2R1bGUgJiYgbW9kdWxlLmluaXQgJiYgLy8gQHRzLWlnbm9yZSBjb21wYXQgbGVnYWN5IG1mIHNoYXJlZCBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBtb2R1bGUuaW5pdCh3ZWJwYWNrUmVxdWlyZS5TW3NoYXJlU2NvcGVLZXldLCBpbml0U2NvcGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGVNYXA6IHdlYnBhY2tSZXF1aXJlLlMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlS2V5czogc2hhcmVTY29wZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZS50aGVuKSByZXR1cm4gcHJvbWlzZXMucHVzaChtb2R1bGUudGhlbihpbml0Rm4sIGhhbmRsZUVycm9yKSk7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRSZXN1bHQgPSBpbml0Rm4obW9kdWxlKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKGluaXRSZXN1bHQgJiYgdHlwZW9mIGluaXRSZXN1bHQgIT09ICdib29sZWFuJyAmJiBpbml0UmVzdWx0LnRoZW4pIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZXMucHVzaChpbml0UmVzdWx0WydjYXRjaCddKGhhbmRsZUVycm9yKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IG1mSW5zdGFuY2UuaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZUtleSwge1xuICAgICAgICAgICAgc3RyYXRlZ3k6IG1mSW5zdGFuY2Uub3B0aW9ucy5zaGFyZVN0cmF0ZWd5LFxuICAgICAgICAgICAgaW5pdFNjb3BlLFxuICAgICAgICAgICAgZnJvbTogJ2J1aWxkJ1xuICAgICAgICB9KTtcbiAgICAgICAgYXR0YWNoU2hhcmVTY29wZU1hcCh3ZWJwYWNrUmVxdWlyZSk7XG4gICAgICAgIGNvbnN0IGJ1bmRsZXJSdW50aW1lUmVtb3Rlc09wdGlvbnMgPSB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmJ1bmRsZXJSdW50aW1lT3B0aW9ucy5yZW1vdGVzO1xuICAgICAgICBpZiAoYnVuZGxlclJ1bnRpbWVSZW1vdGVzT3B0aW9ucykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYnVuZGxlclJ1bnRpbWVSZW1vdGVzT3B0aW9ucy5pZFRvUmVtb3RlTWFwKS5mb3JFYWNoKChtb2R1bGVJZCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gYnVuZGxlclJ1bnRpbWVSZW1vdGVzT3B0aW9ucy5pZFRvUmVtb3RlTWFwW21vZHVsZUlkXTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlcm5hbE1vZHVsZUlkID0gYnVuZGxlclJ1bnRpbWVSZW1vdGVzT3B0aW9ucy5pZFRvRXh0ZXJuYWxBbmROYW1lTWFwcGluZ1ttb2R1bGVJZF1bMl07XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBpbml0RXh0ZXJuYWwoZXh0ZXJuYWxNb2R1bGVJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmZvLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gaW5mb1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFGRURFUkFUSU9OX1NVUFBPUlRFRF9UWVBFUy5pbmNsdWRlcyhyZW1vdGVJbmZvLmV4dGVybmFsVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRFeHRlcm5hbChleHRlcm5hbE1vZHVsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdFByb21pc2VzW3NoYXJlU2NvcGVLZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5pdFByb21pc2VzW3NoYXJlU2NvcGVLZXldID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCk9PmluaXRQcm9taXNlc1tzaGFyZVNjb3BlS2V5XSA9IHRydWUpO1xuICAgIH07XG4gICAgc2hhcmVTY29wZUtleXMuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICBpbml0aWFsaXplU2hhcmluZ1Byb21pc2VzLnB1c2goX2luaXRpYWxpemVTaGFyaW5nKGtleSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChpbml0aWFsaXplU2hhcmluZ1Byb21pc2VzKS50aGVuKCgpPT50cnVlKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlSW5pdGlhbENvbnN1bWVzKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG1vZHVsZUlkLCBtb2R1bGVUb0hhbmRsZXJNYXBwaW5nLCB3ZWJwYWNrUmVxdWlyZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBmZWRlcmF0aW9uSW5zdGFuY2UgPSB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluc3RhbmNlO1xuICAgIGlmICghZmVkZXJhdGlvbkluc3RhbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmVkZXJhdGlvbiBpbnN0YW5jZSBub3QgZm91bmQhJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgc2hhcmVLZXksIHNoYXJlSW5mbyB9ID0gbW9kdWxlVG9IYW5kbGVyTWFwcGluZ1ttb2R1bGVJZF07XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZlZGVyYXRpb25JbnN0YW5jZS5sb2FkU2hhcmVTeW5jKHNoYXJlS2V5LCB7XG4gICAgICAgICAgICBjdXN0b21TaGFyZUluZm86IHNoYXJlSW5mb1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignbG9hZFNoYXJlU3luYyBmYWlsZWQhIFRoZSBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCB1bmxlc3MgeW91IHNldCBcImVhZ2VyOnRydWVcIi4gSWYgeW91IGRvIG5vdCBzZXQgaXQsIGFuZCBlbmNvdW50ZXIgdGhpcyBpc3N1ZSwgeW91IGNhbiBjaGVjayB3aGV0aGVyIGFuIGFzeW5jIGJvdW5kYXJ5IGlzIGltcGxlbWVudGVkLicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBpcyBhcyBmb2xsb3dzOiAnKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc3RhbGxJbml0aWFsQ29uc3VtZXMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgbW9kdWxlVG9IYW5kbGVyTWFwcGluZywgd2VicGFja1JlcXVpcmUsIGluc3RhbGxlZE1vZHVsZXMsIGluaXRpYWxDb25zdW1lcyB9ID0gb3B0aW9ucztcbiAgICBpbml0aWFsQ29uc3VtZXMuZm9yRWFjaCgoaWQpPT57XG4gICAgICAgIHdlYnBhY2tSZXF1aXJlLm1baWRdID0gKG1vZHVsZSk9PntcbiAgICAgICAgICAgIHZhciBfc2hhcmVJbmZvX3NoYXJlQ29uZmlnO1xuICAgICAgICAgICAgLy8gSGFuZGxlIHNjZW5hcmlvIHdoZW4gbW9kdWxlIGlzIHVzZWQgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgaW5zdGFsbGVkTW9kdWxlc1tpZF0gPSAwO1xuICAgICAgICAgICAgZGVsZXRlIHdlYnBhY2tSZXF1aXJlLmNbaWRdO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IGhhbmRsZUluaXRpYWxDb25zdW1lcyh7XG4gICAgICAgICAgICAgICAgbW9kdWxlSWQ6IGlkLFxuICAgICAgICAgICAgICAgIG1vZHVsZVRvSGFuZGxlck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgd2VicGFja1JlcXVpcmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaGFyZWQgbW9kdWxlIGlzIG5vdCBhdmFpbGFibGUgZm9yIGVhZ2VyIGNvbnN1bXB0aW9uOiAke2lkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgLy8gQWRkIGxheWVyIHByb3BlcnR5IGZyb20gc2hhcmVDb25maWcgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBjb25zdCB7IHNoYXJlSW5mbyB9ID0gbW9kdWxlVG9IYW5kbGVyTWFwcGluZ1tpZF07XG4gICAgICAgICAgICBpZiAoKHNoYXJlSW5mbyA9PSBudWxsID8gdm9pZCAwIDogKF9zaGFyZUluZm9fc2hhcmVDb25maWcgPSBzaGFyZUluZm8uc2hhcmVDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfc2hhcmVJbmZvX3NoYXJlQ29uZmlnLmxheWVyKSAmJiByZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHNldCBsYXllciBpZiBpdCdzIG5vdCBhbHJlYWR5IGRlZmluZWQgb3IgaWYgaXQncyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuaGFzT3duUHJvcGVydHkoJ2xheWVyJykgfHwgcmVzdWx0LmxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5sYXllciA9IHNoYXJlSW5mby5zaGFyZUNvbmZpZy5sYXllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgaWYgbGF5ZXIgcHJvcGVydHkgaXMgcmVhZC1vbmx5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSlpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGluaXRDb250YWluZXJFbnRyeShvcHRpb25zKSB7XG4gICAgY29uc3QgeyB3ZWJwYWNrUmVxdWlyZSwgc2hhcmVTY29wZSwgaW5pdFNjb3BlLCBzaGFyZVNjb3BlS2V5LCByZW1vdGVFbnRyeUluaXRPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgIGlmICghd2VicGFja1JlcXVpcmUuUykgcmV0dXJuO1xuICAgIGlmICghd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbiB8fCAhd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZSB8fCAhd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbml0T3B0aW9ucykgcmV0dXJuO1xuICAgIGNvbnN0IGZlZGVyYXRpb25JbnN0YW5jZSA9IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2U7XG4gICAgZmVkZXJhdGlvbkluc3RhbmNlLmluaXRPcHRpb25zKF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbml0T3B0aW9ucy5uYW1lLFxuICAgICAgICByZW1vdGVzOiBbXVxuICAgIH0sIHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMpKTtcbiAgICBjb25zdCBob3N0U2hhcmVTY29wZUtleXMgPSByZW1vdGVFbnRyeUluaXRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiByZW1vdGVFbnRyeUluaXRPcHRpb25zLnNoYXJlU2NvcGVLZXlzO1xuICAgIGNvbnN0IGhvc3RTaGFyZVNjb3BlTWFwID0gcmVtb3RlRW50cnlJbml0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogcmVtb3RlRW50cnlJbml0T3B0aW9ucy5zaGFyZVNjb3BlTWFwO1xuICAgIC8vIGhvc3Q6ICdkZWZhdWx0JyByZW1vdGU6ICdkZWZhdWx0JyAgcmVtb3RlWydkZWZhdWx0J10gPSBob3N0U2hhcmVTY29wZU1hcFsnZGVmYXVsdCddXG4gICAgLy8gaG9zdDogWydkZWZhdWx0JywgJ3Njb3BlMSddIHJlbW90ZTogJ2RlZmF1bHQnICByZW1vdGVbJ2RlZmF1bHQnXSA9IGhvc3RTaGFyZVNjb3BlTWFwWydkZWZhdWx0J107IHJlbW90ZVsnc2NvcGUxJ10gPSBob3N0U2hhcmVTY29wZU1hcFsnc2NvcDEnXVxuICAgIC8vIGhvc3Q6ICdkZWZhdWx0JyByZW1vdGU6IFsnZGVmYXVsdCcsJ3Njb3BlMSddICByZW1vdGVbJ2RlZmF1bHQnXSA9IGhvc3RTaGFyZVNjb3BlTWFwWydkZWZhdWx0J107IHJlbW90ZVsnc2NvcGUxJ10gPSBob3N0U2hhcmVTY29wZU1hcFsnc2NvcGUxJ10gPSB7fVxuICAgIC8vIGhvc3Q6IFsnc2NvcGUxJywnZGVmYXVsdCddIHJlbW90ZTogWydzY29wZTEnLCdzY29wZTInXSA9PiByZW1vdGVbJ3Njb3BlMSddID0gaG9zdFNoYXJlU2NvcGVNYXBbJ3Njb3BlMSddOyByZW1vdGVbJ3Njb3BlMiddID0gaG9zdFNoYXJlU2NvcGVNYXBbJ3Njb3BlMiddID0ge307XG4gICAgaWYgKCFzaGFyZVNjb3BlS2V5IHx8IHR5cGVvZiBzaGFyZVNjb3BlS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBrZXkgPSBzaGFyZVNjb3BlS2V5IHx8ICdkZWZhdWx0JztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaG9zdFNoYXJlU2NvcGVLZXlzKSkge1xuICAgICAgICAgICAgLy8gY29uc3Qgc2MgPSBob3N0U2hhcmVTY29wZU1hcCFba2V5XTtcbiAgICAgICAgICAgIC8vIGlmICghc2MpIHtcbiAgICAgICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZVNjb3BlS2V5IGlzIG5vdCBleGlzdCBpbiBob3N0U2hhcmVTY29wZU1hcCcpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gZmVkZXJhdGlvbkluc3RhbmNlLmluaXRTaGFyZVNjb3BlTWFwKGtleSwgc2MsIHtcbiAgICAgICAgICAgIC8vICAgaG9zdFNoYXJlU2NvcGVNYXA6IHJlbW90ZUVudHJ5SW5pdE9wdGlvbnM/LnNoYXJlU2NvcGVNYXAgfHwge30sXG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIGhvc3RTaGFyZVNjb3BlS2V5cy5mb3JFYWNoKChob3N0S2V5KT0+e1xuICAgICAgICAgICAgICAgIGlmICghaG9zdFNoYXJlU2NvcGVNYXBbaG9zdEtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNoYXJlU2NvcGVNYXBbaG9zdEtleV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2MgPSBob3N0U2hhcmVTY29wZU1hcFtob3N0S2V5XTtcbiAgICAgICAgICAgICAgICBmZWRlcmF0aW9uSW5zdGFuY2UuaW5pdFNoYXJlU2NvcGVNYXAoaG9zdEtleSwgc2MsIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNoYXJlU2NvcGVNYXA6IChyZW1vdGVFbnRyeUluaXRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiByZW1vdGVFbnRyeUluaXRPcHRpb25zLnNoYXJlU2NvcGVNYXApIHx8IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZlZGVyYXRpb25JbnN0YW5jZS5pbml0U2hhcmVTY29wZU1hcChrZXksIHNoYXJlU2NvcGUsIHtcbiAgICAgICAgICAgICAgICBob3N0U2hhcmVTY29wZU1hcDogKHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMuc2hhcmVTY29wZU1hcCkgfHwge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcmVTY29wZUtleS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBpZiAoIWhvc3RTaGFyZVNjb3BlS2V5cyB8fCAhaG9zdFNoYXJlU2NvcGVNYXApIHtcbiAgICAgICAgICAgICAgICBmZWRlcmF0aW9uSW5zdGFuY2UuaW5pdFNoYXJlU2NvcGVNYXAoa2V5LCBzaGFyZVNjb3BlLCB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RTaGFyZVNjb3BlTWFwOiAocmVtb3RlRW50cnlJbml0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogcmVtb3RlRW50cnlJbml0T3B0aW9ucy5zaGFyZVNjb3BlTWFwKSB8fCB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaG9zdFNoYXJlU2NvcGVNYXBba2V5XSkge1xuICAgICAgICAgICAgICAgIGhvc3RTaGFyZVNjb3BlTWFwW2tleV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNjID0gaG9zdFNoYXJlU2NvcGVNYXBba2V5XTtcbiAgICAgICAgICAgIGZlZGVyYXRpb25JbnN0YW5jZS5pbml0U2hhcmVTY29wZU1hcChrZXksIHNjLCB7XG4gICAgICAgICAgICAgICAgaG9zdFNoYXJlU2NvcGVNYXA6IChyZW1vdGVFbnRyeUluaXRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiByZW1vdGVFbnRyeUluaXRPcHRpb25zLnNoYXJlU2NvcGVNYXApIHx8IHt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmF0dGFjaFNoYXJlU2NvcGVNYXApIHtcbiAgICAgICAgd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5hdHRhY2hTaGFyZVNjb3BlTWFwKHdlYnBhY2tSZXF1aXJlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLnByZWZldGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24ucHJlZmV0Y2goKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNoYXJlU2NvcGVLZXkpKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHdlYnBhY2tSZXF1aXJlLkkoc2hhcmVTY29wZUtleSB8fCAnZGVmYXVsdCcsIGluaXRTY29wZSk7XG4gICAgfVxuICAgIHZhciBwcm94eUluaXRpYWxpemVTaGFyaW5nID0gQm9vbGVhbih3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmluaXRPcHRpb25zLnNoYXJlZCk7XG4gICAgaWYgKHByb3h5SW5pdGlhbGl6ZVNoYXJpbmcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gd2VicGFja1JlcXVpcmUuSShzaGFyZVNjb3BlS2V5LCBpbml0U2NvcGUpO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHNoYXJlU2NvcGVLZXkubWFwKChrZXkpPT57XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHdlYnBhY2tSZXF1aXJlLkkoa2V5LCBpbml0U2NvcGUpO1xuICAgIH0pKS50aGVuKCgpPT50cnVlKTtcbn1cblxuY29uc3QgZmVkZXJhdGlvbiA9IHtcbiAgICBydW50aW1lLFxuICAgIGluc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgaW5pdE9wdGlvbnM6IHVuZGVmaW5lZCxcbiAgICBidW5kbGVyUnVudGltZToge1xuICAgICAgICByZW1vdGVzLFxuICAgICAgICBjb25zdW1lcyxcbiAgICAgICAgSTogaW5pdGlhbGl6ZVNoYXJpbmcsXG4gICAgICAgIFM6IHt9LFxuICAgICAgICBpbnN0YWxsSW5pdGlhbENvbnN1bWVzLFxuICAgICAgICBpbml0Q29udGFpbmVyRW50cnlcbiAgICB9LFxuICAgIGF0dGFjaFNoYXJlU2NvcGVNYXAsXG4gICAgYnVuZGxlclJ1bnRpbWVPcHRpb25zOiB7fVxufTtcblxuZXhwb3J0IHsgZmVkZXJhdGlvbiBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/webpack-bundler-runtime/dist/index.esm.js\n");

/***/ }),

/***/ "data:text/javascript;base64,CiAgICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgewogICAgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUgPSBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZSB8fCBuZXcgU2V0KCk7CiAgICBtb2R1bGUuZmlsZW5hbWUgJiYgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUuYWRkKG1vZHVsZS5maWxlbmFtZSk7CiAgICBpZihtb2R1bGUuY2hpbGRyZW4pIHsKICAgIG1vZHVsZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHsKICAgICAgYy5maWxlbmFtZSAmJiBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZS5hZGQoYy5maWxlbmFtZSk7CiAgICB9KQp9CiAgfQogICAg":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:text/javascript;base64,CiAgICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgewogICAgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUgPSBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZSB8fCBuZXcgU2V0KCk7CiAgICBtb2R1bGUuZmlsZW5hbWUgJiYgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUuYWRkKG1vZHVsZS5maWxlbmFtZSk7CiAgICBpZihtb2R1bGUuY2hpbGRyZW4pIHsKICAgIG1vZHVsZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHsKICAgICAgYy5maWxlbmFtZSAmJiBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZS5hZGQoYy5maWxlbmFtZSk7CiAgICB9KQp9CiAgfQogICAg ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n    if(typeof module !== 'undefined') {\n    globalThis.entryChunkCache = globalThis.entryChunkCache || new Set();\n    module.filename && globalThis.entryChunkCache.add(module.filename);\n    if(module.children) {\n    module.children.forEach(function(c) {\n      c.filename && globalThis.entryChunkCache.add(c.filename);\n    })\n}\n  }\n    //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YTp0ZXh0L2phdmFzY3JpcHQ7YmFzZTY0LENpQWdJQ0JwWmloMGVYQmxiMllnYlc5a2RXeGxJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5a2dld29nSUNBZ1oyeHZZbUZzVkdocGN5NWxiblJ5ZVVOb2RXNXJRMkZqYUdVZ1BTQm5iRzlpWVd4VWFHbHpMbVZ1ZEhKNVEyaDFibXREWVdOb1pTQjhmQ0J1WlhjZ1UyVjBLQ2s3Q2lBZ0lDQnRiMlIxYkdVdVptbHNaVzVoYldVZ0ppWWdaMnh2WW1Gc1ZHaHBjeTVsYm5SeWVVTm9kVzVyUTJGamFHVXVZV1JrS0cxdlpIVnNaUzVtYVd4bGJtRnRaU2s3Q2lBZ0lDQnBaaWh0YjJSMWJHVXVZMmhwYkdSeVpXNHBJSHNLSUNBZ0lHMXZaSFZzWlM1amFHbHNaSEpsYmk1bWIzSkZZV05vS0daMWJtTjBhVzl1S0dNcElIc0tJQ0FnSUNBZ1l5NW1hV3hsYm1GdFpTQW1KaUJuYkc5aVlXeFVhR2x6TG1WdWRISjVRMmgxYm10RFlXTm9aUzVoWkdRb1l5NW1hV3hsYm1GdFpTazdDaUFnSUNCOUtRcDlDaUFnZlFvZ0lDQWciLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJkYXRhOnRleHQvamF2YXNjcmlwdDtiYXNlNjQsQ2lBZ0lDQnBaaWgwZVhCbGIyWWdiVzlrZFd4bElDRTlQU0FuZFc1a1pXWnBibVZrSnlrZ2V3b2dJQ0FnWjJ4dlltRnNWR2hwY3k1bGJuUnllVU5vZFc1clEyRmphR1VnUFNCbmJHOWlZV3hVYUdsekxtVnVkSEo1UTJoMWJtdERZV05vWlNCOGZDQnVaWGNnVTJWMEtDazdDaUFnSUNCdGIyUjFiR1V1Wm1sc1pXNWhiV1VnSmlZZ1oyeHZZbUZzVkdocGN5NWxiblJ5ZVVOb2RXNXJRMkZqYUdVdVlXUmtLRzF2WkhWc1pTNW1hV3hsYm1GdFpTazdDaUFnSUNCcFppaHRiMlIxYkdVdVkyaHBiR1J5Wlc0cElIc0tJQ0FnSUcxdlpIVnNaUzVqYUdsc1pISmxiaTVtYjNKRllXTm9LR1oxYm1OMGFXOXVLR01wSUhzS0lDQWdJQ0FnWXk1bWFXeGxibUZ0WlNBbUppQm5iRzlpWVd4VWFHbHpMbVZ1ZEhKNVEyaDFibXREWVdOb1pTNWhaR1FvWXk1bWFXeGxibUZ0WlNrN0NpQWdJQ0I5S1FwOUNpQWdmUW9nSUNBZyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbFRoaXMuZW50cnlDaHVua0NhY2hlID0gZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUgfHwgbmV3IFNldCgpO1xuICAgIG1vZHVsZS5maWxlbmFtZSAmJiBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZS5hZGQobW9kdWxlLmZpbGVuYW1lKTtcbiAgICBpZihtb2R1bGUuY2hpbGRyZW4pIHtcbiAgICBtb2R1bGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICBjLmZpbGVuYW1lICYmIGdsb2JhbFRoaXMuZW50cnlDaHVua0NhY2hlLmFkZChjLmZpbGVuYW1lKTtcbiAgICB9KVxufVxuICB9XG4gICAgIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///data:text/javascript;base64,CiAgICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgewogICAgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUgPSBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZSB8fCBuZXcgU2V0KCk7CiAgICBtb2R1bGUuZmlsZW5hbWUgJiYgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUuYWRkKG1vZHVsZS5maWxlbmFtZSk7CiAgICBpZihtb2R1bGUuY2hpbGRyZW4pIHsKICAgIG1vZHVsZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHsKICAgICAgYy5maWxlbmFtZSAmJiBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZS5hZGQoYy5maWxlbmFtZSk7CiAgICB9KQp9CiAgfQogICAg\n");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "next/amp":
/*!***************************!*\
  !*** external "next/amp" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("next/amp");

/***/ }),

/***/ "next/dist/compiled/next-server/pages.runtime.dev.js":
/*!**********************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages.runtime.dev.js" ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages.runtime.dev.js");

/***/ }),

/***/ "next/error":
/*!*****************************!*\
  !*** external "next/error" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("next/error");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "styled-jsx/style":
/*!***********************************!*\
  !*** external "styled-jsx/style" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("styled-jsx/style");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		__webpack_require__.O(undefined, ["vendor-chunks/@module-federation","vendor-chunks/federation"], () => (__webpack_require__("data:text/javascript;base64,CiAgICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgewogICAgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUgPSBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZSB8fCBuZXcgU2V0KCk7CiAgICBtb2R1bGUuZmlsZW5hbWUgJiYgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUuYWRkKG1vZHVsZS5maWxlbmFtZSk7CiAgICBpZihtb2R1bGUuY2hpbGRyZW4pIHsKICAgIG1vZHVsZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHsKICAgICAgYy5maWxlbmFtZSAmJiBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZS5hZGQoYy5maWxlbmFtZSk7CiAgICB9KQp9CiAgfQogICAg")))
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendor-chunks/@module-federation","vendor-chunks/federation"], () => (__webpack_require__("./node_modules/@module-federation/nextjs-mf/dist/src/federation-noop.cjs")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/federation runtime */
/******/ 	(() => {
/******/ 		if(!__webpack_require__.federation){
/******/ 			__webpack_require__.federation = {
/******/ 				initOptions: {"name":"chart_app","remotes":[],"shareStrategy":"loaded-first"},
/******/ 				chunkMatcher: function(chunkId) {return /^(vendor\-chunks\/(react(|\-dom)|@module\-federation|@swc|next|styled\-jsx)|noop)$/.test(chunkId)},
/******/ 				rootOutputDir: "",
/******/ 				initialConsumes: undefined,
/******/ 				bundlerRuntimeOptions: {}
/******/ 			};
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and chunks that the entrypoint depends on
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames not based on template
/******/ 			if (chunkId === "vendor-chunks/@module-federation") return "" + chunkId + ".js";
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "-" + {"vendor-chunks/next":"2188348ef05effe8","vendor-chunks/@swc":"1c9bd094e25d0b1c","vendor-chunks/styled-jsx":"596706bdb5dac08b","vendor-chunks/react":"28b23072ff70a8d0","vendor-chunks/react-dom":"f0fba393cb182cc5"}[chunkId] + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/runtimeId */
/******/ 	(() => {
/******/ 		__webpack_require__.j = "noop";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/sharing */
/******/ 	(() => {
/******/ 		__webpack_require__.S = {};
/******/ 		var initPromises = {};
/******/ 		var initTokens = {};
/******/ 		__webpack_require__.I = (name, initScope) => {
/******/ 			if(!initScope) initScope = [];
/******/ 			// handling circular init calls
/******/ 			var initToken = initTokens[name];
/******/ 			if(!initToken) initToken = initTokens[name] = {};
/******/ 			if(initScope.indexOf(initToken) >= 0) return;
/******/ 			initScope.push(initToken);
/******/ 			// only runs once
/******/ 			if(initPromises[name]) return initPromises[name];
/******/ 			// creates a new share scope if needed
/******/ 			if(!__webpack_require__.o(__webpack_require__.S, name)) __webpack_require__.S[name] = {};
/******/ 			// runs all init snippets from all modules reachable
/******/ 			var scope = __webpack_require__.S[name];
/******/ 			var warn = (msg) => {
/******/ 				if (typeof console !== "undefined" && console.warn) console.warn(msg);
/******/ 			};
/******/ 			var uniqueName = "chart_app";
/******/ 			var register = (name, version, factory, eager) => {
/******/ 				var versions = scope[name] = scope[name] || {};
/******/ 				var activeVersion = versions[version];
/******/ 				if(!activeVersion || (!activeVersion.loaded && (!eager != !activeVersion.eager ? eager : uniqueName > activeVersion.from))) versions[version] = { get: factory, from: uniqueName, eager: !!eager };
/******/ 			};
/******/ 			var initExternal = (id) => {
/******/ 				var handleError = (err) => (warn("Initialization of sharing external failed: " + err));
/******/ 				try {
/******/ 					var module = __webpack_require__(id);
/******/ 					if(!module) return;
/******/ 					var initFn = (module) => (module && module.init && module.init(__webpack_require__.S[name], initScope))
/******/ 					if(module.then) return promises.push(module.then(initFn, handleError));
/******/ 					var initResult = initFn(module);
/******/ 					if(initResult && initResult.then) return promises.push(initResult['catch'](handleError));
/******/ 				} catch(err) { handleError(err); }
/******/ 			}
/******/ 			var promises = [];
/******/ 			switch(name) {
/******/ 				case "default": {
/******/ 					register("next/dynamic", "15.5.0", () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react_jsx-runtime_react_jsx-runtime-webpack_sharing_consume_d-e697260")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/dynamic.js */ "./node_modules/next/dynamic.js"))))));
/******/ 					register("next/head", "15.5.0", () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react_jsx-runtime_react_jsx-runtime-webpack_sharing_consume_d-e697261")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/head.js */ "./node_modules/next/head.js"))))));
/******/ 					register("next/image", "15.5.0", () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_jsx-f679790")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/image.js */ "./node_modules/next/image.js"))))));
/******/ 					register("next/link", "15.5.0", () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react_jsx-runtime_react_jsx-runtime-webpack_sharing_consume_d-e697262")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/link.js */ "./node_modules/next/link.js"))))));
/******/ 					register("next/router", "15.5.0", () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_jsx-f679791")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/router.js */ "./node_modules/next/router.js"))))));
/******/ 					register("next/script", "15.5.0", () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_jsx-f679792")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/script.js */ "./node_modules/next/script.js"))))));
/******/ 					register("react-dom", "19.1.0", () => (Promise.all([__webpack_require__.e("vendor-chunks/react-dom"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_2f6e")]).then(() => (() => (__webpack_require__(/*! ./node_modules/react-dom/index.js */ "./node_modules/react-dom/index.js"))))));
/******/ 					register("react/jsx-dev-runtime", "19.1.0", () => (Promise.all([__webpack_require__.e("vendor-chunks/react"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_7ca41")]).then(() => (() => (__webpack_require__(/*! ./node_modules/react/jsx-dev-runtime.js */ "./node_modules/react/jsx-dev-runtime.js"))))));
/******/ 					register("react/jsx-runtime", "19.1.0", () => (Promise.all([__webpack_require__.e("vendor-chunks/react"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_7ca40")]).then(() => (() => (__webpack_require__(/*! ./node_modules/react/jsx-runtime.js */ "./node_modules/react/jsx-runtime.js"))))));
/******/ 					register("react", "19.1.0", () => (__webpack_require__.e("vendor-chunks/react").then(() => (() => (__webpack_require__(/*! ./node_modules/react/index.js */ "./node_modules/react/index.js"))))));
/******/ 					register("styled-jsx", "5.1.6", () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/styled-jsx"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_bce7")]).then(() => (() => (__webpack_require__(/*! ./node_modules/styled-jsx/index.js */ "./node_modules/styled-jsx/index.js"))))));
/******/ 				}
/******/ 				break;
/******/ 			}
/******/ 			if(!promises.length) return initPromises[name] = 1;
/******/ 			return initPromises[name] = Promise.all(promises).then(() => (initPromises[name] = 1));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup entrypoint */
/******/ 	(() => {
/******/ 		__webpack_require__.X = (result, chunkIds, fn) => {
/******/ 			// arguments: chunkIds, moduleId are deprecated
/******/ 			var moduleId = chunkIds;
/******/ 			if(!fn) chunkIds = result, fn = () => (__webpack_require__(__webpack_require__.s = moduleId));
/******/ 			return Promise.all(chunkIds.map(__webpack_require__.e, __webpack_require__)).then(() => {
/******/ 				var r = fn();
/******/ 				return r === undefined ? result : r;
/******/ 			})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup entrypoint */
/******/ 	(() => {
/******/ 		__webpack_require__.X = (result, chunkIds, fn) => {
/******/ 			// arguments: chunkIds, moduleId are deprecated
/******/ 			var moduleId = chunkIds;
/******/ 			if(!fn) chunkIds = result, fn = () => (__webpack_require__(__webpack_require__.s = moduleId));
/******/ 			return Promise.all(chunkIds.map(__webpack_require__.e, __webpack_require__)).then(() => {
/******/ 				var r = fn();
/******/ 				return r === undefined ? result : r;
/******/ 			})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/sharing */
/******/ 	(() => {
/******/ 		__webpack_require__.federation.initOptions.shared = {	"next/dynamic": [{	version: "15.5.0",
/******/ 				get: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react_jsx-runtime_react_jsx-runtime-webpack_sharing_consume_d-e697260")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/dynamic.js */ "./node_modules/next/dynamic.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"singleton":true,"layer":null}},],	"next/head": [{	version: "15.5.0",
/******/ 				get: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react_jsx-runtime_react_jsx-runtime-webpack_sharing_consume_d-e697261")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/head.js */ "./node_modules/next/head.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"singleton":true,"layer":null}},],	"next/image": [{	version: "15.5.0",
/******/ 				get: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_jsx-f679790")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/image.js */ "./node_modules/next/image.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"singleton":true,"layer":null}},],	"next/link": [{	version: "15.5.0",
/******/ 				get: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react_jsx-runtime_react_jsx-runtime-webpack_sharing_consume_d-e697262")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/link.js */ "./node_modules/next/link.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"singleton":true,"layer":null}},],	"next/router": [{	version: "15.5.0",
/******/ 				get: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_jsx-f679791")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/router.js */ "./node_modules/next/router.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"singleton":true,"layer":null}},],	"next/script": [{	version: "15.5.0",
/******/ 				get: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_jsx-f679792")]).then(() => (() => (__webpack_require__(/*! ./node_modules/next/script.js */ "./node_modules/next/script.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"singleton":true,"layer":null}},],	"react-dom": [{	version: "19.1.0",
/******/ 				get: () => (Promise.all([__webpack_require__.e("vendor-chunks/react-dom"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_2f6e")]).then(() => (() => (__webpack_require__(/*! ./node_modules/react-dom/index.js */ "./node_modules/react-dom/index.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"singleton":true,"layer":null}},],	"react/jsx-dev-runtime": [{	version: "19.1.0",
/******/ 				get: () => (Promise.all([__webpack_require__.e("vendor-chunks/react"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_7ca41")]).then(() => (() => (__webpack_require__(/*! ./node_modules/react/jsx-dev-runtime.js */ "./node_modules/react/jsx-dev-runtime.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"singleton":true,"layer":null}},],	"react/jsx-runtime": [{	version: "19.1.0",
/******/ 				get: () => (Promise.all([__webpack_require__.e("vendor-chunks/react"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_7ca40")]).then(() => (() => (__webpack_require__(/*! ./node_modules/react/jsx-runtime.js */ "./node_modules/react/jsx-runtime.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"singleton":true,"layer":null}},],	"react": [{	version: "19.1.0",
/******/ 				get: () => (__webpack_require__.e("vendor-chunks/react").then(() => (() => (__webpack_require__(/*! ./node_modules/react/index.js */ "./node_modules/react/index.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"singleton":true,"layer":null}},],	"styled-jsx": [{	version: "5.1.6",
/******/ 				get: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/styled-jsx"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_bce7")]).then(() => (() => (__webpack_require__(/*! ./node_modules/styled-jsx/index.js */ "./node_modules/styled-jsx/index.js"))))),
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":"^5.1.6","singleton":true,"layer":null}},],}
/******/ 		__webpack_require__.S = {};
/******/ 		var initPromises = {};
/******/ 		var initTokens = {};
/******/ 		__webpack_require__.I = (name, initScope) => {
/******/ 			return __webpack_require__.federation.bundlerRuntime.I({	shareScopeName: name,
/******/ 				webpackRequire: __webpack_require__,
/******/ 				initPromises: initPromises,
/******/ 				initTokens: initTokens,
/******/ 				initScope: initScope,
/******/ 			})
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/consumes */
/******/ 	(() => {
/******/ 		var installedModules = {};
/******/ 		var moduleToHandlerMapping = {
/******/ 			"webpack/sharing/consume/default/next/head/next/head": {
/******/ 				getter: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_bc8f0")]).then(() => (() => (__webpack_require__(/*! next/head */ "./node_modules/next/head.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14 || ^15",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/head",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/router/next/router": {
/******/ 				getter: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_rea-b25f760")]).then(() => (() => (__webpack_require__(/*! next/router */ "./node_modules/next/router.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/router",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/link/next/link": {
/******/ 				getter: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_bc8f1")]).then(() => (() => (__webpack_require__(/*! next/link */ "./node_modules/next/link.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14 || ^15",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/link",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/script/next/script": {
/******/ 				getter: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_rea-b25f761")]).then(() => (() => (__webpack_require__(/*! next/script */ "./node_modules/next/script.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14 || ^15",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/script",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/image/next/image": {
/******/ 				getter: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_rea-b25f762")]).then(() => (() => (__webpack_require__(/*! next/image */ "./node_modules/next/image.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14 || ^15",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/image",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/dynamic/next/dynamic": {
/******/ 				getter: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/@swc"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_bc8f2")]).then(() => (() => (__webpack_require__(/*! next/dynamic */ "./node_modules/next/dynamic.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14 || ^15",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/dynamic",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/styled-jsx/styled-jsx": {
/******/ 				getter: () => (Promise.all([__webpack_require__.e("vendor-chunks/next"), __webpack_require__.e("vendor-chunks/styled-jsx"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_bce7")]).then(() => (() => (__webpack_require__(/*! styled-jsx */ "./node_modules/styled-jsx/index.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^5.1.6",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "styled-jsx",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime": {
/******/ 				getter: () => (Promise.all([__webpack_require__.e("vendor-chunks/react"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_7ca40")]).then(() => (() => (__webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react/jsx-runtime",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react/react?bc8f": {
/******/ 				getter: () => (__webpack_require__.e("vendor-chunks/react").then(() => (() => (__webpack_require__(/*! react */ "./node_modules/react/index.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^18.2.0 || 19.0.0-rc-de68d2f4-20241204 || ^19.0.0",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react-dom/react-dom": {
/******/ 				getter: () => (Promise.all([__webpack_require__.e("vendor-chunks/react-dom"), __webpack_require__.e("webpack_sharing_consume_default_react_react-_2f6e")]).then(() => (() => (__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^18.2.0 || 19.0.0-rc-de68d2f4-20241204 || ^19.0.0",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react-dom",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react/react?bce7": {
/******/ 				getter: () => (__webpack_require__.e("vendor-chunks/react").then(() => (() => (__webpack_require__(/*! react */ "./node_modules/react/index.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": ">= 16.8.0 || 17.x.x || ^18.0.0-0 || ^19.0.0-0",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react/react?7ca4": {
/******/ 				getter: () => (__webpack_require__.e("vendor-chunks/react").then(() => (() => (__webpack_require__(/*! react */ "./node_modules/react/index.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react/react?2f6e": {
/******/ 				getter: () => (__webpack_require__.e("vendor-chunks/react").then(() => (() => (__webpack_require__(/*! react */ "./node_modules/react/index.js"))))),
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^19.1.0",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react",
/******/ 			}
/******/ 		};
/******/ 		var initialConsumes = ["webpack/sharing/consume/default/next/head/next/head","webpack/sharing/consume/default/next/router/next/router","webpack/sharing/consume/default/next/link/next/link","webpack/sharing/consume/default/next/script/next/script","webpack/sharing/consume/default/next/image/next/image","webpack/sharing/consume/default/next/dynamic/next/dynamic","webpack/sharing/consume/default/styled-jsx/styled-jsx","webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime"];
/******/ 		__webpack_require__.federation.installInitialConsumes = () => (__webpack_require__.federation.bundlerRuntime.installInitialConsumes({
/******/ 			initialConsumes: initialConsumes,
/******/ 			installedModules:installedModules,
/******/ 			moduleToHandlerMapping:moduleToHandlerMapping,
/******/ 			webpackRequire: __webpack_require__
/******/ 		}))
/******/ 		var chunkMapping = {
/******/ 			"noop": [
/******/ 				"webpack/sharing/consume/default/next/head/next/head",
/******/ 				"webpack/sharing/consume/default/next/router/next/router",
/******/ 				"webpack/sharing/consume/default/next/link/next/link",
/******/ 				"webpack/sharing/consume/default/next/script/next/script",
/******/ 				"webpack/sharing/consume/default/next/image/next/image",
/******/ 				"webpack/sharing/consume/default/next/dynamic/next/dynamic",
/******/ 				"webpack/sharing/consume/default/styled-jsx/styled-jsx",
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react_react-_bc8f0": [
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_rea-b25f760": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom",
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react_react-_bc8f1": [
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_rea-b25f761": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom",
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_rea-b25f762": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom",
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react_react-_bc8f2": [
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react_react-_bce7": [
/******/ 				"webpack/sharing/consume/default/react/react?bce7"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react_react-_7ca40": [
/******/ 				"webpack/sharing/consume/default/react/react?7ca4"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react_jsx-runtime_react_jsx-runtime-webpack_sharing_consume_d-e697260": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react_jsx-runtime_react_jsx-runtime-webpack_sharing_consume_d-e697261": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_jsx-f679790": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom",
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react_jsx-runtime_react_jsx-runtime-webpack_sharing_consume_d-e697262": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_jsx-f679791": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom",
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react-dom_react-dom-webpack_sharing_consume_default_react_jsx-f679792": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom",
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react?bc8f"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react_react-_2f6e": [
/******/ 				"webpack/sharing/consume/default/react/react?2f6e"
/******/ 			],
/******/ 			"webpack_sharing_consume_default_react_react-_7ca41": [
/******/ 				"webpack/sharing/consume/default/react/react?7ca4"
/******/ 			]
/******/ 		};
/******/ 		__webpack_require__.f.consumes = (chunkId, promises) => {
/******/ 			__webpack_require__.federation.bundlerRuntime.consumes({
/******/ 			chunkMapping: chunkMapping,
/******/ 			installedModules: installedModules,
/******/ 			chunkId: chunkId,
/******/ 			moduleToHandlerMapping: moduleToHandlerMapping,
/******/ 			promises: promises,
/******/ 			webpackRequire:__webpack_require__
/******/ 			});
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/embed/federation */
/******/ 	(() => {
/******/ 		var prevStartup = __webpack_require__.x;
/******/ 		var hasRun = false;
/******/ 		__webpack_require__.x = () => {
/******/ 			if (!hasRun) {
/******/ 			  hasRun = true;
/******/ 			  __webpack_require__(/*! ./node_modules/.federation/entry.42f9d6ddc353237f58b0246cec23d53e.js */ "./node_modules/.federation/entry.42f9d6ddc353237f58b0246cec23d53e.js");
/******/ 			}
/******/ 			if (typeof prevStartup === 'function') {
/******/ 			  return prevStartup();
/******/ 			} else {
/******/ 			  console.warn('[Module Federation] prevStartup is not a function, skipping startup execution');
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/readFile chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "0" means "already loaded", Promise means loading
/******/ 		var installedChunks = {
/******/ 			"noop": 0,
/******/ 			"vendor-chunks/federation": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.O.readFileVm = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++) {
/******/ 				if(installedChunks[chunkIds[i]]) {
/******/ 					installedChunks[chunkIds[i]][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			__webpack_require__.O();
/******/ 		};
/******/ 		
/******/ 		// ReadFile + VM.run chunk loading for javascript
/******/ 		__webpack_require__.f.readFileVm = function(chunkId, promises) {
/******/ 		
/******/ 			var installedChunkData = installedChunks[chunkId];
/******/ 			if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 				// array of [resolve, reject, promise] means "currently loading"
/******/ 				if(installedChunkData) {
/******/ 					promises.push(installedChunkData[2]);
/******/ 				} else {
/******/ 					if(/^(vendor\-chunks\/(react(|\-dom)|@module\-federation|@swc|next|styled\-jsx)|noop)$/.test(chunkId)) {
/******/ 						// load the chunk and return promise to it
/******/ 						var promise = new Promise(function(resolve, reject) {
/******/ 							installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 							var filename = require("node:path").join(__dirname, "" + __webpack_require__.u(chunkId));
/******/ 							require("node:fs").readFile(filename, 'utf-8', function(err, content) {
/******/ 								if(err) return reject(err);
/******/ 								var chunk = {};
/******/ 								require("node:vm").runInThisContext('(function(exports, require, __dirname, __filename) {' + content + '\n})', filename)(chunk, require, require("node:path").dirname(filename), filename);
/******/ 								installChunk(chunk);
/******/ 							});
/******/ 						});
/******/ 						promises.push(installedChunkData[2] = promise);
/******/ 					} else installedChunks[chunkId] = 0;
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return Promise.all([
/******/ 				__webpack_require__.e("vendor-chunks/@module-federation"),
/******/ 				__webpack_require__.e("vendor-chunks/federation")
/******/ 			]).then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ 	
/******/ 	
/******/ 	
/******/ 	var promises = [];
/******/ 	if (typeof __webpack_require__.x === "function") {
/******/ 	  __webpack_require__.x();
/******/ 	} else {
/******/ 	  console.warn("[Module Federation] __webpack_require__.x is not a function, skipping startup extension");
/******/ 	}
/******/ 	var __webpack_exports__ = Promise.all([
/******/ 		__webpack_require__.f.consumes || function(chunkId, promises) {},
/******/ 		__webpack_require__.f.remotes || function(chunkId, promises) {},
/******/ 	].reduce((p, handler) => (handler('noop', p), p), promises)
/******/ 	).then(() => (__webpack_require__.X(0, ["vendor-chunks/@module-federation","vendor-chunks/federation"], () => (__webpack_exec__("data:text/javascript;base64,CiAgICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgewogICAgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUgPSBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZSB8fCBuZXcgU2V0KCk7CiAgICBtb2R1bGUuZmlsZW5hbWUgJiYgZ2xvYmFsVGhpcy5lbnRyeUNodW5rQ2FjaGUuYWRkKG1vZHVsZS5maWxlbmFtZSk7CiAgICBpZihtb2R1bGUuY2hpbGRyZW4pIHsKICAgIG1vZHVsZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpIHsKICAgICAgYy5maWxlbmFtZSAmJiBnbG9iYWxUaGlzLmVudHJ5Q2h1bmtDYWNoZS5hZGQoYy5maWxlbmFtZSk7CiAgICB9KQp9CiAgfQogICAg"), __webpack_exec__("./node_modules/@module-federation/nextjs-mf/dist/src/federation-noop.cjs")))));
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;